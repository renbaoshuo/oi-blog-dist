<!-- Baoshuo's OI Blog (99786fb) | Baoshuo ( https://baoshuo.ren ) -->
<!DOCTYPE html><html data-color-mode=auto data-dark-theme=dark data-light-theme=light lang=zh-cn><head><meta charset=utf-8><meta content="width=device-width, initial-scale=1" name=viewport><meta content=webkit name=renderer><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="telephone=no" name=format-detection><title>Link-Cut Tree 学习笔记 - 宝硕博客</title><meta content="Link-Cut Tree 是一种用来解决动态树问题的数据结构。" name=description><meta content="数据结构,Treap,动态树,Link-Cut Tree,Splay,宝硕博客,宝硕,Baoshuo,博客,OI,信息学竞赛,信息学奥赛,信息学奥林匹克竞赛" name=keywords><meta content="Link-Cut Tree 学习笔记 - 宝硕博客" property=og:title><meta content=article property=og:type><meta content=https://oi.baoshuo.ren/link-cut-tree/ property=og:url><meta content=https://cdn.jsdelivr.net/npm/bsi@0.0.7/favicon/128x128.png property=og:image><meta content="Link-Cut Tree 是一种用来解决动态树问题的数据结构。" property=og:description><meta content=summary name=twitter:card><meta name=twitter:site><meta content="Link-Cut Tree 学习笔记 - 宝硕博客" name=twitter:title><meta content="Link-Cut Tree 是一种用来解决动态树问题的数据结构。" name=twitter:description><meta content=https://cdn.jsdelivr.net/npm/bsi@0.0.7/favicon/128x128.png name=twitter:image><meta content=宝硕博客 name=twitter:image:alt><meta content="Link-Cut Tree 学习笔记 - 宝硕博客" itemprop=name><meta content="Link-Cut Tree 是一种用来解决动态树问题的数据结构。" itemprop=description><meta content=https://cdn.jsdelivr.net/npm/bsi@0.0.7/favicon/128x128.png itemprop=image><link href=//oi.baoshuo.ren/link-cut-tree/ rel=canonical><link href="//static.cdn.baoshuo.ren/oi-blog/styles/app.cc1292c.css?v=99786fb" rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/base.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/layout.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/utilities.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/subhead.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/navigation.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/labels.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/links.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/alerts.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/loaders.min.css rel=stylesheet><script>setTimeout((function(){"serviceWorker"in navigator&&"oi.baoshuo.ren"===location.hostname&&navigator.serviceWorker.register("/sw.js")}),750);</script><script async data-api=https://stat.u.sb/api/event data-domain=oi.baoshuo.ren src="//static.cdn.baoshuo.ren/oi-blog/scripts/plausible.036d279.js?v=99786fb"></script><script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)};</script><meta content="Hexo 6.2.0" name=generator><link href=/atom.xml rel=alternate title=宝硕博客 type=application/atom+xml></head><body class="AppFrame overflow-y-scroll"><div class="AppFrame-a11yNav border-bottom color-shadow-medium"><a class=AppFrame-a11yLink href=#start-of-content>Skip to content</a></div><div class=AppFrame-main><div class=AppFrame-header-wrapper><header class="AppFrame-subheader border-bottom color-bg-default py-2 user-select-none"><nav class="container-lg d-flex flex-column flex-items-center flex-md-justify-between flex-md-row px-3"><a class="color-fg-default h3 no-underline text-bold" href=/>宝硕博客</a><ul class="d-flex flex-items-center flex-justify-center flex-md-justify-end flex-wrap list-style-none"><li class="d-flex flex-items-center mr-2 my-1 my-lg-0"><a class="color-fg-default no-underline" href=/>首页</a></li><li class="d-flex flex-items-center mx-2 my-1 my-lg-0"><a class="color-fg-default no-underline" href=/archives/>归档</a></li><li class="d-flex flex-items-center mx-2 my-1 my-lg-0"><a class="color-fg-default no-underline" href=/tags/>标签</a></li><li class="d-flex flex-items-center mx-2 my-1 my-lg-0"><a class="color-fg-default no-underline" href=/friends/>友链</a></li><li class="d-flex flex-items-center mx-2 my-1 my-lg-0"><a class="color-fg-default no-underline" href=/about/>关于</a></li><li class="d-flex flex-items-center mx-2 my-1 my-lg-0"><a class="color-fg-default no-underline" href=/atom.xml><svg aria-hidden=false aria-label="Atom Feed" class="octicon octicon-rss" fill=currentColor height=18 role=img style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;" viewbox="0 0 16 16" width=18><path d="M2.002 2.725a.75.75 0 01.797-.699C8.79 2.42 13.58 7.21 13.974 13.201a.75.75 0 11-1.497.098 10.502 10.502 0 00-9.776-9.776.75.75 0 01-.7-.798zM2 13a1 1 0 112 0 1 1 0 01-2 0zm.84-5.95a.75.75 0 00-.179 1.489c2.509.3 4.5 2.291 4.8 4.8a.75.75 0 101.49-.178A7.003 7.003 0 002.838 7.05z" fill-rule=evenodd></path></svg></a></li><li class="d-flex flex-items-center ml-2 my-1 my-lg-0"><a class="color-fg-default no-underline" href=/search/><svg aria-hidden=false aria-label=Search class="octicon octicon-search" fill=currentColor height=18 role=img style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;" viewbox="0 0 16 16" width=18><path d="M11.5 7a4.499 4.499 0 11-8.998 0A4.499 4.499 0 0111.5 7zm-.82 4.74a6 6 0 111.06-1.06l3.04 3.04a.75.75 0 11-1.06 1.06l-3.04-3.04z" fill-rule=evenodd></path></svg></a></li></ul></nav></header></div><div class=AppFrame-body><div class="flash flash-error flash-full" id=outdated-browser style="display: none;"><div class="container-lg px-3"><svg aria-hidden=false aria-label="Alert Icon" class="octicon octicon-alert" fill=currentColor height=18 role=img style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;" viewbox="0 0 16 16" width=18><path d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z" fill-rule=evenodd></path></svg>您的浏览器版本过低，可能会导致部分内容无法正常显示。推荐使用最新版本的 <a href=https://www.google.cn/chrome/ rel=noopener target=_blank>Google Chrome</a> 浏览器访问本站。</div></div><script>"CSS"in window&&"supports"in CSS&&CSS.supports("display","grid")&&"fetch"in window&&"IntersectionObserver"in window||(document.getElementById("outdated-browser").style.display="block");</script><div class="flash flash-full flash-warn" id=dark-reader-alert style="display: none;"><div class="container-lg d-flex flex-items-center px-lg-3"><svg aria-hidden=false aria-label="Alert Icon" class="octicon octicon-alert" fill=currentColor height=18 role=img style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;" viewbox="0 0 16 16" width=18><path d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z" fill-rule=evenodd></path></svg><div><p class="h5 mb-1">您似乎正在使用 Dark Reader</p><p class=text-small>本站支持根据系统偏好开启深色模式，使用 Dark Reader 可能会导致内容显示异常，推荐对本站禁用 Dark Reader。</p></div></div></div><div id=start-of-content></div><main class=py-3><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/markdown.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/actionlist.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/highlight.js/11.5.1/styles/github.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/highlight.js/11.5.1/styles/github-dark.min.css media="(prefers-color-scheme: dark)" rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/buttons.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/Primer/20.3.0/pagination.min.css rel=stylesheet><link href=//cdnjs.baoshuo.ren/ajax/libs/KaTeX/0.16.0/katex.min.css rel=stylesheet><link href="//static.cdn.baoshuo.ren/oi-blog/styles/post.e2db16f.css?v=99786fb" rel=stylesheet><div class="container-lg px-3"><h1 class="bs__page-title mb-2">Link-Cut Tree 学习笔记</h1><div class="border-bottom color-fg-muted d-flex flex-column flex-md-items-end flex-md-justify-between flex-md-row mb-3 pb-3"><div><time datetime=2022-07-15T21:52:19.000Z>2022-07-15</time><span class=dot></span><a class=Link--muted href=/categories/%E7%AC%94%E8%AE%B0/>笔记</a><span class=dot></span><span>约 2.2 千字</span></div><div class="f5 mt-1 mt-lg-0"> <a class=Link--muted href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/># 数据结构</a> <a class="Link--muted ml-1" href=/tags/Treap/># Treap</a> <a class="Link--muted ml-1" href=/tags/%E5%8A%A8%E6%80%81%E6%A0%91/># 动态树</a> <a class="Link--muted ml-1" href=/tags/Link-Cut-Tree/># Link-Cut Tree</a> <a class="Link--muted ml-1" href=/tags/Splay/># Splay</a></div></div><div class="bs__Layout Layout Layout--flowRow-until-md Layout--sidebarPosition-end"><aside class="bs__Layout-sidebar bs__Layout-sidebar-1 Layout-sidebar"><div class="bs__sticky mb-2 position-sticky top-3"><div class="border bs__toc mb-2 overflow-hidden rounded-2"><div class="color-bg-inset mb-0 pt-2 px-3 Subhead" id=toc-heading><h2 class="h5 Subhead-heading"><svg aria-hidden=false aria-label="Table of Contents Icon" class=mr-2 fill=currentColor height=18 role=img style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;" viewbox="0 0 16 16" width=18><path d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z" fill-rule=evenodd></path></svg>文章目录</h2></div><div class="position-relative width-full" id=toc-content><ol class=ActionList><li class="bs__toc-item bs__toc-level-2"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C-2><span class=ActionList-item-label>主要操作</span></a><ol class="ActionList border-left ml-2 pl-2 pr-0"><li class="bs__toc-item bs__toc-level-3"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#splay-%E7%9B%B8%E5%85%B3><span class=ActionList-item-label>Splay 相关</span></a><ol class="ActionList border-left ml-2 pl-2 pr-0"><li class="bs__toc-item bs__toc-level-4"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#isroot-%E5%87%BD%E6%95%B0><span class=ActionList-item-label>isRoot 函数</span></a></li><li class="bs__toc-item bs__toc-level-4"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#%E6%97%8B%E8%BD%AC%EF%BC%88rotate%EF%BC%89%E6%93%8D%E4%BD%9C><span class=ActionList-item-label>旋转（rotate）操作</span></a></li><li class="bs__toc-item bs__toc-level-4"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#splay-%E6%93%8D%E4%BD%9C><span class=ActionList-item-label>Splay 操作</span></a></li></ol></li><li class="bs__toc-item bs__toc-level-3"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#access-%E6%93%8D%E4%BD%9C><span class=ActionList-item-label>Access 操作</span></a></li><li class="bs__toc-item bs__toc-level-3"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#makeroot-%E6%93%8D%E4%BD%9C><span class=ActionList-item-label>makeRoot 操作</span></a></li><li class="bs__toc-item bs__toc-level-3"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#split-%E6%93%8D%E4%BD%9C><span class=ActionList-item-label>Split 操作</span></a></li><li class="bs__toc-item bs__toc-level-3"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#link-%E6%93%8D%E4%BD%9C><span class=ActionList-item-label>Link 操作</span></a></li><li class="bs__toc-item bs__toc-level-3"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#cut-%E6%93%8D%E4%BD%9C><span class=ActionList-item-label>Cut 操作</span></a></li></ol></li><li class="bs__toc-item bs__toc-level-2"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#%E4%BB%A3%E7%A0%81-32><span class=ActionList-item-label>代码</span></a></li><li class="bs__toc-item bs__toc-level-2"><a class="ActionList-content ActionList-item bs__toc-item-inner" href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-10><span class=ActionList-item-label>参考资料</span></a></li></ol></div></div></div></aside><article class="bs__Layout-main bs__Layout-main-1 Layout-main mb-3 mb-md-0"><div class=katex><div class=katex-mathml><div class="flash flash-warn mb-3"><svg aria-hidden=false aria-label="Alert Icon" class="octicon octicon-alert" fill=currentColor height=18 role=img style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;" viewbox="0 0 16 16" width=18><path d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z" fill-rule=evenodd></path></svg>检测到 KaTeX 加载失败，可能会导致文中的数学公式无法正常渲染。</div></div></div><section class=markdown-body id=content><p>Link-Cut Tree 是一种用来解决动态树问题的数据结构。</p> <span id=more></span> <p>它采用类似树链剖分的轻重边路径剖分，把树边分为实边和虚边，并用 Splay 来维护每一条实路径。Link-Cut Tree 的基本操作复杂度为均摊 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(\log n)</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class="mathnormal mord" style=margin-right:0.02778em;>O</span><span class=mopen>(</span><span class=mop>lo<span style=margin-right:0.01389em;>g</span></span><span class=mspace style=margin-right:0.1667em;></span><span class="mathnormal mord">n</span><span class=mclose>)</span></span></span></span>，但常数因子较大，一般效率会低于树链剖分。</p> <section> <h2 id=主要操作-2>主要操作</h2> </section> <section> <h3 id=splay-相关>Splay 相关</h3> <p>LCT 中的 Splay 与原版 Splay 之间存在一定差别。</p> </section> <section> <h4 id=isroot-函数>isRoot 函数</h4> <p>判断节点 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>u</mi></mrow><annotation encoding=application/x-tex>u</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mathnormal mord">u</span></span></span></span> 是否为其所属 Splay 的根。</p> <pre><code class="cpp hljs" data-lang=cpp data-size=0.09><span class=hljs-function><span class=hljs-type>bool</span> <span class=hljs-title>isRoot</span><span class=hljs-params>(<span class=hljs-type>const</span> <span class=hljs-type>size_t</span> &amp;u)</span> </span>&#123;
    <span class=hljs-keyword>return</span> tr[tr[u].f].l != u &amp;&amp; tr[tr[u].f].r != u;
&#125;</code></pre> </section> <section> <h4 id=旋转（rotate）操作>旋转（rotate）操作</h4> <p>判断根不能以父亲节点是否存在为依据，而应该使用上文中的 <code>isRoot()</code> 函数。</p> <div class=bs__tabs><div class="mb-0 tabnav"><nav class="bs__tab-nav tabnav-tabs"><button aria-current=page class=tabnav-tab>对比</button><button class=tabnav-tab>代码</button></nav></div><div class=bs__tab-contents><div class="border-bottom border-x bs__tab-content d-block p-2" data-title=对比><pre><code class="diff hljs" data-lang=diff data-size=0.20> void rotate(size_t u) &#123;
     size_t p = tr[u].f;
     unsigned x = relation(u);

<span class=hljs-deletion>-    if (tr[p].f) &#123;</span>
<span class=hljs-addition>+    if (!isRoot(p)) &#123;</span>
         tr[tr[p].f].child(relation(p)) = u;
     &#125;
     tr[u].f = tr[p].f;</code></pre></div><div class="border-bottom border-x bs__tab-content d-none p-2" data-title=代码><pre><code class="cpp hljs" data-lang=cpp data-size=0.36><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>rotate</span><span class=hljs-params>(<span class=hljs-type>size_t</span> u)</span> </span>&#123;
    <span class=hljs-type>size_t</span> p = tr[u].f;
    <span class=hljs-type>unsigned</span> x = <span class=hljs-built_in>relation</span>(u);

    <span class=hljs-keyword>if</span> (!<span class=hljs-built_in>isRoot</span>(p)) &#123;
        tr[tr[p].f].<span class=hljs-built_in>child</span>(<span class=hljs-built_in>relation</span>(p)) = u;
    &#125;
    tr[u].f = tr[p].f;

    <span class=hljs-keyword>if</span> (tr[u].<span class=hljs-built_in>child</span>(x ^ <span class=hljs-number>1</span>)) &#123;
        tr[tr[u].<span class=hljs-built_in>child</span>(x ^ <span class=hljs-number>1</span>)].f = p;
    &#125;
    tr[p].<span class=hljs-built_in>child</span>(x) = tr[u].<span class=hljs-built_in>child</span>(x ^ <span class=hljs-number>1</span>);

    tr[u].<span class=hljs-built_in>child</span>(x ^ <span class=hljs-number>1</span>) = p;
    tr[p].f = u;

    <span class=hljs-built_in>pushup</span>(p);
    <span class=hljs-built_in>pushup</span>(u);
&#125;</code></pre></div></div></div> </section> <section> <h4 id=splay-操作>Splay 操作</h4> <p>要先自顶到下将路径上的所有节点 pushdown 后再进行 Splay 操作。</p> <div class=bs__tabs><div class="mb-0 tabnav"><nav class="bs__tab-nav tabnav-tabs"><button aria-current=page class=tabnav-tab>对比</button><button class=tabnav-tab>代码</button></nav></div><div class=bs__tab-contents><div class="border-bottom border-x bs__tab-content d-block p-2" data-title=对比><pre><code class="diff hljs" data-lang=diff data-size=0.65><span class=hljs-deletion>-void splay(size_t u, size_t t = 0) &#123;</span>
<span class=hljs-addition>+void splay(size_t u) &#123;</span>
<span class=hljs-addition>+    std::stack&lt;size_t&gt; st;</span>

<span class=hljs-addition>+    size_t cur = u;</span>
<span class=hljs-addition>+    st.push(cur);</span>
<span class=hljs-addition>+    while (!isRoot(cur)) &#123;</span>
<span class=hljs-addition>+        st.push(tr[cur].f);</span>
<span class=hljs-addition>+        cur = tr[cur].f;</span>
<span class=hljs-addition>+    &#125;</span>

<span class=hljs-addition>+    while (!st.empty()) &#123;</span>
<span class=hljs-addition>+        pushdown(st.top());</span>
<span class=hljs-addition>+        st.pop();</span>
<span class=hljs-addition>+    &#125;</span>

<span class=hljs-deletion>-    while (tr[u].f != t) &#123;</span>
<span class=hljs-deletion>-        if (tr[tr[u].f].f == t) &#123;</span>
<span class=hljs-addition>+    while (!isRoot(u)) &#123;</span>
<span class=hljs-addition>+        if (isRoot(tr[u].f)) &#123;</span>
             rotate(u);
         &#125; else if (relation(u) == relation(tr[u].f)) &#123;
             rotate(tr[u].f);
           rotate(u);
         &#125; else &#123;
             rotate(u);
             rotate(u);
         &#125;
     &#125;
<span class=hljs-deletion>-</span>
<span class=hljs-deletion>-    if (!t) root = u;</span>
 &#125;</code></pre></div><div class="border-bottom border-x bs__tab-content d-none p-2" data-title=代码><pre><code class="cpp hljs" data-lang=cpp data-size=0.52><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>splay</span><span class=hljs-params>(<span class=hljs-type>size_t</span> u)</span> </span>&#123;
    std::stack&lt;<span class=hljs-type>size_t</span>&gt; st;

    <span class=hljs-type>size_t</span> cur = u;
    st.<span class=hljs-built_in>push</span>(cur);
    <span class=hljs-keyword>while</span> (!<span class=hljs-built_in>isRoot</span>(cur)) &#123;
        st.<span class=hljs-built_in>push</span>(tr[cur].f);
        cur = tr[cur].f;
    &#125;

    <span class=hljs-keyword>while</span> (!st.<span class=hljs-built_in>empty</span>()) &#123;
        <span class=hljs-built_in>pushdown</span>(st.<span class=hljs-built_in>top</span>());
        st.<span class=hljs-built_in>pop</span>();
    &#125;

    <span class=hljs-keyword>while</span> (!<span class=hljs-built_in>isRoot</span>(u)) &#123;
        <span class=hljs-keyword>if</span> (<span class=hljs-built_in>isRoot</span>(tr[u].f)) &#123;
            <span class=hljs-built_in>rotate</span>(u);
        &#125; <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (<span class=hljs-built_in>relation</span>(u) == <span class=hljs-built_in>relation</span>(tr[u].f)) &#123;
            <span class=hljs-built_in>rotate</span>(tr[u].f);
            <span class=hljs-built_in>rotate</span>(u);
        &#125; <span class=hljs-keyword>else</span> &#123;
            <span class=hljs-built_in>rotate</span>(u);
            <span class=hljs-built_in>rotate</span>(u);
        &#125;
    &#125;
&#125;</code></pre></div></div></div> </section> <section> <h3 id=access-操作>Access 操作</h3> <p>该操作意为「访问」节点 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>u</mi></mrow><annotation encoding=application/x-tex>u</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mathnormal mord">u</span></span></span></span>，被访问过的节点会有一条实路径连接到根节点，且该节点在这条路径的头部（最下端）。</p> <pre><code class="cpp hljs" data-lang=cpp data-size=0.14><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>access</span><span class=hljs-params>(<span class=hljs-type>size_t</span> u)</span> </span>&#123;
    <span class=hljs-keyword>for</span> (<span class=hljs-type>size_t</span> f = <span class=hljs-number>0</span>; u; u = tr[f = u].f) &#123;
        <span class=hljs-built_in>splay</span>(u);
        tr[u].r = f;
        <span class=hljs-built_in>pushup</span>(u);
    &#125;
&#125;</code></pre> </section> <section> <h3 id=makeroot-操作>makeRoot 操作</h3> <p>使节点 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>u</mi></mrow><annotation encoding=application/x-tex>u</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mathnormal mord">u</span></span></span></span> 成为原树的根。</p> <pre><code class="cpp hljs" data-lang=cpp data-size=0.10><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>makeRoot</span><span class=hljs-params>(<span class=hljs-type>const</span> <span class=hljs-type>size_t</span> &amp;u)</span> </span>&#123;
    <span class=hljs-built_in>access</span>(u);
    <span class=hljs-built_in>splay</span>(u);
    tr[u].rev = !tr[u].rev;
&#125;</code></pre> </section> <section> <h3 id=split-操作>Split 操作</h3> <p>将 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>x</mi><mo>∼</mo><mi>y</mi></mrow><annotation encoding=application/x-tex>x \sim y</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mathnormal mord">x</span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>∼</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:0.625em;vertical-align:-0.1944em;></span><span class="mathnormal mord" style=margin-right:0.03588em;>y</span></span></span></span> 的路径单独抽成一棵 Splay。</p> <pre><code class="cpp hljs" data-lang=cpp data-size=0.10><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>split</span><span class=hljs-params>(<span class=hljs-type>const</span> <span class=hljs-type>size_t</span> &amp;x, <span class=hljs-type>const</span> <span class=hljs-type>size_t</span> &amp;y)</span> </span>&#123;
    <span class=hljs-built_in>makeRoot</span>(x);
    <span class=hljs-built_in>access</span>(y);
    <span class=hljs-built_in>splay</span>(y);
&#125;</code></pre> </section> <section> <h3 id=link-操作>Link 操作</h3> <p>在 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>x</mi></mrow><annotation encoding=application/x-tex>x</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mathnormal mord">x</span></span></span></span> 节点和 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>y</mi></mrow><annotation encoding=application/x-tex>y</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.625em;vertical-align:-0.1944em;></span><span class="mathnormal mord" style=margin-right:0.03588em;>y</span></span></span></span> 节点之间连一条边，使其成为同一棵树内的两个节点。</p> <pre><code class="cpp hljs" data-lang=cpp data-size=0.12><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>link</span><span class=hljs-params>(<span class=hljs-type>const</span> <span class=hljs-type>int</span> &amp;x, <span class=hljs-type>const</span> <span class=hljs-type>int</span> &amp;y)</span> </span>&#123;
    <span class=hljs-built_in>makeRoot</span>(x);

    <span class=hljs-keyword>if</span> (<span class=hljs-built_in>findRoot</span>(y) != x) &#123;
        tr[x].f = y;
    &#125;
&#125;</code></pre> </section> <section> <h3 id=cut-操作>Cut 操作</h3> <p>切断 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>x</mi></mrow><annotation encoding=application/x-tex>x</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.4306em;></span><span class="mathnormal mord">x</span></span></span></span> 和 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>y</mi></mrow><annotation encoding=application/x-tex>y</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:0.625em;vertical-align:-0.1944em;></span><span class="mathnormal mord" style=margin-right:0.03588em;>y</span></span></span></span> 之间的路径。</p> <pre><code class="cpp hljs" data-lang=cpp data-size=0.16><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>cut</span><span class=hljs-params>(<span class=hljs-type>int</span> x, <span class=hljs-type>int</span> y)</span> </span>&#123;
    <span class=hljs-built_in>split</span>(x, y);

    <span class=hljs-keyword>if</span> (tr[y].l == x) &#123;  <span class=hljs-comment>// 只有路径存在时才删除</span>
        tr[y].l = <span class=hljs-number>0</span>;
        tr[x].f = <span class=hljs-number>0</span>;
    &#125;
&#125;</code></pre> </section> <section> <h2 id=代码-32>代码</h2> <div class=bs__tabs><div class="mb-0 tabnav"><nav class="bs__tab-nav tabnav-tabs"><button aria-current=page class=tabnav-tab>Splay</button><button class=tabnav-tab>FHQ Treap</button></nav></div><div class=bs__tab-contents><div class="border-bottom border-x bs__tab-content d-block p-2" data-title=Splay><pre><code class="cpp hljs" data-lang=cpp data-size=3.82><span class=hljs-meta>#<span class=hljs-keyword>include</span> <span class=hljs-string>&lt;iostream&gt;</span></span>
<span class=hljs-meta>#<span class=hljs-keyword>include</span> <span class=hljs-string>&lt;stack&gt;</span></span>

<span class=hljs-keyword>using</span> std::cin;
<span class=hljs-keyword>using</span> std::cout;
<span class=hljs-type>const</span> <span class=hljs-type>char</span> endl = <span class=hljs-string>&#x27;\n&#x27;</span>;

<span class=hljs-type>const</span> <span class=hljs-type>int</span> N = <span class=hljs-number>1e5</span> + <span class=hljs-number>5</span>;

<span class=hljs-keyword>class</span> <span class="class_ hljs-title">LinkCutTree</span> &#123;
  <span class=hljs-keyword>private</span>:
    <span class=hljs-keyword>struct</span> <span class="class_ hljs-title">node</span> &#123;
        <span class=hljs-type>size_t</span> l, r, f;
        <span class=hljs-type>unsigned</span> v, s;
        <span class=hljs-type>bool</span> rev;

        <span class=hljs-built_in>node</span>()
            : <span class=hljs-built_in>l</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>r</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>f</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>s</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>v</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>rev</span>(<span class=hljs-literal>false</span>) &#123;&#125;

        <span class=hljs-built_in>node</span>(<span class=hljs-type>unsigned</span> _v, <span class=hljs-type>size_t</span> _f)
            : <span class=hljs-built_in>l</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>r</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>f</span>(_f), <span class=hljs-built_in>s</span>(_v), <span class=hljs-built_in>v</span>(_v), <span class=hljs-built_in>rev</span>(<span class=hljs-literal>false</span>) &#123;&#125;

        <span class=hljs-function><span class=hljs-type>size_t</span> &amp;<span class=hljs-title>child</span><span class=hljs-params>(<span class=hljs-type>unsigned</span> x)</span> </span>&#123;
            <span class=hljs-keyword>return</span> !x ? l : r;
        &#125;
    &#125; tr[N];

    <span class=hljs-function><span class=hljs-keyword>inline</span> <span class=hljs-type>void</span> <span class=hljs-title>pushup</span><span class=hljs-params>(<span class=hljs-type>size_t</span> u)</span> </span>&#123;
        tr[u].s = tr[tr[u].l].s ^ tr[u].v ^ tr[tr[u].r].s;
    &#125;

    <span class=hljs-function><span class=hljs-keyword>inline</span> <span class=hljs-type>void</span> <span class=hljs-title>pushdown</span><span class=hljs-params>(<span class=hljs-type>const</span> <span class=hljs-type>size_t</span> &amp;u)</span> </span>&#123;
        <span class=hljs-keyword>if</span> (!tr[u].rev) <span class=hljs-keyword>return</span>;

        std::<span class=hljs-built_in>swap</span>(tr[u].l, tr[u].r);
        tr[tr[u].l].rev = !tr[tr[u].l].rev;
        tr[tr[u].r].rev = !tr[tr[u].r].rev;
        tr[u].rev = <span class=hljs-literal>false</span>;
    &#125;

    <span class=hljs-function><span class=hljs-type>unsigned</span> <span class=hljs-title>relation</span><span class=hljs-params>(<span class=hljs-type>const</span> <span class=hljs-type>size_t</span> &amp;u)</span> </span>&#123;
        <span class=hljs-keyword>return</span> u == tr[tr[u].f].l ? <span class=hljs-number>0</span> : <span class=hljs-number>1</span>;
    &#125;

    <span class=hljs-function><span class=hljs-type>bool</span> <span class=hljs-title>isRoot</span><span class=hljs-params>(<span class=hljs-type>const</span> <span class=hljs-type>size_t</span> &amp;u)</span> </span>&#123;
        <span class=hljs-keyword>return</span> tr[tr[u].f].l != u &amp;&amp; tr[tr[u].f].r != u;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>rotate</span><span class=hljs-params>(<span class=hljs-type>size_t</span> u)</span> </span>&#123;
        <span class=hljs-type>size_t</span> p = tr[u].f;
        <span class=hljs-type>unsigned</span> x = <span class=hljs-built_in>relation</span>(u);

        <span class=hljs-keyword>if</span> (!<span class=hljs-built_in>isRoot</span>(p)) &#123;
            tr[tr[p].f].<span class=hljs-built_in>child</span>(<span class=hljs-built_in>relation</span>(p)) = u;
        &#125;
        tr[u].f = tr[p].f;

        <span class=hljs-keyword>if</span> (tr[u].<span class=hljs-built_in>child</span>(x ^ <span class=hljs-number>1</span>)) &#123;
            tr[tr[u].<span class=hljs-built_in>child</span>(x ^ <span class=hljs-number>1</span>)].f = p;
        &#125;
        tr[p].<span class=hljs-built_in>child</span>(x) = tr[u].<span class=hljs-built_in>child</span>(x ^ <span class=hljs-number>1</span>);

        tr[u].<span class=hljs-built_in>child</span>(x ^ <span class=hljs-number>1</span>) = p;
        tr[p].f = u;

        <span class=hljs-built_in>pushup</span>(p);
        <span class=hljs-built_in>pushup</span>(u);
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>splay</span><span class=hljs-params>(<span class=hljs-type>size_t</span> u)</span> </span>&#123;
        std::stack&lt;<span class=hljs-type>size_t</span>&gt; st;

        <span class=hljs-type>size_t</span> cur = u;
        st.<span class=hljs-built_in>push</span>(cur);
        <span class=hljs-keyword>while</span> (!<span class=hljs-built_in>isRoot</span>(cur)) &#123;
            st.<span class=hljs-built_in>push</span>(tr[cur].f);
            cur = tr[cur].f;
        &#125;

        <span class=hljs-keyword>while</span> (!st.<span class=hljs-built_in>empty</span>()) &#123;
            <span class=hljs-built_in>pushdown</span>(st.<span class=hljs-built_in>top</span>());
            st.<span class=hljs-built_in>pop</span>();
        &#125;

        <span class=hljs-keyword>while</span> (!<span class=hljs-built_in>isRoot</span>(u)) &#123;
            <span class=hljs-keyword>if</span> (<span class=hljs-built_in>isRoot</span>(tr[u].f)) &#123;
                <span class=hljs-built_in>rotate</span>(u);
            &#125; <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (<span class=hljs-built_in>relation</span>(u) == <span class=hljs-built_in>relation</span>(tr[u].f)) &#123;
                <span class=hljs-built_in>rotate</span>(tr[u].f);
                <span class=hljs-built_in>rotate</span>(u);
            &#125; <span class=hljs-keyword>else</span> &#123;
                <span class=hljs-built_in>rotate</span>(u);
                <span class=hljs-built_in>rotate</span>(u);
            &#125;
        &#125;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>access</span><span class=hljs-params>(<span class=hljs-type>size_t</span> u)</span> </span>&#123;
        <span class=hljs-keyword>for</span> (<span class=hljs-type>size_t</span> f = <span class=hljs-number>0</span>; u; u = tr[f = u].f) &#123;
            <span class=hljs-built_in>splay</span>(u);
            tr[u].r = f;
            <span class=hljs-built_in>pushup</span>(u);
        &#125;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>makeRoot</span><span class=hljs-params>(<span class=hljs-type>const</span> <span class=hljs-type>size_t</span> &amp;u)</span> </span>&#123;
        <span class=hljs-built_in>access</span>(u);
        <span class=hljs-built_in>splay</span>(u);
        tr[u].rev = !tr[u].rev;
    &#125;

    <span class=hljs-function><span class=hljs-type>size_t</span> <span class=hljs-title>findRoot</span><span class=hljs-params>(<span class=hljs-type>size_t</span> u)</span> </span>&#123;
        <span class=hljs-built_in>access</span>(u);
        <span class=hljs-built_in>splay</span>(u);

        <span class=hljs-keyword>while</span> (tr[u].l) &#123;
            u = tr[u].l;
        &#125;

        <span class=hljs-keyword>return</span> u;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>split</span><span class=hljs-params>(<span class=hljs-type>const</span> <span class=hljs-type>size_t</span> &amp;x, <span class=hljs-type>const</span> <span class=hljs-type>size_t</span> &amp;y)</span> </span>&#123;
        <span class=hljs-built_in>makeRoot</span>(x);
        <span class=hljs-built_in>access</span>(y);
        <span class=hljs-built_in>splay</span>(y);
    &#125;

  <span class=hljs-keyword>public</span>:
    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>set</span><span class=hljs-params>(<span class=hljs-type>int</span> p, <span class=hljs-type>int</span> v)</span> </span>&#123;
        tr[p].s = tr[p].v = v;
    &#125;

    <span class=hljs-function><span class=hljs-type>unsigned</span> <span class=hljs-title>query</span><span class=hljs-params>(<span class=hljs-type>int</span> x, <span class=hljs-type>int</span> y)</span> </span>&#123;
        <span class=hljs-built_in>split</span>(x, y);

        <span class=hljs-keyword>return</span> tr[y].s;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>link</span><span class=hljs-params>(<span class=hljs-type>const</span> <span class=hljs-type>int</span> &amp;x, <span class=hljs-type>const</span> <span class=hljs-type>int</span> &amp;y)</span> </span>&#123;
        <span class=hljs-built_in>makeRoot</span>(x);

        <span class=hljs-keyword>if</span> (<span class=hljs-built_in>findRoot</span>(y) != x) &#123;
            tr[x].f = y;
        &#125;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>cut</span><span class=hljs-params>(<span class=hljs-type>int</span> x, <span class=hljs-type>int</span> y)</span> </span>&#123;
        <span class=hljs-built_in>split</span>(x, y);

        <span class=hljs-keyword>if</span> (tr[y].l == x) &#123;
            tr[y].l = <span class=hljs-number>0</span>;
            tr[x].f = <span class=hljs-number>0</span>;
        &#125;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>change</span><span class=hljs-params>(<span class=hljs-type>int</span> p, <span class=hljs-type>int</span> v)</span> </span>&#123;
        <span class=hljs-built_in>access</span>(p);
        <span class=hljs-built_in>splay</span>(p);
        tr[p].v = v;
        <span class=hljs-built_in>pushup</span>(p);
    &#125;
&#125; lct;

<span class=hljs-type>int</span> n, m;

<span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>main</span><span class=hljs-params>()</span> </span>&#123;
    std::ios::<span class=hljs-built_in>sync_with_stdio</span>(<span class=hljs-literal>false</span>);
    cin.<span class=hljs-built_in>tie</span>(<span class=hljs-literal>nullptr</span>);

    cin &gt;&gt; n &gt;&gt; m;

    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>, x; i &lt;= n; i++) &#123;
        cin &gt;&gt; x;

        lct.<span class=hljs-built_in>set</span>(i, x);
    &#125;

    <span class=hljs-keyword>while</span> (m--) &#123;
        <span class=hljs-type>int</span> op, x, y;

        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;

        <span class=hljs-keyword>switch</span> (op) &#123;
            <span class=hljs-keyword>case</span> <span class=hljs-number>0</span>: &#123;
                cout &lt;&lt; lct.<span class=hljs-built_in>query</span>(x, y) &lt;&lt; endl;

                <span class=hljs-keyword>break</span>;
            &#125;
            <span class=hljs-keyword>case</span> <span class=hljs-number>1</span>: &#123;
                lct.<span class=hljs-built_in>link</span>(x, y);

                <span class=hljs-keyword>break</span>;
            &#125;
            <span class=hljs-keyword>case</span> <span class=hljs-number>2</span>: &#123;
                lct.<span class=hljs-built_in>cut</span>(x, y);

                <span class=hljs-keyword>break</span>;
            &#125;
            <span class=hljs-keyword>case</span> <span class=hljs-number>3</span>: &#123;
                lct.<span class=hljs-built_in>change</span>(x, y);

                <span class=hljs-keyword>break</span>;
            &#125;
        &#125;
    &#125;

    <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>;
&#125;</code></pre></div><div class="border-bottom border-x bs__tab-content d-none p-2" data-title="FHQ Treap"><pre><code class="cpp hljs" data-lang=cpp data-size=4.31><span class=hljs-meta>#<span class=hljs-keyword>include</span> <span class=hljs-string>&lt;iostream&gt;</span></span>
<span class=hljs-meta>#<span class=hljs-keyword>include</span> <span class=hljs-string>&lt;algorithm&gt;</span></span>
<span class=hljs-meta>#<span class=hljs-keyword>include</span> <span class=hljs-string>&lt;cstdlib&gt;</span></span>
<span class=hljs-meta>#<span class=hljs-keyword>include</span> <span class=hljs-string>&lt;stack&gt;</span></span>

<span class=hljs-keyword>using</span> std::cin;
<span class=hljs-keyword>using</span> std::cout;
<span class=hljs-type>const</span> <span class=hljs-type>char</span> endl = <span class=hljs-string>&#x27;\n&#x27;</span>;

<span class=hljs-type>const</span> <span class=hljs-type>int</span> N = <span class=hljs-number>1e5</span> + <span class=hljs-number>5</span>;

<span class=hljs-comment>// Link-Cut Tree</span>
<span class=hljs-keyword>class</span> <span class="class_ hljs-title">LinkCutTree</span> &#123;
  <span class=hljs-keyword>private</span>:
    std::stack&lt;<span class=hljs-type>bool</span>&gt; st;

    <span class=hljs-keyword>struct</span> <span class="class_ hljs-title">node</span> &#123;
        <span class=hljs-type>int</span> p,  <span class=hljs-comment>// 父亲节点</span>
            l,  <span class=hljs-comment>// 左儿子</span>
            r;  <span class=hljs-comment>// 右儿子</span>
        <span class=hljs-type>int</span> pre;
        <span class=hljs-type>int</span> val,   <span class=hljs-comment>// 节点值</span>
            sum;   <span class=hljs-comment>// 异或和</span>
        <span class=hljs-type>int</span> key;   <span class=hljs-comment>// 权值</span>
        <span class=hljs-type>bool</span> rev;  <span class=hljs-comment>// 翻转标记</span>

        <span class=hljs-built_in>node</span>()
            : <span class=hljs-built_in>p</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>l</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>r</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>pre</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>val</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>sum</span>(<span class=hljs-number>0</span>), <span class=hljs-built_in>key</span>(<span class=hljs-built_in>rand</span>()), <span class=hljs-built_in>rev</span>(<span class=hljs-literal>false</span>) &#123;&#125;
    &#125; tr[N];

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>pushup</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span> </span>&#123;
        <span class=hljs-comment>// 计算异或和</span>
        tr[u].sum = tr[tr[u].l].sum ^ tr[u].val ^ tr[tr[u].r].sum;

        <span class=hljs-comment>// 标记父亲节点</span>
        <span class=hljs-keyword>if</span> (tr[u].l) tr[tr[u].l].p = u;
        <span class=hljs-keyword>if</span> (tr[u].r) tr[tr[u].r].p = u;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>pushdown</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span> </span>&#123;
        <span class=hljs-keyword>if</span> (!tr[u].rev) <span class=hljs-keyword>return</span>;

        tr[u].rev = <span class=hljs-literal>false</span>;
        std::<span class=hljs-built_in>swap</span>(tr[u].l, tr[u].r);
        tr[tr[u].l].rev ^= <span class=hljs-number>1</span>;
        tr[tr[u].r].rev ^= <span class=hljs-number>1</span>;
    &#125;

    <span class=hljs-function>std::pair&lt;<span class=hljs-type>int</span>, <span class=hljs-type>int</span>&gt; <span class=hljs-title>split</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span> </span>&#123;
        <span class=hljs-keyword>if</span> (st.<span class=hljs-built_in>empty</span>()) &#123;
            <span class=hljs-built_in>pushdown</span>(u);
            <span class=hljs-keyword>auto</span> t = std::<span class=hljs-built_in>make_pair</span>(u, tr[u].r);
            tr[u].r = <span class=hljs-number>0</span>;
            <span class=hljs-built_in>pushup</span>(u);

            <span class=hljs-keyword>return</span> t;
        &#125;

        <span class=hljs-type>bool</span> d = st.<span class=hljs-built_in>top</span>() ^ tr[u].rev;
        st.<span class=hljs-built_in>pop</span>();

        <span class=hljs-built_in>pushdown</span>(u);

        <span class=hljs-keyword>if</span> (d) &#123;
            <span class=hljs-keyword>auto</span> t = <span class=hljs-built_in>split</span>(tr[u].l);
            tr[u].l = t.second;
            <span class=hljs-built_in>pushup</span>(u);

            <span class=hljs-keyword>return</span> std::<span class=hljs-built_in>make_pair</span>(t.first, u);
        &#125;

        <span class=hljs-keyword>auto</span> t = <span class=hljs-built_in>split</span>(tr[u].r);
        tr[u].r = t.first;
        <span class=hljs-built_in>pushup</span>(u);

        <span class=hljs-keyword>return</span> std::<span class=hljs-built_in>make_pair</span>(u, t.second);
    &#125;

    <span class=hljs-comment>// 合并</span>
    <span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>merge</span><span class=hljs-params>(<span class=hljs-type>int</span> x, <span class=hljs-type>int</span> y)</span> </span>&#123;
        <span class=hljs-keyword>if</span> (!x || !y) <span class=hljs-keyword>return</span> x | y;

        <span class=hljs-keyword>if</span> (tr[x].key &lt; tr[y].key) &#123;
            <span class=hljs-built_in>pushdown</span>(x);
            tr[x].r = <span class=hljs-built_in>merge</span>(tr[x].r, y);
            <span class=hljs-built_in>pushup</span>(x);
            <span class=hljs-keyword>return</span> x;
        &#125;

        <span class=hljs-built_in>pushdown</span>(y);
        tr[y].l = <span class=hljs-built_in>merge</span>(x, tr[y].l);
        <span class=hljs-built_in>pushup</span>(y);
        <span class=hljs-keyword>return</span> y;
    &#125;

    <span class=hljs-comment>// 是否是根节点</span>
    <span class=hljs-function><span class=hljs-type>bool</span> <span class=hljs-title>isRoot</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span> </span>&#123;
        <span class=hljs-keyword>return</span> !tr[u].p || (tr[tr[u].p].l != u &amp;&amp; tr[tr[u].p].r != u);
    &#125;

    <span class=hljs-comment>// 查找根节点</span>
    <span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>findRoot</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span> </span>&#123;
        <span class=hljs-keyword>while</span> (!st.<span class=hljs-built_in>empty</span>()) st.<span class=hljs-built_in>pop</span>();
        <span class=hljs-keyword>while</span> (!<span class=hljs-built_in>isRoot</span>(u)) &#123;
            <span class=hljs-comment>// pushdown(u);</span>
            st.<span class=hljs-built_in>push</span>(tr[tr[u].p].l == u);
            u = tr[u].p;
        &#125;
        <span class=hljs-keyword>return</span> u;
    &#125;

    <span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>findLeft</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span> </span>&#123;
        u = <span class=hljs-built_in>findRoot</span>(u);
        <span class=hljs-built_in>pushdown</span>(u);
        <span class=hljs-keyword>while</span> (tr[u].l) &#123;
            u = tr[u].l;
            <span class=hljs-built_in>pushdown</span>(u);
        &#125;
        <span class=hljs-keyword>return</span> u;
    &#125;

    <span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>access</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span> </span>&#123;
        <span class=hljs-type>int</span> lst = <span class=hljs-number>0</span>;

        <span class=hljs-keyword>while</span> (u) &#123;
            <span class=hljs-keyword>auto</span> t = <span class=hljs-built_in>split</span>(<span class=hljs-built_in>findRoot</span>(u));
            tr[<span class=hljs-built_in>findLeft</span>(lst)].pre = <span class=hljs-number>0</span>;
            lst = <span class=hljs-built_in>merge</span>(t.first, lst);
            tr[<span class=hljs-built_in>findLeft</span>(t.second)].pre = u;
            u = tr[<span class=hljs-built_in>findLeft</span>(lst)].pre;
        &#125;

        <span class=hljs-keyword>return</span> lst;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>makeRoot</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span> </span>&#123;
        tr[<span class=hljs-built_in>access</span>(u)].rev ^= <span class=hljs-number>1</span>;
    &#125;

  <span class=hljs-keyword>public</span>:
    <span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>getRoot</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span> </span>&#123;
        <span class=hljs-keyword>return</span> <span class=hljs-built_in>findLeft</span>(<span class=hljs-built_in>access</span>(u));
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>link</span><span class=hljs-params>(<span class=hljs-type>int</span> x, <span class=hljs-type>int</span> y)</span> </span>&#123;
        <span class=hljs-built_in>makeRoot</span>(x);
        tr[x].pre = y;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>cut</span><span class=hljs-params>(<span class=hljs-type>int</span> x, <span class=hljs-type>int</span> y)</span> </span>&#123;
        <span class=hljs-built_in>makeRoot</span>(x);
        <span class=hljs-built_in>access</span>(y);
        <span class=hljs-built_in>access</span>(x);
        tr[y].pre = <span class=hljs-number>0</span>;
    &#125;

    <span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>query</span><span class=hljs-params>(<span class=hljs-type>int</span> x, <span class=hljs-type>int</span> y)</span> </span>&#123;
        <span class=hljs-built_in>makeRoot</span>(x);
        <span class=hljs-built_in>access</span>(y);

        <span class=hljs-keyword>auto</span> t = <span class=hljs-built_in>split</span>(<span class=hljs-built_in>findRoot</span>(y));
        <span class=hljs-type>int</span> res = tr[t.first].sum;
        <span class=hljs-built_in>merge</span>(t.first, t.second);

        <span class=hljs-keyword>return</span> res;
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>change</span><span class=hljs-params>(<span class=hljs-type>int</span> u, <span class=hljs-type>int</span> val)</span> </span>&#123;
        <span class=hljs-built_in>makeRoot</span>(u);
        <span class=hljs-keyword>auto</span> t = <span class=hljs-built_in>split</span>(<span class=hljs-built_in>findRoot</span>(u));
        tr[u].val = val;
        <span class=hljs-built_in>merge</span>(t.first, t.second);
    &#125;

    <span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>set</span><span class=hljs-params>(<span class=hljs-type>int</span> u, <span class=hljs-type>int</span> val)</span> </span>&#123;
        tr[u].sum = tr[u].val = val;
    &#125;
&#125; lct;

<span class=hljs-type>int</span> n, m;

<span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>main</span><span class=hljs-params>()</span> </span>&#123;
    std::ios::<span class=hljs-built_in>sync_with_stdio</span>(<span class=hljs-literal>false</span>);
    cin.<span class=hljs-built_in>tie</span>(<span class=hljs-literal>nullptr</span>);

    cin &gt;&gt; n &gt;&gt; m;

    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>, x; i &lt;= n; i++) &#123;
        cin &gt;&gt; x;

        lct.<span class=hljs-built_in>set</span>(i, x);
    &#125;

    <span class=hljs-keyword>while</span> (m--) &#123;
        <span class=hljs-type>int</span> op, x, y;

        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;

        <span class=hljs-keyword>switch</span> (op) &#123;
            <span class=hljs-keyword>case</span> <span class=hljs-number>0</span>: &#123;
                cout &lt;&lt; lct.<span class=hljs-built_in>query</span>(x, y) &lt;&lt; endl;

                <span class=hljs-keyword>break</span>;
            &#125;
            <span class=hljs-keyword>case</span> <span class=hljs-number>1</span>: &#123;
                <span class=hljs-keyword>if</span> (lct.<span class=hljs-built_in>getRoot</span>(x) != lct.<span class=hljs-built_in>getRoot</span>(y)) &#123;
                    lct.<span class=hljs-built_in>link</span>(x, y);
                &#125;

                <span class=hljs-keyword>break</span>;
            &#125;
            <span class=hljs-keyword>case</span> <span class=hljs-number>2</span>: &#123;
                lct.<span class=hljs-built_in>cut</span>(x, y);

                <span class=hljs-keyword>break</span>;
            &#125;
            <span class=hljs-keyword>case</span> <span class=hljs-number>3</span>: &#123;
                lct.<span class=hljs-built_in>change</span>(x, y);

                <span class=hljs-keyword>break</span>;
            &#125;
        &#125;
    &#125;

    <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>;
&#125;</code></pre></div></div></div> </section> <section> <h2 id=参考资料-10>参考资料</h2> <ol> <li>平衡树 &amp; LCT，石家庄市第二中学信息学奥赛集训（线下授课），张闰清，2022 年 7 月 12 日。</li> </ol> </section> </section></article><aside class="bs__Layout-sidebar bs__Layout-sidebar-2 Layout-sidebar"><div class="bs__sponsor-card color-bg-sponsors color-border-sponsors d-flex f5 flash flex-items-center flex-justify-between my-2"><div>喜欢这篇文章？为什么不考虑打赏一下作者呢？</div><a class="btn btn-sm color-bg-done-emphasis color-border-done color-fg-on-emphasis flex-shrink-0 ml-2" href=https://afdian.net/@baoshuo rel="external nofollow noopener" target=_blank>爱发电</a></div><div class="bs__copyright-card color-bg-subtle color-border-subtle flash my-2 py-3"><div class=h4>Link-Cut Tree 学习笔记</div><div class="f5 mb-2 mt-1"><a class="Link Link--secondary" href=/link-cut-tree/>https://oi.baoshuo.ren/link-cut-tree/</a></div><div class="d-flex flex-wrap mb-1"><div class="flex-shrink-0 mb-2 mr-3"><div class=f6>本文作者</div><div><a class="Link Link--primary" href="https://baoshuo.ren/?utm_source=oi.baoshuo.ren&amp;utm_medium=author" target=_blank>宝硕</a></div></div><div class="flex-shrink-0 mb-2 mr-3"><div class=f6>发布于</div><div>2022-07-15</div></div><div class="flex-shrink-0 mb-2 mr-3"><div class=f6>版权协议</div><div><a class="Link Link--primary" href=https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode.zh-Hans rel=license target=_blank>CC BY-NC-SA 4.0</a></div></div></div><div class=text-small>转载或引用本文时请遵守许可协议，注明出处、不得用于商业用途！</div></div></aside><div class="bs__Layout-main bs__Layout-main-2 Layout-main"><nav class="my-2 pagination-container"><div class="bs__post-pagination d-flex flex-items-stretch pagination width-full"><a class="d-flex flex-1 flex-items-center mr-1 previous_page py-2 text-left ws-normal" href=/hnoi2010-bounce/>「HNOI2010」弹飞绵羊</a><a class="d-flex flex-1 flex-items-center flex-justify-end ml-1 next_page py-2 text-right ws-normal" href=/splay/>Splay 学习笔记</a></div></nav></div><aside class="bs__Layout-sidebar bs__Layout-sidebar-3 Layout-sidebar"><div aria-labeled-by=categories-heading class="mb-2 menu"><h2 class="color-bg-inset menu-heading" id=categories-heading><svg aria-hidden=false aria-label="Categories Icon" class=mr-2 fill=currentColor height=18 role=img style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;" viewbox="0 0 16 16" width=18><path d="M7.122.392a1.75 1.75 0 011.756 0l5.003 2.902c.83.481.83 1.68 0 2.162L8.878 8.358a1.75 1.75 0 01-1.756 0L2.119 5.456a1.25 1.25 0 010-2.162L7.122.392zM8.125 1.69a.25.25 0 00-.25 0l-4.63 2.685 4.63 2.685a.25.25 0 00.25 0l4.63-2.685-4.63-2.685zM1.601 7.789a.75.75 0 011.025-.273l5.249 3.044a.25.25 0 00.25 0l5.249-3.044a.75.75 0 01.752 1.298l-5.248 3.044a1.75 1.75 0 01-1.756 0L1.874 8.814A.75.75 0 011.6 7.789zm0 3.5a.75.75 0 011.025-.273l5.249 3.044a.25.25 0 00.25 0l5.249-3.044a.75.75 0 01.752 1.298l-5.248 3.044a1.75 1.75 0 01-1.756 0l-5.248-3.044a.75.75 0 01-.273-1.025z" fill-rule=evenodd></path></svg>分类</h2><a class="d-flex flex-items-center flex-justify-between menu-item" href=/categories/%E8%AE%A1%E5%88%92/>计划 <span class="Counter ml-1">4</span></a> <a class="d-flex flex-items-center flex-justify-between menu-item" href=/categories/%E9%A2%98%E8%A7%A3/>题解 <span class="Counter ml-1">71</span></a> <a class="d-flex flex-items-center flex-justify-between menu-item" href=/categories/%E7%AC%94%E8%AE%B0/>笔记 <span class="Counter ml-1">20</span></a> <a class="d-flex flex-items-center flex-justify-between menu-item" href=/categories/%E6%9D%82%E9%A1%B9/>杂项 <span class="Counter ml-1">2</span></a> </div><div aria-labeled-by=tags-heading class="border mb-2 overflow-hidden rounded-2"><div class="color-bg-inset mb-0 pt-2 px-3 Subhead"><h2 class="h5 Subhead-heading" id=tags-heading><svg aria-hidden=false aria-label="Tags Icon" class=mr-2 fill=currentColor height=18 role=img style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;" viewbox="0 0 16 16" width=18><path d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z" fill-rule=evenodd></path></svg>热门标签</h2></div><div class="px-3 py-2 width-full"><a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/%E6%B4%9B%E8%B0%B7/># 洛谷</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/%E6%95%B0%E5%AD%A6/># 数学</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/S2OJ/># S2OJ</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/># 数据结构</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/LibreOJ/># LibreOJ</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/%E6%A8%A1%E6%8B%9F/># 模拟</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/># 动态规划</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/%E5%9B%BE%E8%AE%BA/># 图论</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/NOIP/># NOIP</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/AcWing/># AcWing</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/># 线段树</a> <a class="d-inline-block Link--secondary mr-2 no-underline" href=/tags/%E8%B4%AA%E5%BF%83/># 贪心</a> </div></div><div aria-labeled-by=stats-heading class="border mb-2 overflow-hidden rounded-2"><div class="color-bg-inset mb-0 pt-2 px-3 Subhead"><h2 class="h5 Subhead-heading" id=stats-heading><svg aria-hidden=false aria-label="Analytics Icon" class=mr-2 fill=currentColor height=18 role=img style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;" viewbox="0 0 16 16" width=18><path d="M5.5 3.5a2 2 0 100 4 2 2 0 000-4zM2 5.5a3.5 3.5 0 115.898 2.549 5.507 5.507 0 013.034 4.084.75.75 0 11-1.482.235 4.001 4.001 0 00-7.9 0 .75.75 0 01-1.482-.236A5.507 5.507 0 013.102 8.05 3.49 3.49 0 012 5.5zM11 4a.75.75 0 100 1.5 1.5 1.5 0 01.666 2.844.75.75 0 00-.416.672v.352a.75.75 0 00.574.73c1.2.289 2.162 1.2 2.522 2.372a.75.75 0 101.434-.44 5.01 5.01 0 00-2.56-3.012A3 3 0 0011 4z" fill-rule=evenodd></path></svg>统计信息</h2></div><div class="px-3 py-2 width-full" id=sidebar-stats><svg class="anim-rotate d-block mx-auto" fill=none height=32px viewbox="0 0 16 16" width=32px><circle cx=8 cy=8 r=7 stroke=currentColor stroke-opacity=0.25 stroke-width=2 vector-effect=non-scaling-stroke></circle><path d="M15 8a7.002 7.002 0 00-7-7" stroke=currentColor stroke-linecap=round stroke-width=2 vector-effect=non-scaling-stroke></path></svg><div class="mt-1 text-center">加载中<span class=AnimatedEllipsis></span></div></div><script src="//static.cdn.baoshuo.ren/oi-blog/scripts/sidebar.fb40361.js?v=99786fb"></script></div></aside></div></div><script src="//static.cdn.baoshuo.ren/oi-blog/scripts/tabs.0df21cc.js?v=99786fb"></script><script src="//static.cdn.baoshuo.ren/oi-blog/scripts/toc.5a6b3a4.js?v=99786fb"></script><script defer src=//cdnjs.baoshuo.ren/ajax/libs/KaTeX/0.16.0/contrib/copy-tex.min.js></script></main></div><footer class="AppFrame-footer color-bg-subtle color-fg-muted user-select-none"><div class="container-lg d-md-flex f5 flex-md-items-center flex-md-justify-between px-3 py-4"><div>Copyright © 2019 - 2022 <a class=Link--muted href=/>Baoshuo's OI Blog</a></div><div>Powered by <a class=Link--muted href=https://hexo.io rel="external nofollow noopener" target=_blank>Hexo</a><span class=dot></span>Designed by <a class=Link--muted href="https://baoshuo.ren/?utm_source=oi.baoshuo.ren&amp;utm_medium=footer" rel="external nofollow noopener" target=_blank>Baoshuo</a></div></div></footer></div><script async src=//cdnjs.baoshuo.ren/ajax/libs/instant.page/5.1.0/instantpage.min.js></script></body></html>