[{"title":"C++ 输入输出的速度优化与实际测试","date":"2022-05-31T20:48:15.000Z","url":"/cpp-io-speed-optimization/","tags":["C++","STL","速度优化"],"categories":["杂项"],"content":"TL;DR 使用下面的这段代码可以为标准 C++ 流的输入输出提速。 使用时有几个注意事项： 关闭了流同步后，切莫将 C++ 风格的输入输出与 C 风格的输入输出（如 scanf 和 printf）混用，否则会造成意料之外的错误。 如果需要清空缓冲区，请使用 std::flush 或者 std::endl。 cout.tie(nullptr) 在一般情况下是非必要的，因为其在初始化时并没有绑定其他流。 原理 关闭与标准 C 流之间的同步 根据 C++ Reference 上的描述： std::ios_base::sync_with_stdio 设置标准 C++ 流是否与标准 C 流在每次输入/输出操作后同步。 标准 C++ 流为下列者：std::cin、std::cout、std::cerr、std::clog、std::wcin、std::wcout、std::wcerr 和 std::wclog。 标准 C 流为下列者：stdin、stdout 和 stderr。 对于与 C 流 f 同步的标准流 str，下列函数对拥有等同的效果： std::fputc(f, c) 和 str.rdbuf()-&gt;sputc(c) std::fgetc(f) 和 str.rdbuf()-&gt;sbumpc() std::ungetc(c, f) 和 str.rdbuf()-&gt;sputbackc(c) 实践中，这表示同步的 C++ 流为无缓冲，而每次 C++ 流上的 I/O 都立即应用到对应 C 流的缓冲区。这使得能自由地混合 C++ 与 C I/O。 另外，同步的 C++ 流保证为线程安全（从多个线程输出的单独字符可能交错，但无数据竞争）。 若关闭同步，则允许 C++ 标准流独立地缓冲其 I/O ，可认为这在某些情况下更快。 所有八个标准 C++ 流默认与其相应的 C 流同步。 若在标准流上已出现 I/O 后调用此函数，则行为是实现定义的：有的实现无效果，有的实现销毁读取缓冲区。 可以得知以下信息： C++ 为了保证兼容性，默认将标准 C++ 流的数据与标准 C 流同步，并将缓冲数据放置到标准 C 流的缓冲区中，但这样会减慢速度。 当关闭同步时会导致程序的不同线程之间的 I/O 冲突，不过 OI 中并不涉及。 在程序运行到产生首次输入输出后关闭同步的行为是由实现定义的。 那么可以通过关闭流同步的方式来解决第一点问题： 将这行代码放到主函数的起始位置即可。 由第三点信息可知，不能在运行时反复开启/关闭流同步，防止出现错误。 使用 \\n 代替 std::endl 根据 C++ Reference 上的描述： std::endl 插入换行符到输出序列 os 并冲入它，如同调用 os.put(os.widen('\\n')) 后随 os.flush()。 这是仅输出的 I/O 操纵符，可对任何 std::basic_ostream 类型的 out 以表达式 out &lt;&lt; std::endl 调用它。 可以得知，在调用 std::endl 时不仅输出了换行符，而且还清空了缓冲区。众所周知，频繁清空缓冲区会导致程序运行速度的下降，所以应该尽量避免使用 std::endl 作为换行符。 那么可以通过使用 \\n 来替代 std::endl 的做法来提升速度： 不推荐使用 endl 的原因是，如果遇到特殊情况需要使用 std::endl 时，define 会将 std::endl 中的 endl 替换为 \\n 导致编译错误。 取消 cin 与 cout 之间的联系 根据 C++ Reference 上的描述： std::basic_ios::tie 管理联系流。联系流是输出流，它与流缓冲（rdbuf()）所控制的输出序列同步，即在任何 *this 上的输入/输出操作前，在联系流上调用 flush()。 返回当前联系流。若无联系流，则返回空指针。 设置当前联系流为 str 。返回操作前的联系流。若无联系流，则返回空指针。 可以得知，如果一个流设置了联系流，在它进行输入/输出操作前会清除其联系流的缓冲区。众所周知，频繁清空缓冲区会导致程序运行速度的下降，所以如非必要，在竞赛中可以取消 std::cin 和 std::cout 间的联系以获得更快的输入输出速度： 无需使用 cout.tie(nullptr) 查看 ISO C++ 14 标准（ISO/IEC 14882:2014(E)，原文见文末附件）： 此处（第 999 页）并没有对 std::cout 的 tie() 赋初值。 在第 1012 页中，指明了 tie() 的初值为 0，即未绑定任何流。 所以，std::cout 在初始时并未与任何流产生绑定，所以无需取消 std::cout 与其他流的绑定。cout.tie(nullptr) 是多余的，可以删去。 测试 输入数据为 LibreOJ 7. Input Test 的测试点 5，大小为 59.7 MB。测试选择在 LibreOJ 评测量较为平稳时进行。不用洛谷测试的原因是怕被管理封号，我自己的 LibreOJ 账号有管理权限不怕被封。 结果 用时 O2 优化 cin.tie(nullptr) cout.tie(nullptr) 与标准 C 流同步 换行符 1820 ms 是 是 是 是 std::endl 1041 ms \\n 1107 ms 否 std::endl 335 ms \\n 1803 ms 否 是 std::endl 1053 ms \\n 1100 ms 否 std::endl 335 ms \\n 1877 ms 否 是 是 std::endl 1801 ms \\n 1117 ms 否 std::endl 1160 ms \\n 1810 ms 否 是 std::endl 1826 ms \\n 1093 ms 否 std::endl 1159 ms \\n 1810 ms 否 是 是 是 std::endl 1020 ms \\n 1095 ms 否 std::endl 347 ms \\n 1808 ms 否 是 std::endl 1045 ms \\n 1105 ms 否 std::endl 355 ms \\n 1837 ms 否 是 是 std::endl 1832 ms \\n 1095 ms 否 std::endl 1133 ms \\n 1872 ms 否 是 std::endl 1845 ms \\n 1098 ms 否 std::endl 1130 ms \\n 代码 实际测试 7. Input Test #1472987，O2 优化 + 读输优化，559 ms。 #1473174，O2 优化，2207 ms。 10145. 「一本通 4.6 练习 2」郁闷的出纳员 #1472998，O2 优化 + 读输优化，253 ms。 #1473175，O2 优化，399 ms。 结语 感谢你完整阅读了本文。 通过本文，相信读者对 C++ 的输入/输出流又有了更深的认识。按照本文所叙述的方法去操作，你就可以获得一个媲美 scanf 和 printf 的速度的 C++ 风格的输入了。 如果本文中有笔者遗漏、编写错误的地方，欢迎指正。 附件：27. IO library - ISO/IEC 14882:2014(E)（文件存档备份）。 参考资料 std::basic_ios&lt;CharT,Traits&gt;::tie，C++ Reference，2021 年 1 月 1 日。 std::ios_base::sync_with_stdio，2017 年 11 月 23 日。 std::flush，2017 年 11 月 18 日。 27.4 Standard iostream objects，ISO/IEC 14882:2014(E)。 感谢 LibreOJ 提供的高效、稳定的测评服务。 "},{"title":"洛谷 - P2421 [NOI2002] 荒岛野人","date":"2022-05-29T21:13:10.000Z","url":"/luogu-p2421/","tags":["数学","扩展欧几里得算法","洛谷"],"categories":["题解"],"content":"题目信息卡题目名称荒岛野人提交地址洛谷 P2421LibreOJ 10215题目难度提高+/省选-题目来源NOI2002 题面 题目描述 克里特岛以野人群居而著称。岛上有排列成环行的 m 个山洞。这些山洞顺时针编号为 1,2,…,m。岛上住着 n 个野人，一开始依次住在山洞 C1​,C2​,…,Cn​中，以后每年，第 i 个野人会沿顺时针向前走 Pi​ 个洞住下来。 每个野人 i 有一个寿命值 Li​，即生存的年数。 下面四幅图描述了一个有 6 个山洞，住有三个野人的岛上前四年的情况。三个野人初始的洞穴编号依次为 1,2,3；每年要走过的洞穴数依次为 3,7,2；寿命值依次为 4,3,1。 奇怪的是，虽然野人有很多，但没有任何两个野人在有生之年处在同一个山洞中，使得小岛一直保持和平与宁静，这让科学家们很是惊奇。他们想知道，至少有多少个山洞，才能维持岛上的和平呢？ 输入格式 第 1 行为一个整数 n，即野人的数目。 第 2 行到第 n+1 每行为三个整数 Ci​,Pi​,Li​，表示每个野人所住的初始洞穴编号，每年走过的洞穴数及寿命值。 输出格式 仅包含一个数 m，即最少可能的山洞数。输入数据保证有解，且 m 不大于 106。 输入输出样例 样例输入 #1 样例输出 #1 数据范围与约定 对于 100% 的数据，1≤n≤15，1≤Ci​,Pi​≤100，0≤Li​≤106，最终答案 m≤106。 思路 当 i=j 且 i,j∈[1,n] 时，第 i 个野人和第 j 个野人在同一个山洞中当且仅当情况如下： Ci​+xPi​≡Cj​+xPj​(modm)(1) 那么只需要使其在 [0,min(Li​,Lj​)] 范围内无解即可维持岛上的和平。 移项，有： x(Pi​−Pj​)≡Cj​−Ci​(modm)(2) 那么可以使用扩展欧几里得算法求出 (2) 式的解： (Pi​−Pj​)x+my=Cj​−Ci​(3) 再观察数据范围，发现答案 m≤106，那么可以考虑在 [max1≤i≤n​Ci​,106] 区间内枚举答案，复杂度为 O(mn2logCi​)，可以通过本题。 题外话：今天下午打模拟赛的时候这道题的 (3) 式推错了没切掉，真是可惜啊。 注：本题答案不具有单调性，不能二分。 代码 感谢 JohnSonloy 指出本文中的错误，已修正。 "},{"title":"洛谷 - P3586 [POI2015] LOG","date":"2022-05-26T15:53:15.000Z","url":"/luogu-p3586/","tags":["数据结构","洛谷","树状数组"],"categories":["题解"],"content":"题目信息卡题目名称LOG提交地址洛谷 P3586题目难度省选/NOI-题目来源POI2015 题面 题目描述 维护一个长度为 n 的序列，一开始都是 0，支持以下两种操作： U k a 将序列中第 k 个数修改为 a。 Z c s 在这个序列上，每次选出 c 个正数，并将它们都减去 1，询问能否进行 s 次操作。 每次询问独立，即每次询问不会对序列进行修改。 输入格式 第一行包含两个正整数 n,m，分别表示序列长度和操作次数。 接下来 m 行为 m 个操作。 输出格式 包含若干行，对于每个 Z 询问，若可行，输出 TAK，否则输出 NIE。 输入输出样例 样例输入 #1 样例输出 #1 数据范围与约定 对于 100% 的数据，1≤n,m≤106，1≤k,c≤n，0≤a≤109，1≤s≤109。 原题名称为 Logistyka。 思路 本题的答案实际上和序列无关，因此可以将序列看作一个集合来处理。设 ≥s 的数有 x 个，&lt;s 的数和为 sum，有结论如下： 如果无法满足 sum≥(c−x)×s 则操作一定不能成功，满足后要证明每次取有至少 c 个数。那么考虑小于 s 的数最少的时候有 ⌈s−1sum​⌉ 个，如果满足 sum≥(c−x)×s，则 ⌈s−1sum​⌉&gt;c−x，此时一定有解。 代码 "},{"title":"CDQ 分治学习笔记","date":"2022-05-25T21:25:49.000Z","url":"/cdq-divide/","tags":["数据结构","杂项","离线","CDQ 分治"],"categories":["笔记"],"content":"CDQ 分治是 OI 中的一个比较常用的分治算法。该算法最早由 IOI2008 金牌得主陈丹琦提出，并因此得名。 本文主要讲解使用 CDQ 分治解决点对三维偏序问题。 点对三维偏序问题的基本模型如下： 有 n 个元素，第 i 个元素有 ai​,bi​,ci​ 三个属性，设 f(i) 表示满足 aj​≤ai​ 且 bj​≤bi​ 且 cj​≤ci​ 且 j=i 的 j 的数量。给定一个或多个 x，求 f(x) 的值。 实现 CDQ 分治解决这类问题的算法流程如下： 找到这个序列的中点 mid； 将所有点对 (i,j) 划分为 3 类： 1≤i,j≤mid 的点对； 1≤i≤mid,mid+1≤j≤n 的点对； mid+1≤i,j≤n 的点对。 将 (1,n) 这个序列拆成两个序列 (1,mid) 和 (mid+1,n)。此时第一类点对和第三类点对都在这两个序列之中； 递归地处理这两类点对； 设法处理第二类点对。 可以看到 CDQ 分治的思想就是不断地把点对通过递归的方式分给左右两个区间。 在实际应用时，我们通常使用一个函数 solve(l, r) 处理 l≤i,j≤r 的点对。上述算法流程中的递归部分便是通过 solve(l, mid) 与 solve(mid, r) 来实现的。剩下的第二类点对则需要额外设计算法解决。 代码 对应题目：P3810 【模板】三维偏序（陌上花开） 参考资料 从《Cash》谈一类分治算法的应用（文件存档备份），陈丹琦，2008 年。 2.15 CDQ 分治，AcWing 算法进阶课，闫学灿，2020 年 11 月 20 日。 CDQ 分治，OI Wiki，2021 年 10 月 11 日。 "},{"title":"点分治学习笔记","date":"2022-05-24T21:38:57.000Z","url":"/tree-divide/","tags":["图论","树分治","点分治","分治"],"categories":["笔记"],"content":"点分治是用来解决树上路径问题的一种方法。 树的重心 定义 一棵树的重心是该树以该点为根时最大子树最小的点。 性质 以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。 树至多有两个重心。如果树有两个重心，那么它们相邻。此时树一定有偶数个节点，且可以被划分为两个大小相等的分支，每个分支各自包含一个重心。 树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。 往树上增加或减少一个叶子，如果原节点数是奇数，那么重心可能增加一个，原重心仍是重心；如果原节点数是偶数，重心可能减少一个，另一个重心仍是重心。 把两棵树通过一条边相连得到一棵新的树，则新的重心在较大的一棵树一侧的连接点与原重心之间的简单路径上。如果两棵树大小一样，则重心就是两个连接点。 求法 求重心可以用一次 DFS 完成。 在 DFS 中计算每个子树的大小，记录“向下”的子树的最大大小，利用总点数 - 当前子树（这里的子树指有根树的子树）的大小得到“向上”的子树的大小，然后就可以依据定义找到重心了。 代码 点分治 实现 先选择一个节点 p 作为根节点，则相对 p 而言，树上的路径可以分为两类： 经过根节点 p； 包含于 p 的某一棵子树中。 根据分治的思想，对于第 2 类路径，可以将 p 的每棵子树作为子问题递归求解。 对于第 1 类路径，可以从根节点 p 将路径分为 u→p 和 p→v 两端。然后从 p 出大对整棵树进行 DFS，求出 dist 数组表示从根节点 p 走到节点 x 的距离。 对于 P3806 【模板】点分治 1 这道题，在求出某棵子树的 dist 数组之后，若存在一条长为 queryj​−disti​ 的路径（这个路径是上一棵及以前的子树中到根节点的），则整棵树中一定存在长为 queryj​ 的路径，标记答案数组即可。本轮循环完成后再将本次的 dist 数组标记到 exists 数组中以供下次使用。 代码 参考资料 0x45 点分治，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 一种基于错误的寻找重心方法的点分治的复杂度分析，刘承奥，2017 年 9 月 24 日。 树分治，OI Wiki，2022 年 2 月 13 日。 点分治学习笔记，黄浩睿，2016 年 6 月 17 日。 题解：P3806 【模板】点分治 1，niiick，2020 年 8 月 8 日。 2.14 点分治和点分树，AcWing 算法进阶课，闫学灿，2020 年 11 月 14 日。 "},{"title":"洛谷 - P5596 【XR-4】题","date":"2022-05-23T21:26:36.000Z","url":"/luogu-p5596/","tags":["数学","推式子"],"categories":["题解"],"content":"题目信息卡题目名称题提交地址洛谷 P5596题目难度提高+/省选- 题面 题目描述 小 X 遇到了一道题： 给定自然数 a,b，求满足下列条件的自然数对 (x,y) 的个数： y2−x2=ax+b 他不会，只好求助于精通数学的你。 如果有无限多个自然数对满足条件，那么你只需要输出 inf 即可。 输入格式 一行两个整数 a,b。 输出格式 如果个数有限，一行一个整数，表示个数。 如果个数无限，一行一个字符串 inf。 输入输出样例 样例输入 #1 样例输出 #1 样例解释 #1 (x,y)=(6,9). 样例输入 #2 样例输出 #2 样例输入 #3 样例输出 #3 样例输入 #4 样例输出 #4 样例输入 #5 样例输出 #5 数据范围与约定 本题采用捆绑测试。 Subtask 1（3 points）：a=b=0。 Subtask 2（6 points）：0≤a,b≤2，不存在无限个数的情况。 Subtask 3（9 points）：0≤a,b≤100，不存在无限个数的情况。 Subtask 4（13 points）：0≤a,b≤103，不存在无限个数的情况。 Subtask 5（14 points）：0≤a≤104，0≤b≤107。 Subtask 6（14 points）：a=0。 Subtask 7（14 points）：b=0。 Subtask 8（27 points）：无特殊限制。 对于 100% 的数据，0≤a≤108，0≤b≤1015。 思路 先观察题目中给出的这个式子： y2−x2=ax+b(1) 对 (1) 式进行移项，得： y2−b=x2+2ax(2) 对 (2) 式右侧配方，得： y2−b=(x+2a​)2−4a2​(3) 将 (3) 式两侧同乘 4，得： 4y2−4b=(2x+a)2−a2(4) 对 (4) 式再次移项，得： a2−4b=(2x+a)2−4y2(5) 展开 (5) 式左侧，得： a2−4b=(2x+a+2y)(2x+a−2y)(6) 由题，显然 2x+a+2y&gt;0，接下来分类讨论： 当 a2−4b&lt;0 时，2x+a−2y&lt;0： 左右同乘 −1，得： 4b−a2=(2y+2x+a)(2y−2x−a)(7) 记 p=2y+2x+a，q=2y−2x−a（0&lt;q&lt;p），显然可以将 4b−a2 分解为两数之积可以得到一组 p,q。又有： p+qp−q​=4y=4x+2a⇒p−q−2a=4x​ 可以枚举 q 再据此计算出 p，进而再计算出 x,y 的取值。 当 a2−4b&gt;0 时，2x+a−2y&gt;0： 记 p=2x+a+2y，q=2x+a−2y（0&lt;q&lt;p），显然可以将 a2−4b 分解为两数之积可以得到一组 p,q。又有： p+qp−q​=4x+2a⇒p+q−2a=4x=4y​ 可以枚举 q 再据此计算出 p，进而再计算出 x,y 的取值。 当 a2−4b=0 时，2x+a−2y=0： 由 a2−4b=0 可知，a 为偶数。可得 x+2a​=y。 显然对于任意一个 x 都有一个与其对应的 y 满足条件。此时有无穷多组解。 代码 "},{"title":"S2OJ - 1426. 空","date":"2022-05-22T20:33:21.000Z","url":"/s2oj-1426/","tags":["STL","S2OJ"],"categories":["题解"],"content":"题目信息卡题目名称空提交地址S2OJ 1426题目来源2022.05.21 三省联考 题面 题目描述 Utsuho 有 n 条线段，现在她希望在其中找到两条有公共点的线段，使得它们的异或值最大。 定义线段异或值为它们并的长度减它们交的长度。 输入格式 输入的第一行包括一个正整数 n，表示 Utsuho 的线段的个数。 接下来 n 行每行包括两个正整数 l,r，表示 Utsuho 拥有的线段的左右端点。 输出格式 输出一行一个整数，表示能得到的最大异或值。 输入输出样例 样例输入 #1 样例输出 #1 样例解释 #1 选择第一条和第二条：99−40=59； 选择第一条和第三条：90−50=40； 选择第二条和第三条：99−0=99。 样例输入 #2 样例输出 2 数据规模与约定 对于 20% 的数据，满足 l,r,n≤300; 对于 40% 的数据，满足 n≤2×103; 另有 10% 的数据，满足 l=1; 对于 100% 的数据，满足 1≤n≤2×105，1≤l≤r≤108。 思路 算是个优化版的暴力。考场上的思路不是特别清晰，所以前前后后一共搞了一个多小时。这个做法的不如正解的简单明了，但是跑的比正解快，内存占用还比正解小。 同一直线上的两条线段存在一下几种关系： 包含，两者的异或值为 (l2​−l1​)+(r1​−r2​)； 相交，两者的异或值为 (l2​−l1​)+(r2​−r1​)； 相离，此时对最大异或值没有贡献，忽略即可。 接下来可以分类讨论： 对于包含的情况，可以枚举线段 2，然后使用堆维护前面所有线段中长度最长的线段作为线段 1。 对于相交的情况，上方的计算异或值的式子可以改写为 (l2​+r2​)−(l1​+r1​)，那么可以枚举线段 2，并使用堆维护 (l+r) 值最大的线段 1。 可以使用优先队列模拟堆，省去了手写的麻烦。 代码 "},{"title":"洛谷 - P2261 [CQOI2007] 余数求和","date":"2022-05-21T21:44:26.000Z","url":"/luogu-p2261/","tags":["数学","洛谷","分块"],"categories":["题解"],"content":"题目信息卡题目名称余数求和提交地址洛谷 P2261题目难度提高+/省选-题目来源CQOI2007 题面 题目描述 给出正整数 n 和 k，请计算： G(n,k)=i=1∑n​kmodi 其中 kmodi 表示 k 除以 i 的余数。 输入格式 输入只有一行两个整数，分别表示 n 和 k。 输出格式 输出一行一个整数表示答案。 输入输出样例 样例输入 #1 样例输出 #1 样例解释 #1 G(10,5)=0+1+2+1+0+5+5+5+5+5=29。 数据范围与约定 对于 30% 的数据，保证 n,k≤103； 对于 60% 的数据，保证 n,k≤106； 对于 100% 的数据，保证 1≤n,k≤109。 思路 ==​i=1∑n​kmodii=1∑n​k−i⌊ik​⌋nk−i=1∑n​i×⌊ik​⌋​ 然后使用整除分块计算。设 t=⌊lk​⌋，若 t=0，则 r=⌊tk​⌋，否则 r=n。将 ans 减去 (l+r)/2×t×(r−l+1)（区间内 i 的平均值 × ⌊lk​⌋ × 区间长度）。 当 t=0 时可知余下部分全为 0，退出循环即可。 代码 "},{"title":"AtCoder - AGC048B Bracket Score","date":"2022-05-11T21:52:43.000Z","url":"/atcoder-agc048b/","tags":["AtCoder","贪心"],"categories":["题解"],"content":"题面 题目描述 给定一个偶数 N 和长度为 N 的整数序列 A 和 B。在这里，我们为一个长度为 N 的括号序列 s 定义一个分数： s 的总分是其中每个字符的分数的总和； 第 i 个字符若是 ( 或 )，则分数为 Ai​，否则分数为 Bi​。 请你构造出一个括号序列，使得这个括号序列的分数最大。 输入格式 第一行一个整数 N。 第二行 N 个整数表示 A 序列。 第三行 N 个整数表示 B 序列。 输出格式 一行一个整数，表示最大分数。 数据范围与约定 对于 100% 的数据，2≤N≤105，1≤Ai​,Bi​≤109。 思路 由括号序列的性质得出，一对匹配的括号的间距一定是偶数，即它们两个的位置的奇偶性不同。 还能发现，一旦每个位置上的括号类型（圆/方括号）确定且一对匹配的括号的间距是偶数，一定能找到一种确定括号朝向的方法使得序列合法。 可以使用贪心解决本题。 先钦定全部选择圆括号，然后对于每个位置，计算将它改为方括号对答案的影响。那么可以将改动奇数位置和改动偶数位置对答案的影响分别放入两个堆中，每次分别取出两个堆的堆顶，将对应的位置改为方括号，直到再取堆顶答案不会更优为止。 代码 "},{"title":"Codeforces - 1675D. Vertical Paths","date":"2022-05-11T19:11:47.000Z","url":"/codeforces-1675d/","tags":["Codeforces","图论","树"],"categories":["题解"],"content":"题目信息卡题目名称Vertical Paths提交地址Codeforces 1675D洛谷 CF1675D题目难度普及/提高-题目来源Codeforces Round #787 (Div. 3) 题面 本文中所给出的题面为原题面的中文翻译，并非原始题面。翻译如有错误之处，请联系指出。 题目描述 给定一棵由 n 个顶点组成的有根树。顶点由 1 到 n 编号。任何顶点都可以是树的根。 请在树上找出这样一组路径： 每个顶点恰好属于一条路径，每条路径可以包含一个或多个顶点； 在每条路径中，每个节点的下一个节点是当前节点的子节点（即路径总是向下 —— 从父节点到子节点）； 路径的数量最少。 输入格式 第一行输入一个整数 t 表示该测试点内测试数据的组数。 每组测试点的第 1 行包含一个整数 n 表示树的节点个数。第 2 行包含 n 个整数，第 i 个整数 pi​ 表示第 i 个节点的父节点为 pi​。根节点的父亲是它本身。 输出格式 对于每组测试数据： 第 1 行输出一个整数 m 表示组内路径的数量。 然后输出 m 条路径的信息： 第 1 行输出路径的长度； 第 2 行按照从上到下的顺序输出该路径内的的所有节点编号。 在每组测试数据的末尾输出一个空行。 如果有多种答案，输出其中的任何一种即可。 输入输出样例 输入样例 #1 输出样例 #1 样例解释 #1 以该测试点中的第一组数据为例，有三条路径： 3→1→5，长度为 3； 4，长度为 1； 2，长度为 1。 数据范围与约定 对于 100% 的数据，1≤t≤104，1≤n≤2×105，1≤pi​≤n。 数据保证每个测试点中的所有测试数据中 n 的总和不超过 2×105。 思路 看到这道题的样例说明之后第一眼想到的是树链剖分（图源 OI Wiki）： 按照这样剖出来的答案显然是对的。 再看看样例会发现一个很显然的结论：最小路径数一定是叶子节点数。 可以使用深度优先搜索，遇到分叉的时候就新开其他路径，同时挑选一个方向继续当前路径，这样出来的答案一定是最优的。 具体实现可以看代码。 代码 "},{"title":"BZOJ - 1013. 球形空间产生器","date":"2022-05-09T16:39:41.000Z","url":"/bzoj-1013/","tags":["数学","线性代数","矩阵","高斯消元"],"categories":["题解"],"content":"题目信息卡题目名称球形空间产生器提交地址BZOJ1013 @ HydroDarkBZOJ 1013洛谷 P4035AcWing 207题目难度省选/NOI-题目来源JSOI2008 题面 题目描述 有一个球形空间产生器能够在 n 维空间中产生一个坚硬的球体。现在，你被困在了这个 n 维球体中，你只知道球面上 n+1 个点的坐标，你需要以最快的速度确定这个 n 维球体的球心坐标，以便于摧毁这个球形空间产生器。 输入格式 第一行是一个整数 n。接下来的 n+1 行，每行有 n 个实数，表示球面上一点的 n 维坐标。每一个实数精确到小数点后 6 位，且其绝对值都不超过 20000。 输出格式 有且只有一行，依次给出球心的 n 维坐标（ n 个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后 3 位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。 输入输出样例 样例输入 #1 样例输出 #1 数据范围与约定 对于 100% 的数据，1≤n≤10。 提示 给出两个定义： 球心：到球面上任意一点距离都相等的点。 距离：设两个 n 维空间上的点 A,B 的坐标为 (a1​,a2​,⋯,an​),(b1​,b2​,⋯,bn​)，则 AB 之间的距离定义为：dist=∑i=1n​(ai​−bi​)2​。 思路 设球的半径为 R，球心坐标为 (x1​,x2,…,xn​)。那么根据球体的性质，显然有： j=0∑n​(ai,j​−xj​)2=R2 那么展开来写可以得到一个方程组的形式： ⎩⎨⎧​(a1,1​−x1​)2+(a1,2​−x2​)2+⋯+(a1,n​−xn​)2(a2,1​−x1​)2+(a2,2​−x2​)2+⋯+(a2,n​−xn​)2⋮(an+1,1​−x1​)2+(an+1,2​−x2​)2+⋯+(an+1,n​−xn​)2​=R2=R2=R2​​ 但这个方程组是由 n+1 个 n 元二次方程构成的，不是线性方程组。本着「出题人绝对不会多给 1 Byte 有用数据」的原则，我们可以察觉到 n+1 中的异样之处。通过将相邻两个方程作差, 得到的结果是： ⎩⎨⎧​2(a2,1​−a1,1​)x1​+2(a2,2​−a1,2​)x2​+⋯+2(a2,n​−a1,n​)xn​2(a3,1​−a2,1​)x1​+2(a3,2​−a2,2​)x2​+⋯+2(a3,n​−a2,n​)xn​⋮2(an+1,1​−an,1​)x1​+2(an+1,2​−an,2​)x2​+⋯+2(an+1,n​−an,n​)xn​​=a2,12​+a2,22​+⋯+a2,n2​−a1,12​−a1,22​−⋯−a1,n2​=a3,12​+a3,22​+⋯+a3,n2​−a2,12​−a2,22​−⋯−a2,n2​=an+1,12​+an+1,22​+⋯+an+1,n2​−an,12​−an,22​−⋯−an,n2​​​ 可以转化成增广矩阵的形式： ⎣⎡​2(a2,1​−a1,1​)2(a3,1​−a2,1​)⋮2(an+1,1​−an,1​)​2(a2,2​−a1,2​)2(a3,2​−a2,2​)⋮2(an+1,2​−an,2​)​⋯⋯⋱⋯​2(a2,n​−a1,n​)2(a3,n​−a2,n​)⋮2(an+1,n​−an,n​)​∑j=1n​(a2,j2​−a1,j2​)∑j=1n​(a3,j2​−a2,j2​)⋮∑j=1n​(an+1,j2​−an,j2​)​⎦⎤​ 对该矩阵进行高斯消元即可。 代码 "},{"title":"POJ - 3696. 最幸运的数字","date":"2022-05-08T21:59:17.000Z","url":"/poj-3696/","tags":["数学","数论","同余","POJ","欧拉定理"],"categories":["题解"],"content":"题目信息卡题目名称最幸运的数字提交地址POJ 3696AcWing 202 题面 题目描述 8 是中国的幸运数字，如果一个数字的每一位都由 8 构成则该数字被称作是幸运数字。 现在给定一个正整数 L，请问至少多少个 8 连在一起组成的正整数（即最小幸运数字）是 L 的倍数。 输入格式 输入包含多组测试用例。 每组测试用例占一行，包含一个整数 L。 当输入用例 L=0 时，表示输入终止，该用例无需处理。 输出格式 每组测试用例输出结果占一行。 结果为 Case i: 和一个整数 N，N 代表满足条件的最小幸运数字的位数。 如果满足条件的幸运数字不存在，则 N=0。 输入输出样例 样例输入 #1 样例输出 #1 数据范围与约定 对于 100% 的数据，1≤L≤2×109。 思路 x 个 8 连在一起组成的正整数可以表示为 98(10x−1)​，那么题意就转化为了求最小的 x 满足 L&nbsp;∣&nbsp;98(10x−1)​。 设 d=gcd(L,8)，有推论如下： L&nbsp;∣&nbsp;98(10x−1)​⟺9L&nbsp;∣&nbsp;8(10x−1)⟺d9L​&nbsp;∣&nbsp;10x−1⟺10x≡1(modd9L​) 引理： 若 a,n∈N∗ 互质，则满足 ax≡1(modn) 的最小正整数 x0​ 是 φ(n) 的约数。 由引理得，可以枚举 φ(d9L​) 的所有约数，然后求出 x0​ 的最小值即为答案。 代码 "},{"title":"高斯消元学习笔记","date":"2022-05-07T21:49:42.000Z","url":"/gauss/","tags":["数学","线性代数","矩阵","高斯消元"],"categories":["笔记"],"content":"前置知识 矩阵 请参阅《矩阵学习笔记》。 线性方程组的矩阵表示法 线性方程组是由 n 个 m 元一次方程共同构成的。例如，有线性方程组如下： ⎩⎨⎧​x1​+2x2​−x3​2x1​+x2​−3x3​−x1​−x2​+2x3​​=−6=−9=7​​(1) 该方程组的所有系数可以写成一个 n×m 的「系数矩阵」： ⎣⎡​12−1​21−1​−1−32​⎦⎤​ 加上等号右侧的常数项可以写成一个 n×(m+1) 的「增广矩阵」： ⎣⎡​12−1​21−1​−1−32​−6−97​⎦⎤​ 初等行列变换 矩阵的初等行变换包括以下几种操作： 将某一行乘一个非零的数； 交换某两行； 将某行的若干倍加到另一行。 同理，我们也可以定义矩阵的初等列变换。这两种变换统称矩阵的初等行列变换。 高斯消元法 高斯消元是一种通过初等行列变换将增广矩阵变为简化阶梯矩阵的线性方程组求解方法。 引入 使用若干次初等行变换求解上文中提到的方程组 (1)，过程如下： ⇒⇒⇒⇒⇒​⎣⎡​12−1​21−1​−1−32​−6−97​⎦⎤​⎣⎡​10−1​2−3−1​−1−12​−637​⎦⎤​⎣⎡​100​2−31​−1−11​−631​⎦⎤​⎣⎡​100​21−1​−11−1​−613​⎦⎤​⎣⎡​100​210​−112​−616​⎦⎤​⎣⎡​100​210​−111​−613​⎦⎤​​ 最后得到的矩阵被称为「阶梯形矩阵」，它的系数矩阵部分被称为「上三角矩阵」，这个矩阵表达的信息为： ⎣⎡​100​210​−111​−613​⎦⎤​⇒⎩⎨⎧​x1​+2x2​−x3​x2​+x3​x3​​=−6=1=3​​ 再运用加减消元法即可得到每个未知量的解，也可以进一步化简该矩阵： ⇒⇒​⎣⎡​100​210​−111​−613​⎦⎤​⎣⎡​100​210​001​−3−23​⎦⎤​⎣⎡​100​010​001​1−23​⎦⎤​​ 最后得到的矩阵名为「简化阶梯形矩阵」，它的系数矩阵部分是一个 n 阶单位矩阵，也叫做「对角矩阵」。该矩阵直接给出了方程组的解。 基本思想 对于每个未知量 xi​，找到一个 xi​ 的系数非零、但 x1​∼xi−1​ 的系数都是零的方程，然后使用初等行列变换将其他方程组 xi​ 的系数全部消成零，之后再逐一回代求解出所有未知量。 方程组的解 消元后有以下几种情况： 完美阶梯形：存在唯一解； 含有系数全为零、常数不为零的行：无解； 含有系数和常数均为零的行：存在无穷多组解。 算法实现 枚举系数矩阵中的每一列 c： 找到绝对值最大的一行； 将该行移至顶部； 将该行第 1 个非零的数变成 1； 将下方所有行的第 c 列变成 0。 之后再将系数矩阵化为对角矩阵即可求出所有未知量的值。 代码 a 数组中存储了表示线性方程组的增广矩阵。 当函数返回 0 时方程组有解，返回 -1 时无解，返回 1 时有无穷多组解。 参考资料 6.3.1 高斯消元法，《信息学奥赛之数学一本通》（ISBN 978-7-5641-6576-5，东南大学出版社），林厚从，2019 年 11 月第 9 次修订版。 高斯消元，第四章 数学知识，AcWing 算法基础课，闫学灿，2019 年 7 月 5 日。 0x35 高斯消元和线性空间，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 "},{"title":"POJ - 3090. Visible Lattice Points","date":"2022-05-03T17:19:18.000Z","url":"/poj-3090/","tags":["数学","数论","约数"],"categories":["题解"],"content":"题目信息卡题目名称Visible Lattice Points提交地址POJ 3090洛谷 P2158AcWing 201题目难度提高+/省选- 本题有以下几种解法： 莫比乌斯反演 欧拉反演（本文） 题面 难度：提高+/省选- 题目描述 在一个平面直角坐标系的第一象限内，如果一个点 (x,y) 与原点 (0,0) 的连线中没有通过其他任何点，则称该点在原点处是可见的。 例如，点 (4,2) 就是不可见的，因为它与原点的连线会通过点 (2,1)。 部分可见点与原点的连线如下图所示： 编写一个程序，计算给定整数 N 的情况下，满足 0≤x,y≤N 的可见点 (x,y) 的数量（可见点不包括原点）。 输入格式 第一行包含整数 C，表示共有 C 组测试数据。 每组测试数据占一行，包含一个整数 N。 输出格式 每组测试数据的输出占据一行。 应包括：测试数据的编号（从 1 开始），该组测试数据对应的 N 以及可见点的数量。 同行数据之间用空格隔开。 输入输出样例 样例输入 #1 样例输出 #1 数据范围与约定 对于 100% 的数据，1≤N,C≤1000。 思路 分析题目可得，除了 (1,0)、(0,1) 和 (1,1) 三个点，其他点都只能在满足 gcd(x,y)=1 时被看到。 然后还可以发现能看到的点是沿着 (0,0)−(n,n) 这条直线对称的，所以只计算其中一半然后再将答案乘 2 即可。 可以发现满足上述性质的点的数量恰好是 ∑i=2n​φ(i)。 所以最终答案为 3+2×∑i=2n​φ(i)。 代码 "},{"title":"矩阵学习笔记","date":"2022-05-02T21:46:16.000Z","url":"/matrix/","tags":["数学","线性代数","矩阵"],"categories":["笔记"],"content":"在数学中，矩阵（Matrix）是一个按照长方阵列排列的实数或复数集合，最早来自于方程组的系数及常数所构成的方阵，是高等代数学中的常见工具。 矩阵 由 n×m 个数 ai,j​ 排成的 n 行 m 列的数表叫做 n 行 m 列的矩阵，简称 n×m 矩阵。记作： A=⎣⎡​a1,1​a2,1​⋮an,1​​a1,2​a2,2​⋮an,2​​⋯⋯⋱⋯​a1,m​a2,m​⋮an,m​​⎦⎤​ 这 n×m 个数称为矩阵 A 的元素，简称为元。数 ai,j​ 位于矩阵 A 的第 i 行第 j 列，称为矩阵 A 的 (i,j) 元。以数 ai,j​ 为 (i,j) 元的矩阵也可记作 [ai,j​] 或 [ai,j​]n×m​。 如果矩阵 A 的元素可以写成只与其行数 i 与列数 j 有关的统一函数 f，那么也可以使用 A=[f(i,j)]n×m​ 作为 A 的简写。 n×m 矩阵 A 也可记作 Anm​。 矩阵的基本运算 矩阵的基本运算包括加法、减法、数乘、转置、共轭等。 加（减）法 对于两个同型（行数、列数均相同）的矩阵 A 和 B，加法就是将对应 (i,j) 元做加法运算。如： [15​11​44​]+[14​25​36​]=[1+15+4​1+21+5​4+34+6​]=[29​36​710​] 减法运算同理。 矩阵的加（减）法运算满足结合律和交换律： A+B(A+B)+C​=B+A=A+(B+C)​ 数乘 矩阵的数乘是指一个数乘以一个矩阵，只需要将这个数乘到矩阵的每个元素上即可。如： 2×[15​11​44​]=[2×12×5​2×12×1​2×42×4​]=[210​22​88​] 矩阵的数乘运算满足结合律和分配律： (λμ)A(λ+μ)Aλ(A+B)​=λ(μA)=λA+μA=λA+λB​ 矩阵的加法、减法和数乘运算合称为矩阵的线性运算。 转置 将矩阵 A 的行换成同序数的列所得到的新矩阵称为 A 的转置矩阵，这一过程称为矩阵的转置，记为 AT。如： [15​11​44​]T=⎣⎡​114​514​⎦⎤​ 矩阵的转置运算满足以下运算律： (AT)T(λA)T(AB)T​=A=λAT=BTAT​ 共轭 对于一个复矩阵，其共轭矩阵定义为 Ai,j​=Ai,j​​。如： A=[3+i2−2i​5i​]​A=[3−i2+2i​5−i​]​ 矩阵的共轭转置定义为 A∗i,j​=Aj,i​​（也可记作 A∗=(A)T=AT）。如： A=[3+i2−2i​5i​]​A∗=[3−i5​2+2i−i​]​ 矩阵乘法 两个矩阵的乘法运算仅当第一个矩阵 A 的列数和第二个矩阵 B 的行数相等时才能定义。如 An×m​,Bm×p​ 的乘积 C 是一个 n×p 矩阵 C=[ci,j​]，它的任意一个元素值为： ci,j​=ai,1​×b1,j​+ai,2​×b2,j​+⋯+ai,m​×bm,j​=k=1∑m​(ai,k​×bk,j​) 将此乘积记为 C=AB。如： ==​[1−1​03​21​]×⎣⎡​321​110​⎦⎤​[(1×3+0×2+2×1)(−1×3+3×2+1×1)​(1×1+0×1+2×0)(−1×1+3×1+1×0)​][54​12​]​ 矩阵乘法满足结合律、左分配律、右分配律，但不满足交换律： (AB)C(A+B)CC(A+B)​=A(BC)=AC+BC=CA+CB​ 单位矩阵 n 阶单位矩阵 In​ 是一个 n×n 的方形矩阵，其主对角线上的所有数为 1，其余数为 0。 I1​=[1​],​I2​=[10​01​],​I3​=⎣⎡​100​010​001​⎦⎤​,​⋯,​In​=⎣⎡​10⋮0​01⋮0​⋯⋯⋱⋯​00⋮1​⎦⎤​​ 单位矩阵有一个特殊性质：任何矩阵乘上这个矩阵都得它本身，即 AI=A。这个性质在进行矩阵快速幂的时候会用到。 矩阵快速幂 矩阵快速幂和一般的快速幂类似，都是通过运用结合律来减少乘法运算的次数来达到提速的目的的。 Ak=⎩⎨⎧​IA×Ak−1A2k÷2​if&nbsp;k=0if&nbsp;kmod2=1if&nbsp;kmod2=0​​ 矩阵加速递推 斐波那契数列 斐波那契数列的递推公式如下： fn​={1fn−1​+fn−2​​if&nbsp;n∈{1,2}if&nbsp;n≥3​ 可以看出 fn​ 和 fn−1​ 是存在一定关系的，可以构造一个多项式来找出关系： fn​fn−1​​=fn−1​+fn−2​=fn−1​​(1) 设 x1​=fn−1​,x2​=fn−2​,y1​=fn​,y2​=fn−1​，则 1 式可化为以下形式： y1​y2​​=x1​+x2​=x1​​(2) 这种齐次线性方程组可以使用 系数矩阵×N&nbsp;维向量 的形式来表示，即： AX=B 则有： [y1y2​]=[11​10​][x1x2​](3) 设 F(n)=[fn​fn−1​​]，由 3 式得： F(n)=[11​10​]n−1[f1​f0​​](4) 这样就将本节刚开始的递推式转换成了一个求解矩阵幂运算的通项公式，使用上一节中提到的矩阵快速幂的知识即可将复杂度优化到 log 级别。 推广 例题：P1939 【模板】矩阵加速（数列） 由题可得该数列的递推公式： fn​={1fn−1​+fn−3​​if&nbsp;n∈{1,2,3}if&nbsp;n≥4​ 与上题相同，可以构造一组多项式来找出关系： fn​fn−1​fn−2​fn−3​​=fn−1​+fn−3​=fn−1​=fn−2​=fn−3​​(1) 设 x1​=fn−1​,x2​=fn−2​,x3​=fn−3​,x4​=fn−4​,y1​=fn​,y2​=fn−1​,y3=fn−2​,y4=fn−3​，则 1 式可化为以下形式： y1​y2​y3​y4​​=x1​+x3​=x1​=x2​=x3​​(2) 用 系数矩阵×N&nbsp;维向量 的形式来表示，有： ⎣⎡​y1​y2​y3​y4​​⎦⎤​=⎣⎡​1100​0010​1001​0000​⎦⎤​⎣⎡​x1​x2​x3​x4​​⎦⎤​(3) 从 3 式可以看出，x4​ 的系数恒为 0，可以化简为： ⎣⎡​y1​y2​y3​​⎦⎤​=⎣⎡​110​001​100​⎦⎤​⎣⎡​x1​x2​x3​​⎦⎤​(4) 设 F(n)=⎣⎡​fn​fn−1​fn−2​​⎦⎤​，由 4 式得： F(n)=⎣⎡​110​001​100​⎦⎤​n−1⎣⎡​f3​f2​f1​​⎦⎤​ 参照此种方法，就可以使用矩阵加速递推了。 参考资料 6.1 矩阵及其运算，《信息学奥赛之数学一本通》（ISBN 978-7-5641-6576-5，东南大学出版社），林厚从，2019 年 11 月第 9 次修订版。 矩阵，OI Wiki，2022 年 2 月 13 日。 矩阵快速幂，一瓜算法小册，2020 年 2 月 18 日。 "},{"title":"POJ - 1006. 生理周期","date":"2022-05-02T10:16:09.000Z","url":"/poj-1006/","tags":["数学","数论","同余","中国剩余定理","POJ"],"categories":["题解"],"content":"题目信息卡题目名称生理周期提交地址POJ 1006AcWing 1300 题面 题目描述 人生来就有三个生理周期，分别为体力、感情和智力周期，它们的周期长度为 23 天、28 天和 33 天。每一个周期中有一天是高峰。在高峰这天，人会在相应的方面表现出色。例如，智力周期的高峰，人会思维敏捷，精力容易高度集中。因为三个周期的周长不同，所以通常三个周期的高峰不会落在同一天。对于每个人，我们想知道何时三个高峰落在同一天。对于每个周期，我们会给出从当前年份的第一天开始，到出现高峰的天数（不一定是第一次高峰出现的时间）。你的任务是给定一个从当年第一天开始数的天数，输出从给定时间开始（不包括给定时间）下一次三个高峰落在同一天的时间（距给定时间的天数）。例如：给定时间为 10，下次出现三个高峰同天的时间是 12，则输出 2（注意这里不是 3）。 输入格式 输入四个整数：p,e,i,d。 p,e,i 分别表示体力、情感和智力高峰出现的时间（时间从当年的第一天开始计算）。d 是给定的时间，可能小于 p,e,i。 所有给定时间是非负的并且小于 365，所求的时间小于 21252。 当 p=e=i=d=−1 时，输入数据结束。 输出格式 从给定时间起，下一次三个高峰同天的时间（距离给定时间的天数）。 采用以下格式： 注意：即使结果是 1 天，也使用复数形式 days。 输入输出样例 样例输入 #1 样例输出 #1 思路 设 s 表示三个峰值同时出现的那一天，T 为周期，有： s=p+Tp​kp​=e+Te​ke​=i+Ti​ki​(1) 显然需要求出 kp​,ke​,ki​ 使 (1) 式成立，但题目只需要求出 S 的值，所以可以换一个角度入手。可以将 (1) 式转化为： ⎩⎨⎧​s≡ps≡es≡i​(mod&nbsp;23)(mod&nbsp;28)(mod&nbsp;33)​ 这样就可以使用中国剩余定理来解决问题了： 令 (28×33×a)≡1&nbsp;(mod&nbsp;23)，解得 a=6，则 28×33×a=5544。 令 (23×33×b)≡1&nbsp;(mod&nbsp;28)，解得 b=19，则 23×33×b=14421。 令 (23×28×c)≡1&nbsp;(mod&nbsp;33)，解得 c=2，则 23×28×c=1288。 故 s=5544×p+14421×e+1288×i，则最终结果为 s−d。 代码 "},{"title":"中国剩余定理学习笔记","date":"2022-04-24T21:34:49.000Z","url":"/crt/","tags":["数学","数论","同余","中国剩余定理"],"categories":["笔记"],"content":"前置知识 扩展欧几里得算法 线性同余方程 中国剩余定理 中国剩余定理（Chinese Remainder Theorem，CRT）可求解如下形式的一元线性同余方程组（其中 n1​,n2​,⋯,nk​ 两两互质）： ⎩⎨⎧​x≡a1​x≡a2​…x≡ak​​(modn1​)(modn2​)(modnk​)​​ 算法流程 计算所有模数的积 n； 对于第 i 个方程： 计算 mi​=ni​n​； 计算 mi​ 在模 ni​ 意义下的 逆元 mi−1​； 第 i 个方程的解 ci​=mi​×mi−1​（不要对 ni​ 取模）。 求出方程组的唯一解 x=∑i=1k​ai​mi​ci​(modn)。 代码实现 证明 因为 mi​=ni​n​ 是除 mi​ 之外所有模数的倍数，所以 ∀k=i,ai​mi​ci​≡0(modmk​)。又因为 ai​mi​ci​≡ai​(modmi​)，所以代入 x=∑i=1n​ai​mi​ci​，原方程组成立。 证毕。 参考资料 第 154 ~ 155 页，0x33 同余，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 1.5 中国剩余定理，《信息学奥赛之数学一本通》（ISBN 978-7-5641-6576-5，东南大学出版社），林厚从，2019 年 11 月第 9 次修订版。 中国剩余定理，OI Wiki，2022 年 3 月 27 日。 "},{"title":"扩展欧几里得算法学习笔记","date":"2022-04-23T20:25:05.000Z","url":"/exgcd/","tags":["数学","数论","扩展欧几里得算法","逆元"],"categories":["笔记"],"content":"相关定理 欧几里得算法 ∀a,b∈N,b=0,gcd(a,b)=gcd(b,amodb)​ Bézout 定理 对于任意整数 a,b，存在一对整数 x,y 满足 ax+by=gcd(a,b)。 扩展欧几里得算法 扩展欧几里得算法是用来求二元一次不定方程（如 (1) 式）的一组特解的算法。 ax+by=c(1) (1) 式有解当且仅当 gcd(a,b)&nbsp;∣&nbsp;c。 实现 对于每次递归， 当 b=0 时， ax+by=a，故 x=1,y=0。 当 b=0 时， x=x,y=y−⌊ba​⌋x。 证明： 设 d=gcd(a,b)，由欧几里得算法得： d​=ax+by=by+(amodb)x=by+(a−⌊ba​⌋b)x=ax+b(y−⌊ba​⌋x)​ 则上述 b=0 情况中的式子成立。 证毕。 代码 通解 求出特解 x0​,y0​ 后补齐次项即可： x=x0​+bky=y0​−ak​ 方程的最小整数解的 k=b/gcd(a,b)，x=(xmodk+k)modk。 逆元 若 ax≡1&nbsp;(mod&nbsp;b)，且 a,b 互质，则称 x 为 a 的逆元，记为 a−1。 可将上式转化为： ax+by=1(2) 这样可以就使用扩展欧几里得算法求出 (2) 式的解，x 的最小解即为 a 的逆元。 参考资料 第 150 ~ 151 页，0x33 同余，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 1.3.4 扩展欧几里得算法，《信息学奥赛之数学一本通》（ISBN 978-7-5641-6576-5，东南大学出版社），林厚从，2019 年 11 月第 9 次修订版。 1.4 逆元，《信息学奥赛之数学一本通》（ISBN 978-7-5641-6576-5，东南大学出版社），林厚从，2019 年 11 月第 9 次修订版。 2022-05-06: 感谢 iBug 指出本文中的错误。 "},{"title":"洛谷 - P1516 青蛙的约会","date":"2022-04-22T11:27:01.000Z","url":"/luogu-p1516/","tags":["数学","同余","扩展欧几里得算法","洛谷","线性同余方程"],"categories":["题解"],"content":"题目信息卡题目名称青蛙的约会提交地址洛谷 P1516LibreOJ 10209POJ 1061题目难度提高+/省选- 题面 题目描述 两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 0 度处为原点，由东往西为正方向，单位长度 1 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 x，青蛙 B 的出发点坐标是 y。青蛙 A 一次能跳 m 米，青蛙 B 一次能跳 n 米，两只青蛙跳一次所花费的时间相同。纬度线总长 L 米。现在要你求出它们跳了几次以后才会碰面。 输入格式 输入只包括一行五个整数 x,y,m,n,L。 输出格式 输出碰面所需要的天数，如果永远不可能碰面则输出一行一个字符串 Impossible。 输入输出样例 样例输入 #1 样例输出 #1 数据范围与约定 对于 100% 的数据，1≤x=y≤2×109，1≤m,n≤2×109，1≤L≤2.1×109。 思路 设 k∈N 表示走了多少天，有方程如下： x+km≡y+kn&nbsp;(modL)(1) 设 p∈N∗ 表示青蛙 A 跳的圈数和青蛙 B 的圈数之差。由 (1) 式可得： (x+km)−(y+kn)=pL(2) 可以转化为： x−y+k(m−n)=pL(3) 移项，得： k(m−n)−pL=−(x−y)(4) 设 c=x−y，b=n−m（此处有变号），可得： kb+pL=c(5) 使 (5) 成立的最小的 c 为 gcd(b,l)，所以当 gcd(b,l)&nbsp;∣&nbsp;c 时本题有解，求出 (5) 中 k 的最小值即可。 代码 "},{"title":"「省选联考 2022 Day1」预处理器","date":"2022-04-17T21:44:39.000Z","url":"/luogu-p8289/","tags":["模拟","省选"],"categories":["题解"],"content":"题目信息卡题目名称预处理器提交地址洛谷 P8289LibreOJ题目难度普及+/提高题目来源联合省选 2022 题面 题目描述 宏是 C/C++ 语言的一项特性，它根据预先定义的规则进行文本替换（也被称为 “宏展开”），能够实现定义常量、简化代码重复输入等功能。例如： 以上代码经过宏展开后变为： 其中，宏定义命令变成了空行，而其他行中的宏被展开成了规则定义的文本。 C/C++ 语言代码在编译时对宏的处理由预处理器完成。你的任务是实现一个简化版的预处理器，要求如下： 代码由行组成，每行除行末的换行符外，均由可打印 ASCII 字符（ASCII 码范围 32∼126）组成。每行要么是 预处理命令（以 # 开头），要么是 普通文本（其他情况）。 预处理器逐行处理代码， 如果是预处理命令，执行该命令，并输出一个空行。 如果是普通文本，对其进行宏展开并输出结果。 预处理命令有两种，分别是宏定义命令 #define 和取消宏定义命令 #undef。 宏定义命令的格式为 #define &lt;name&gt; &lt;content&gt;，其中第一部分 #define 是命令名，第二部分 &lt;name&gt; 是要定义的宏的名字，第三部分 &lt;content&gt; 是要定义的宏的展开内容。 取消宏定义命令的格式为 #undef &lt;name&gt;，其中第一部分 #undef 是命令名，第二部分 &lt;name&gt; 是要取消的宏的名字。 以上两种预处理命令中，相邻两部分之间都严格用一个空格分隔。&lt;name&gt; 是由大小写字母和数字以及下划线组成的标识符（一个或多个字符），&lt;content&gt; 可以包含任意可打印 ASCII 字符（零个或多个字符）。一个宏定义的有效范围是从它定义所在行开始到后续最近的宏名匹配的取消定义所在行为止（如果没有对应的取消定义，则有效范围一直覆盖到文件结束）。 对普通文本进行宏展开时，将一行文本中每段连续极长的大小写字母和数字以及下划线视为标识符（而不是其中一部分），其余为其他字符。从左到右依次对文本中的标识符进行宏展开： 如果该标识符是有效的宏名，则用对应的展开内容替换它，此时该宏名进入正在展开的状态，直到本流程结束；否则原样保留宏名。例如，若宏 A 定义为 b，则文本 A 展开结果为 b（发生替换），文本 B 展开结果仍然为 B（未定义，不替换），文本 AA 展开结果仍然为 AA（AA 是不同于 A 的另一个标识符，未定义），而文本 A*B 展开结果为 b*B。 替换发生后，如果展开内容中包含标识符，重复应用以上的展开操作，称为 “多次展开”。例如，若宏 A 定义为 B，宏 B 定义为 c，则文本 A 的展开结果为 c。 如果待展开的宏名与正在进行展开的某个宏名相同，称为 “递归展开”，此时该宏名不再展开。本规则用来防止无限递归展开。例如，若宏 A 定义为 B+a，宏 B 定义为 A+b，则文本 A 展开结果为 A+b+a，由于最初的 A 处于正在展开状态，因此 A+b+a 里的 A 不再展开。 其他字符原样保留。 注意：出于简化的目的，本题的要求与 C/C++ 语言标准里的描述不完全一致，请以上面的要求为准。最明显的区别是本题只有标识符和其他字符两类词法单元，没有数值、字符串、注释等。 输入格式 输入的第一行包含一个正整数 n，表示要处理的代码行数。 接下来的 n 行是要处理的代码。 输出格式 输出 n 行，为输入逐行预处理后的结果。 输入输出样例 输入样例 #1 样例输出 #1 样例输入 #2 见附件中的 preprocessor/preprocessor2.in。 样例输入 #2 见附件中的 preprocessor/preprocessor2.ans。 样例输入 #3 见附件中的 preprocessor/preprocessor3.in。 样例输入 #3 见附件中的 preprocessor/preprocessor3.ans。 数据范围与约定 【数据范围】 对 20% 的数据，不会出现宏定义命令 #define 和宏取消定义命令 #undef。 对另外 20% 的数据，不会出现多次展开的情况，且不会出现宏取消定义命令 #undef。 对另外 20% 的数据，不会出现多次展开的情况。 对另外 20% 的数据，不会出现递归展开的情况。 对其余数据，无特殊限制。 对 100% 的数据，n≤100，输入的每行字符数都不超过 100，且保证输出的每行字符数都不超过 1000（字符数均不计行末换行符）。保证输入数据中的预处理命令都是合法的，包含但不限于： # 字符只会出现在预处理命令所在行的第一个字符的位置，其他任何位置（包括预处理命令和普通文本）都不会出现 # 字符。 宏定义和取消定义命令的格式是正确的，严格遵循题面所描述的格式。 同一个宏在取消定义之前不会被再次定义。 要取消定义的宏在之前被定义过且还没有被取消过。 也就是说，你不需要做任何语法和语义的错误检查。 【提示】 本题进行输入时建议使用 C++ 语言的按行读入字符串功能，示例如下： 也可以使用 C 语言提供的 fgets 函数，示例如下： 注意：在读取行数 n 之后可能需要额外读取一行以忽略其后的换行符。 附加文件 样例文件（1.7 KB） 民间数据（洛谷，10.7 KB） 思路 这是一道不大不小的模拟题，有一些注意事项： 判断有效的宏名（正则：[A-Za-z0-9_]+）比判断分隔符要容易实现。 题目有要求不能展开无限递归的宏，需要打标记记录一下。 STL 是个好东西。 题外话：我在省选前不久碰见了一个短小精悍的 C 语言编译器，而里面正好有预处理相关的代码：preprocess.c at rui314/chibicc@90d1f7f。可惜的是，这么长的代码我记不住，而且过于工程化，没有必要在考场上写这种东西。不过这个编译器和我曾经用到的 PurgeCSS 库为我提供了一些思路和实现上的点拨，使得我能在考场上切掉这道题，写出来的代码也不至于特别冗长。 STL 相关 一个非常好用的 C++ 参考手册（中文）：zh.cppreference.com。 在考场上如果不知道怎么用 STL 可以去翻头文件中的注释（英文），里面有简单的说明。 std::string 入门 声明一个 std::string 类型的变量 s： 获取字符串长度： 判空： 截取子串： 查找字串： 同样地，也可以查找某个字符出现的位置： STL 也提供了其他查找函数： find_first_of：查找字符串中第一个包含指定字符的位置。 find_last_of：查找字符串中最后一个包含指定字符的位置。 find_first_not_of：查找字符串中第一个不包含指定字符的位置。 find_last_not_of：查找字符串中最后一个不包含指定字符的位置。 使用方法与上面的 find 函数类似，不再过多赘述。 清空字符串： std::unordered_map 入门 std::unordered_map 在 C++11 中被引入，由于其基于哈希的实现导致了在大多数情况下 std::unordered_map 比 std::map 要快。 声明一个 std::unordered_map&lt;std::string, int&gt; 类型的变量 map： 插入元素： 查找元素： 删除迭代器 it 指向的元素： 删除键为 c 的元素： 获取元素个数： 判空： 访问元素： 使用下标访问时如果元素不存在会自动新建，所以建议访问前先使用 map.count() 判断是否存在该元素。 清空整个容器： 代码 "},{"title":"洛谷 - P1541 [NOIP2010 提高组] 乌龟棋","date":"2022-03-29T21:16:32.000Z","url":"/luogu-p1541/","tags":["动态规划","洛谷","线性 DP","多维 DP"],"categories":["题解"],"content":"题目信息卡题目名称乌龟棋提交地址洛谷 P1541LibreOJ 2593AcWing 312题目难度普及+/提高题目来源NOIP2010 题面 题目背景 小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。 题目描述 乌龟棋的棋盘是一行 N 个格子，每个格子上一个分数（非负整数）。棋盘第 1 格是唯一的起点，第 N 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。 乌龟棋中 M 张爬行卡片，分成 4 种不同的类型（M 张卡片中不一定包含所有 4 种类型的卡片，见样例），每种类型的卡片上分别标有 1,2,3,4 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。 游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。 很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。 现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？ 输入格式 每行中两个数之间用一个空格隔开。 第 1 行 2 个正整数 N,M，分别表示棋盘格子数和爬行卡片数。 第 2 行 N 个非负整数，a1​,a2​,…,aN​，其中 ai​ 表示棋盘第 i 个格子上的分数。 第 3 行 M 个整数，b1​,b2​,…,bM​，表示 M 张爬行卡片上的数字。 输入数据保证到达终点时刚好用光 M 张爬行卡片。 输出格式 1 个整数，表示小明最多能得到的分数。 输入输出样例 输入样例 #1 输出样例 #1 样例解释 #1 思路 多维 DP 经典题。 可以考虑设置 4 个维度，每个维度分别记录 1,2,3,4 号卡片的状态，而当前所在的格就是 ai+2j+3k+4l​。 得转移方程如下： ​fi,j,k,l​=max(fi,j,k,l​,fi−1,j,k,l​)+ai+2j+3k+4l​fi,j,k,l​=max(fi,j,k,l​,fi,j−1,k,l​)+ai+2j+3k+4l​fi,j,k,l​=max(fi,j,k,l​,fi,j,k−1,l​)+ai+2j+3k+4l​fi,j,k,l​=max(fi,j,k,l​,fi,j,k,l−1​)+ai+2j+3k+4l​​(i&gt;0)(j&gt;0)(k&gt;0)(l&gt;0)​ 其中 i∈[0,b1​],j∈[0,b2​],k∈[0,b3​],l∈[0,b4​]。 代码 "},{"title":"洛谷 - P2389 电脑班的裁员","date":"2022-03-23T17:06:06.000Z","url":"/luogu-p2389/","tags":["动态规划","洛谷"],"categories":["题解"],"content":"题目信息卡题目名称电脑班的裁员提交地址洛谷 P2389题目难度提高+/省选- 题面 题目背景 隔壁的新初一电脑班刚考过一场试，又到了 BlingBling 的裁员时间，老师把这项工作交给了 ZZY 来进行。而 ZZY 最近忙着刷题，就把这重要的任务交（tui）给了你。 题目描述 ZZY 有独特的裁员技巧：每个同学都有一个考试得分 ai​，在 n 个同学中选出不大于 k 段相邻的同学留下，裁掉未被选中的同学，使剩下同学的得分和最大。要特别注意的是，这次考试答错要扣分，所以得分有可能为负。 输入格式 第一行为 n,k，第二行为第 1∼n 位同学的得分。 输出格式 一个数 s，为最大得分和。 输入输出样例 输入样例 #1 输出样例 #1 数据范围与约定 对于 100% 的数据，k≤n≤500，∣ai​∣≤103。 思路 动态规划，时间复杂度 O(n3)。 设 fi,j​ 表示前 i 个数取 j 段的最大价值。 若不选 ai​ 则 fi,j​=fi−1,j​； 若选择 ai​ 则需要枚举最后一段的起始位置 l：fi,j​=fl,j−1​+∑p=li​ap​(l∈[j−1,i])。 整理得转移方程： fi,j​=max{fi,j​,fi−1,j​,fl,j−1​+p=l+1∑i​ap​} 代码 "},{"title":"洛谷 - P2045 方格取数加强版","date":"2022-03-22T13:27:06.000Z","url":"/luogu-p2045/","tags":["洛谷","网络流","费用流"],"categories":["题解"],"content":"题目信息卡题目名称方格取数加强版提交地址洛谷 P2045题目难度省选/NOI- 题面 题目描述 给出一个 n×n 的矩阵，每一格有一个非负整数 Ai,j​ 现在从 (1,1) 出发，可以往右或者往下走，最后到达 (n,n)。每到达一格，把该格的数取出并将原位置归 0，这样一共走 k 次，请你求出走 k 次所达到的方格的数的和的最大值。 输入格式 第一行两个数 n,k。 接下来 n 行，每行 n 个数，分别表示矩阵上的每个格子中的数。 输出格式 走 k 次所达到的方格的数的和的最大值。 输入输出样例 输入样例 #1 输出样例 #1 数据范围与约定 对于 100% 的数据，1≤n≤50，0≤k≤10，0≤Ai,j​≤1000。 思路 按照网格建立网络，将每个点拆成入点和出点两个点，入点向出点连两条边：一条 flow=1,cost=−val 表示第一次经过（负数是为了把最大费用最大流转化为最小费用最大流），另一条 flow=inf,cost=0 供后几次经过使用。每个点的出点向右方和下方连 flow=inf,cost=0 的边。之后将从超级源点向 (1,1)、从 (n,n) 向超级汇点分别连两条 flow=k,cost=0 的边，再求出最小费用最大流即可。 最后输出答案时别忘了将负数再转回正数。 代码 "},{"title":"洛谷 - P2774 方格取数问题","date":"2022-03-21T21:31:01.000Z","url":"/luogu-p2774/","tags":["LibreOJ","洛谷","网络流","BZOJ","Hydro","最大流","网络流 24 题"],"categories":["题解"],"content":"题目信息卡题目名称方格取数问题提交地址洛谷 P2774LibreOJ 6007BZOJ 1475 @ Hydro题目难度省选/NOI-题目来源网络流 24 题 题面 题目描述 有一个 m 行 n 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。 输入格式 第一行是两个用空格隔开的整数，分别代表方格图的行数 m 和列数 n。 第 2 到第 (m+1) 行，每行 n 个整数，第 (i+1) 行的第 j 个整数代表方格图第 i 行第 j 列的的方格中的数字 ai,j​。 输出格式 输出一行一个整数，代表和最大是多少。 样例输入输出 样例输入 #1 样例输出 #1 数据规模与约定 对于 100% 的数据，保证 1≤n,m≤100，1≤ai,j​≤105。 思路 可以对整个方格图进行黑白染色，将 (x+y)mod2=1 的点设为黑点，如下图所示： 可以发现，若取一个黑格的点，受到影响的就是周围的白点。然后可以建一个二分图，这道题就可以用最小割求解了。 新建一个超级源点，将所有黑点连到这个超级源点上，容量为点权； 再新建一个超级汇点，将所有白点连接到这个超级汇点上，容量为点权； 最后将每一个黑点连接到会被这个点影响到的白点上，容量为 +∞。 答案为方格图中所有点的点权和再减去最小割。 代码 "},{"title":"P2891 [USACO07OPEN] Dining G","date":"2022-03-19T21:45:11.000Z","url":"/luogu-p2891/","tags":["图论","洛谷","网络流","最大流"],"categories":["题解"],"content":"题目信息卡题目名称Dining G提交地址洛谷 P2891题目难度省选/NOI-题目来源USACO 2007 Open 题面 本文中所给出的题面为原题面的中文翻译，并非原始题面。翻译如有错误之处，请联系指出。 题目描述 奶牛就是这么挑食。每头奶牛都有自己喜欢的食物和饮料，她不会吃她不喜欢的食物和或者喝她不喜欢的饮料。 农夫约翰为他的奶牛做了美味的饭菜，但他忘记根据她们的喜好检查他的菜单。虽然他可能无法让每头奶牛都吃饱，但他想让尽可能多的奶牛吃一顿符合她们喜好的饭。 农夫约翰烹制了 F 种食物并准备了 D 种饮料。他的 N 头奶牛中的每一头都给出了她喜欢吃的食物种类和饮料种类。农夫约翰必须为每头奶牛分配一种食物类型和一种饮料类型，以最大限度地增加同时获得这两种食物的奶牛数量。 每道菜或饮料只能由一头牛食用（即一旦将种类编号为 2 的食物分配给一头牛，就不能再将这种食物分配给其他牛）。 输入格式 第一行包含三个以空格分隔的整数 N,F,D。 接下来有 N 行数据。第 i 行以两个整数 Fi​,Di​ 开头，即奶牛喜欢吃的食物种类的数量和喜欢喝的饮料种类的数量。之后有 Fi​ 个整数给出了第 i 头奶牛喜欢吃的菜的编号，有 Di​ 个整数给出了第 i 头奶牛喜欢喝的饮料种类的编号。 输出格式 一行一个整数，表示可以享受到自己喜欢的食物和饮料的奶牛的最大数量。 输入输出样例 输入样例 #1 输出样例 #1 数据范围与提示 对于 100% 的数据，1≤N,F,D≤100。 思路 本题的难点主要在于建图。 一种很容易想到的做法是建立一个超级源点连接食物，食物连牛，牛连饮料，饮料连接超级汇点，然后再跑一遍最大流。但这个算法是错误的，它可能会重复选择同一只奶牛。 Hack 数据 输入数据 错误答案 正确答案 那么可以运用拆点的思想，将一只奶牛拆成两个点，食物连入点，出点连饮料，就避免了重复选择的问题。 之后再跑网络流求出答案即可。 代码 "},{"title":"最大流学习笔记","date":"2022-03-13T21:11:26.000Z","url":"/max-flow/","tags":["图论","网络流","最大流"],"categories":["笔记"],"content":"最大流问题是求解图上从源点流向汇点的最大流量的问题。 求解最大流问题主要有两种算法：Edmonds-Karp 动能算法（EK 算法）和 Dinic 算法，其中后者在算法竞赛中更为常用。 基本概念 流网络 流网络 G=(V,E)（Flow Network） 是一个有向图，图中每条边 (u,v)∈E 有一个非负的 容量值 c(u,v)≥0。而且，如果边集合 E 包含一条边 (u,v)，则图中不存在反方向的边 (v,u)。为了方便起见，如果 (u,v)∈/E，则定义 c(u,v)=0。 在流网络的所有节点中，有两个特殊的点：源点 s 和汇点 t (s=t)。 流 设 f(u,v) 定义在二元组 (u∈V,v∈V) 上的实数函数且满足 容量限制（Capacity Constraints）：对于每条边，流经该边的流量不得超过该边的容量，即 ∀u,v∈V,f(u,v)≤c(u,v)； 流量守恒（Flow Conservation）：从源点流出的流量等于汇点流入的流量，即 ∀x∈V−{s,t},∑(u,x)∈E​f(u,x)=∑(x,v)∈E​f(x,v)； 那么 f 称为网络 G 的流函数。 对于 (u,v)∈E，f(u,v) 称为边的 流量，c(u,v)−f(u,v) 称为边的 剩余容量（Residual Capacity），可以记作 cf​(u,v)。整个网络的流量为 ∑(s,v)∈E​f(s,v)，即从源点发出的所有流量之和。为了方便起见，如果 (u,v)∈/E，则定义 f(u,v)=0。 一般而言也可以把网络流理解为整个图的流量。而这个流量必满足上述两个性质。 流函数的完整定义如下： f(u,v)=⎩⎨⎧​​f(u,v),−f(v,u),0,​(u,v)∈E(v,u)∈E(u,v)∈/E,(v,u)∈/E​ 残量网络 对于流函数 f，残量网络 Gf​（Residual Network）是网络 G 中所有节点和剩余容量大于 0 的边构成的子图，即 Gf​=(Vf​=V,Ef​={(u,v)∈E,cf​(u,v)&gt;0}) 注意，剩余容量大于 0 的边可能不在原图 G 中（根据容量、剩余容量的定义以及流函数的斜对称性得到）。可以理解为，残量网络中包括了那些还剩了流量空间的边构成的图，也包括虚边（即反向边）。 增广路 在原图 G 中若存在一条从源点到汇点的路径上所有边的剩余容量都大于 0，则这条路径被称为增广路（Augmenting Path）。 Edmonds-Karp 算法 Edmonds-Karp 算法的基本思路很简单：不断地使用 BFS 去寻找增广路，直到网络上不存在增广路为止。 在每轮寻找增广路的过程中，Edmonds-Karp 算法只考虑所有 cf​(u,v)≥0 的边，用 BFS 找到任意一条从 s 到 t 的路径，同时计算出路径上各边的剩余容量的最小值 minf，则网络的流量就可以增加 minf。 需要注意的是，当一条边的流量 f(u,v)&gt;0 时，根据斜对称性质，它的反向边流量 f(v,u)&lt;0，此时必定有 f(v,u)&lt;c(v,u)。故 Edmonds-Karp 算法在 BFS 时除了原图的边集 E 外，还应该考虑遍历 E 中每条边的反向边。 在实现时，只需要维护残量网络即可。当一条边 (u,v) 流过大小为 e 的流时，令 (u,v) 的剩余容量减小 (e)，(v,u) 的剩余流量增大 e 即可。 Edmonds-Karp 算法的时间复杂度为 O(VE2)。然而在实际运用中远远达不到这个上界，效率较高，可以处理 103∼104 规模的网络。 来自 GitHub Copilot 的补全（未验证）：然而在实际应用中，这个算法的时间复杂度可以降低到 O(VE)，因为在每轮 BFS 时，只需要更新 E 中的边的剩余容量，而不需要更新 V 中的节点。 代码 Dinic 算法 Edmonds-Karp 算法每轮可能会遍历整个残量网络，但只找出一条增广路，还有进一步优化的空间。 Dinic 算法不断重复以下步骤，直到在残量网络中 s 不能到达 t： 在残量网络上 BFS 求出节点的层次，构造分层图。 在分层图上 DFS 求出增广路，在回溯时实时更新剩余容量。另外，每个点可以流向多条出边，同时还加入了若干剪枝（参考程序注释）。 Dinic 算法的时间复杂度为 O(V2E)。但在实际中远远达不到这个上界，一般能够处理 104∼105 规模的网络，特别地，在求解稠密图上的最大流问题是效率要比前文提到的 Edmonds-Karp 算法更高。 Dinic 算法中的两个优化： 多路增广：每找到一条增广路时，若还有残余流量存在，那么可以再找出其他的增广路来利用这些残余流量。这样就可以在一次 DFS 中找出多条增广路，大大提高了算法的效率。 当前弧优化：如果一条边已经被增广过，那么该边就没有可能被增广第二次。那么，当下一次进行增广的时候，就可以不必再走那些已经被增广过的边。 代码 参考资料 0x6A 网络流初步，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 第 26 章 最大流，《算法导论》中译本（ISBN 978-7-111-40701-0，机械工业出版社），2013 年 1 月第三版。 1.1.1 网络流的基本概念，AcWing 算法进阶课，闫学灿，2020 年 7 月 25 日。 1.1.2 最大流，AcWing 算法进阶课，闫学灿，2020 年 7 月 31 日 ~ 2020 年 8 月 8 日。 网络流简介，图论，OI Wiki，2021 年 7 月 11 日。 "},{"title":"学考自救指北 —— SQL 篇","date":"2022-03-11T20:35:28.000Z","url":"/xuekao-sql/","tags":["学考","SQL"],"categories":["杂项"],"content":"SQL（Structured Query Language，结构化查询语言）是一种具有数据操纵和数据定义等多种功能的数据库语言。 基本概念 这些可以不用会，但最好了解一下。 数据库（database）：保存有组织的数据的容器（通常是一个文件或一组文件）。 数据表（table）：某种特定类型数据的结构化清单。 模式（schema）：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。 列（column）：表中的一个字段。所有表都是由一个或多个列组成的。 行（row）：表中的一个记录。 主键（primary key）：一列（或一组列），其值能够唯一标识表中每一行。 SQL 语法 SQL 语句不区分大小写（数据库表名、列名和值是否区分大小写，依赖于具体的 DBMS 以及配置）。 例如：SELECT 与 select、Select 是相同的。 多条 SQL 语句必须以半角分号（;）分隔，部分数据库系统要求在每条 SQL 语句后都添加分号。 处理 SQL 语句时，所有空格都被忽略。SQL 语句可以写成一行，也可以分写为多行。 SQL 中的注释有两种形式： 单行注释：-- 后面跟着任意字符串，包括空格。 多行注释：以 /* 开始，*/ 结束。 部分引擎还支持以 # 号开头的注释，在此不做过多叙述。 基本操作 创建表 下方的 SQL 语句创建了一个名为 students 的数据表，表中包含了学生的编号、姓名、出生日期、班级，其中编号每次插入新行都会自动加一、班级（class）默认为「高一年级 A16 班」，并将学生编号设置为了数据表的主键（PRIMARY KEY (`id`) 子句），还设置了这些字段不能为空值（NOT NULL）。 常用数据类型 数据类型 说明 INTEGER (简写 int) 整数型 NUMERIC(全长, 小数位数) 数值型 CHAR 定长字符串 VARCHAR 可变长字符串 DATE 日期型 示例：NUMERIC(7, 2) 表示数值型，有 5 位整数，2 位小数，全长 7 位。 关于主键 主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。 删除表 下方的 SQL 语句删除了一个名为 students 的数据表。 更新表定义 更新表定义可以使用 ALTER 子句。 增加列 下方的语句可以为 students 数据表在 class 列后再增加一个新的列，新列的名称为 address，数据类型为 varchar(100)。 如果不写 AFTER 子句，则新列会被添加到数据表的最后面。也可以使用 FIRST 替代这个子句，这样新列会被添加到数据表的开头。 删除列 下方的语句可以删除 students 表中名为 address 的列。 更改表名 下方的语句可以将名为 students 的表更名为 student。 数据增加 基本格式： 这个语句的意思是向名为 students 的表中插入一行，其中 name 列的值为 张三，birthdate 列的值为 1926-08-17，class 列的值为 高一年级A16班，其他列均为默认值。 数据检索 基本格式： 这个语句的意思是从名为 students 的表中查询 name 列（字段）的值，即获取所有学生的名字。 字段名可以使用通配符代替，这样可以获取所有字段的值，例如： 数据删除 可以使用 DELETE 语句来删除数据。 这个语句可以删除编号为 1 的学生。 数据更新 可以使用 UPDATE 语句来更新数据。 这个语句可以将编号为 1 的学生的姓名改为 李四。 当然，将名字为「张三」的学生改名为「李四」也不是不可以： 数据过滤 SQL 中的数据过滤可以使用 WHERE 子句和一些辅助函数来完成。 单条件筛选 下方的语句可以从 students 表中选择出所有名为「张三」的学生（即 name 的值为 张三 的所有行）并输出该行的所有信息。 多条件筛选 下方的语句可以从 students 表中选择出「高一年级 A16 班」中所有名为「张三」的学生（即 name 字段的值为 张三 且 class 字段的值为 高一年级A16班），并输出这些学生的生日。 如果只需要满足这两个条件之中的某一个可以使用 OR 代替 AND。 下方的语句可以从 exams 表中选择出「2021 - 2022 学年第一学期期中考试」中总成绩大于 300 分的所有学生。 IN 操作符 下方的语句可以从 students 表中选择出所有在「高一年级 A15 班」和「高一年级 A16 班」的学生。 也可以这样写，不过不太简洁： NOT 操作符 下方的语句可以从 students 表中选择出所有 不在「高一年级 A15 班」和「高一年级 A16 班」的学生。 通配符匹配 使用 LIKE 子句可以实现通配符匹配，例如： 这个语句可以选择出所有名字以 张 开头的学生。 而使用 _ 可以匹配任意一个字符，例如： 这个语句可以选择出所有名字有三个字的，且名字以 马 开头、以 国 结尾的学生。 数据处理 排序 排序可以使用 ORDER BY 子句来完成，例如： 这个语句可以选择出所有名为 2021-2022学年第一学期期中考试 的考试，并按照 score 字段进行排序。 如果需要降序排序，那么为 ORDER BY 子句添加 DESC 即可： LIMIT 子句 可以使用这个子句来限制输出数量，比如下面这个语句就可以输出考试中成绩前十名的学生： 内建函数 SQL 中常用的内建函数有 5 个，分别是 count sum avg max min。 COUNT 函数 下面的语句返回指定列的值的数目（未去重）： 如果需要对数据进行去重，可以使用 DISTINCT 子句： 也可以统计表中数据的行数，使用 COUNT(*) 子句： SUM 函数 下面的语句可以返回指定列中的所有值的总和： 这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试中所有同学们获得的总分之和。 AVG 函数 下面的语句可以返回指定列中的所有值的平均值： 这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试的平均分。 MIN 函数 下面的语句可以返回指定列中的所有值的最小值： 这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试中的最低分。 MAX 函数 这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试中的最高分。 参考资料 SQL 教程，菜鸟教程。 Transact-SQL 参考，Microsoft SQL Server 中文文档。 MySQL 8.0 Reference Manual，Oracle Docs。 本文是在 GitHub Copilot 的辅助之下编写的，版权共有。如有错误请及时指正。 "},{"title":"洛谷 - P1486 [NOI2004] 郁闷的出纳员","date":"2022-03-07T20:16:40.000Z","url":"/luogu-p1486/","tags":["数据结构","STL","Treap","洛谷"],"categories":["题解"],"content":"题目信息卡题目名称郁闷的出纳员提交地址洛谷 P1486LibreOJ 10145题目难度省选/NOI-题目来源NOI2004 题面 题目描述 OIER 公司是一家大型专业化软件公司，有着数以万计的员工。作为一名出纳员，我的任务之一便是统计每位员工的工资。这本来是一份不错的工作，但是令人郁闷的是，我们的老板反复无常，经常调整员工的工资。如果他心情好，就可能把每位员工的工资加上一个相同的量。反之，如果心情不好，就可能把当前在公司的所有员工的工资扣除一个相同的量。我真不知道除了调工资他还做什么其它事情。 工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。 老板经常到我这边来询问工资情况，他并不问具体某位员工的工资情况，而是问现在工资第 k 多的员工拿多少工资。每当这时，我就不得不对数万个员工进行一次漫长的排序，然后告诉他答案。 好了，现在你已经对我的工作了解不少了。正如你猜的那样，我想请你编一个工资统计程序。怎么样，不是很困难吧？ 如果某个员工的初始工资低于最低工资标准，那么将不计入最后的答案内。 输入格式 第一行有两个整数 n 和 min。n 表示下面有多少条命令，min 表示工资下界。 接下来的 n 行，每行一个字符 x 和一个整数 k，表示一条命令。命令可以是以下四种之一： I k 新建一个工资档案，初始工资为 k。如果某员工的初始工资低于工资下界，他将立刻离开公司。 A k 把每位员工的工资加上 k。 S k 把每位员工的工资扣除 k。 F k 查询第 k 多的工资。 在初始时，可以认为公司里一个员工也没有。 输出格式 对于每条 F 命令，你的程序要输出一行，仅包含一个整数，为当前工资第 k 多的员工所拿的工资数，如果 k 大于目前员工的数目，则输出 −1。 输出的最后一行包含一个整数，为离开公司的员工的总数。 请注意，初始工资低于工资下界的员工不算做离开公司的员工。 数据规模与约定 对于 100% 的数据，保证： I 命令的条数不超过 105； A 和 S 命令的总条数不超过 100； F 命令的条数不超过 105； 每次工资调整的调整量不超过 103； 新员工的工资不超过 105。 0≤n≤3×105，0≤min≤109，输入的所有数字均在 32 位带符号整形范围内。 思路 可以使用一个全局变量 Δ 来记录工资的变化。 每次添加员工的时候，若 k&lt;min 则不添加，否则添加 k−Δ 即可。 每次调整的时候只需要在调整后删除掉工资小于 min−Δ 的员工即可。 STLFHQ Treap可以使用 std::vector 来存储员工工资数据。 在插入的时候使用 std::lower_bound 来查找插入位置，确保容器内部元素有序。 在降工资时删除所有小于等于 min−Δ 的员工的数据，并记录删除人数。FHQ Treap 板子活用一下就行了。 在降工资时将整颗 Treap 分裂为两个子树，左子树是工资小于 min−Δ 的员工，记录元素数量并删除该子树即可。 此处求第 k 大可以直接转化成求第 n−k+1 小的元素。 代码 STLFHQ Treap "},{"title":"洛谷 - P3391 【模板】文艺平衡树","date":"2022-03-02T20:55:32.000Z","url":"/luogu-p3391/","tags":["平衡树","Treap","LibreOJ","洛谷","AcWing","S2OJ"],"categories":["题解"],"content":"题目信息卡题目名称文艺平衡树提交地址LibreOJ 105洛谷 P3391AcWing 2437S2OJ 100题目难度提高+/省选-题目来源模板题 题面 题目描述 您需要写一种数据结构（可参考题目标题），来维护一个有序数列。 其中需要提供以下操作：翻转一个区间，例如原有序序列是 5&nbsp;4&nbsp;3&nbsp;2&nbsp;1，翻转区间是 [2,4] 的话，结果是 5&nbsp;2&nbsp;3&nbsp;4&nbsp;1。 输入格式 第一行两个正整数 n,m，表示序列长度与操作个数。序列中第 i 项初始为 i。 接下来 m 行，每行两个正整数 l,r，表示翻转的区间。 输出格式 输出一行 n 个正整数，表示原始序列经过 m 次变换后的结果。 输入输出样例 样例输入 #1 样例输出 #1 数据范围与约定 对于 100% 的数据，1≤n,m≤100000，1≤l≤r≤n。 思路 前置知识：无旋 Treap 学习笔记。 当翻转 [l,r] 区间时，先分裂出 [1,r] 和 [r+1,size] 两个区间，再从 [1,r] 中分裂出 [1,l−1] 和 [l,r] 两个区间。将 [l,r] 区间打标记后再合并即可。 最后按照中序遍历输出即为答案。 代码 "},{"title":"无旋 Treap 学习笔记","date":"2022-02-18T15:27:40.000Z","url":"/fhq-treap/","tags":["数据结构","平衡树","Treap"],"categories":["笔记"],"content":"无旋 Treap，又名 FHQ-Treap。无旋 Treap 仅有两种核心操作 —— 分裂与合并，它依靠这两种操作来维护树的平衡，从而省去了旋转操作。这种操作方式使得它天生支持维护序列、可持久化等特性。 本文提供使用原生指针和数组模拟指针两种方法实现的代码，可以点击代码块上方的切换按钮查看两种不同版本的代码。 前言 Treap 是一种弱平衡的二叉搜索树。它的数据结构由二叉树和二叉堆组合形成，名字也因此为 tree 和 heap 的组合。 Treap 的每个结点上除了按照二叉搜索树排序的 key 值外要额外储存一个叫 priority 的值。它由每个结点建立时随机生成，并按照最大堆性质排序。因此 Treap 除了要满足二叉搜索树的性质之外，还需满足父节点的 priority 大于等于两个子节点的值。所以它是期望平衡的。搜索，插入和删除操作的期望时间复杂度为 O(logn)。 主要操作 分裂 本节所介绍的分裂操作会按照排名将一棵树分裂为两棵子树，左子树包含 k 个元素，右子树包含剩余元素。 分割时，如果左子树中元素个数不足 k 个，就从右子树中分割 k−size(left)−1 个元素放置到左子树中，反之则从左子树中划分出 size(left)−k 个元素放置到右子树中。 不要忘记 pushup。 指针数组 按值分裂 本节介绍的分裂操作将会按照元素值的大小将一棵树分裂为两棵子树，左子树中的元素均不大于 val，右子树中的元素均大于 val。 指针数组 合并 合并操作也就是将两棵 Treap 合并成一棵 Treap，其中一颗 Treap 的所有点的权值均小于或大于另一颗 Treap 任意点的权值。 指针数组 内部工具库 获取子树大小 判断子树是否为空，若空返回 0，非空返回子树大小。 查找元素 (find) 递归查找值为 val 的元素，根据 BST 的性质即可进行。 递归到某个节点时，先判断当前节点的元素值大小，若查询值小于当前节点的元素值时则向左子树递归，反之则向右子树递归。时间复杂度为 O(logn)。 指针数组 封装函数 插入 先将整个 Treap 按照给定的值分割成两个子树，再在这两个子树的中间插入新值即可。 指针数组 删除 本删除操作在遇到多个相同的数时只会删除一个。具体操作与插入类似，不再过多叙述。 指针数组 排名 将整棵树按值分裂，左子树的大小再加 1 即为该数的排名。 指针数组 第 k 大元素 将整棵树分裂为由前 k−1 个元素和其余节点组成的两棵子树，则右子树的第一个元素即为所求。 指针数组 代码 需要的外部函数：rand（定义于头文件 &lt;cstdlib&gt;）。 指针版和数组版的 Treap 类暴露出的接口是一样的。 指针数组 技巧 求数 x 的前驱 求数 x 的后继 参考资料 谈谈各种数据结构（文件存档备份），范浩强，WC2012。 Treap，OI Wiki，2022 年 2 月 7 日。 某科学的无旋 Treap（FHQ-Treap），星夜，2021 年 1 月 25 日。 "},{"title":"S2OJ - 1256. 牧场","date":"2022-02-13T11:24:09.000Z","url":"/s2oj-1256/","tags":["线段树","S2OJ","扫描线"],"categories":["题解"],"content":"题目信息卡题目名称牧场提交地址S2OJ 1256题目来源常中 2018.09.15 题面 题目描述 小 L 准备建一个牧场在里面放羊。他指定了一些他想围住的矩形草坪。他想知道把这些草坪围起来需要多长的栏杆。 例如，选取图一的草坪，栏杆将围成图二的样子。 ▲ 图 1 ▲ 图 2 输入格式 输入文件的第一行是一个整数 n，表示有多少个矩形。 接下来 n 行给出了每一个矩形左下角坐标 sx​,sy​ 和右上角坐标 tx​,ty​。 输出格式 一个正整数，表示所有矩形的周长 输入输出样例 样例输入 #1 样例输出 #1 数据范围与约定 数据点 n 特殊性质 时间限制 1 =1 无 1s 2 =2 3 ≤10 4 ≤100 0≤所有坐标≤1000 5 ≤2000 6 无 7 ≤5000 8 ≤50000 0≤所有坐标≤1000 1.5s 9 无 10 ≤200000 对于 100% 的数据，满足 1≤n≤2×105,&nbsp;−105≤sx​,sy​,tx​,ty​≤105。 思路 很容易想到可以在横向和纵向上各使用一次扫描线来计算周长。 可以发现增加一条边后会引起总和改变，总和的改变量就是新增的边长，而没改变的部分则是被已存在图形覆盖掉的，无需统计。 最后将横向上的边长和与纵向上的边长和相加即为图形总周长。 代码 "},{"title":"S2OJ - 1238. Simple","date":"2022-02-11T01:00:23.000Z","url":"/s2oj-1238/","tags":["数学","S2OJ"],"categories":["题解"],"content":"题目信息卡题目名称Simple提交地址S2OJ 1238题目来源常中 2018.12.05 题面 题目描述 对于给定正整数 n,m，我们称正整数 c 为好的，当且仅当存在非负整数 x,y，使得 nx+my=c。 现在给出 T 组数据，对于每组数据，给定 n,m,q，求 [1,q] 内有多少个正整数不是好的。 输入格式 第一行，一个整数 T 表示数据组数。 接下来每行三个数，分别表示 n,m,q，即一组询问。 输出格式 对于每组数据，输出一行表示答案。 输入输出样例 输入样例 #1 输出样例 #1 数据范围及约定 对于 30% 的数据，n,m,q≤100； 对于 60% 的数据，n,m,q≤105； 对于 100% 的数据，n≤105,m≤109,q≤1018,T≤10。 思路 先考虑将 nx+my=c 中的 x,y 单独提出来，得到下面两个式子： x=nc−my​(1) y=mc−nx​(2) 可以考虑枚举 x,y 之中的任意一个数，根据 (1) 式或 (2) 式计算出对应 y,x 的值。 通过数据范围可以发现，当使用 (2) 式计算时会超时。 再通过暴力打表（程序见文末）可以发现一个规律：c 在到达 lcm(n,m) 时会重复，那么只需枚举 y 到 min(lcm(n,m),q)/m 即可。 最后输出时需要去掉 x=0,y=0 的情况，将 ans−1 即可。 代码 AC 代码 暴力（60 分） "},{"title":"S2OJ - 1230. 小奇的数列","date":"2022-01-21T09:05:39.000Z","url":"/s2oj-1230/","tags":["数学","S2OJ"],"categories":["题解"],"content":"题目信息卡题目名称小奇的数列提交地址S2OJ 1230题目来源常中 2018.09.03 题面 题目描述 小奇总是在数学课上思考奇怪的问题。 给定一个长度为 n 的数列，以及 m 次询问，每次给出三个数 l，r 和 p，询问 (al′​+al′+1​+⋯+ar′​)(modp) 的最小值（其中 l≤l′≤r′≤r）。 即模意义下的区间子串和最小值。 输入格式 第一行包含两个正整数 n 和 m，表示数列的长度和询问的个数。 第二行包含 n 个整数 a1​,…,an​。 接下来 m 行，每行三个数 l，r 和 p，代表一次询问。 输出格式 对于每次询问，输出一行一个整数表示要求的结果。 输入输出样例 输入样例 #1 输出样例 #1 数据范围及约定 对于 20% 的数据，n≤100,m≤100,p≤200； 对于 40% 的数据，n≤200,m≤1000,p≤500； 对于 70% 的数据，n≤100000,m≤10000,p≤200； 对于 100% 的数据，n≤500000,m≤10000,p≤500,1≤ai​≤109。 思路 20 分 对于每个询问，在区间内暴力枚举子串求和、取模即可。复杂度为 O(mn3)。 40 分 考虑在 20 分做法的基础上优化。不难发现，区间求和可以使用前缀和优化。复杂度为 O(mn2)。 70 分 通过 抽屉原理 可知，当询问的区间长度大于等于 p 时（即 r−l≥p 时），一定有两个前缀和相减等于 0，此时直接输出 0 即可。 再考虑枚举 r，可知当 k 是 sumr​ 的前驱时 sumr​−k 最小。时间复杂度为 O(mp2)。 100 分 使用 std::set 维护前驱即可。时间复杂度为 O(mplogp)。 代码 40 分 70 分 OJ 上的数据比较水，所以这样也能 A 掉。 提交记录：0616685 100 分 提交记录：d5b8f54 "},{"title":"LibreOJ - 2759. 「JOI 2014 Final」飞天鼠","date":"2022-01-16T19:57:47.000Z","url":"/libreoj-2759/","tags":["图论","最短路","Dijkstra"],"categories":["题解"],"content":"题目信息卡题目名称飞天鼠提交地址LibreOJ 2759S2OJ 1266题目难度提高+/省选-题目来源JOI 2014 Final 本题有多个提交渠道： LibreOJ #2759 (ff4a803) S2OJ #1266 (5ddfd92) 题面 题目描述 译自 JOI 2014 Final T4「フクロモモンガ」 飞天鼠 JOI 君住着的森林里长着编号为 1 到 N 的 N 棵桉树。第 i 棵树的高度是 Hi​ 米。 JOI 君能在其中的 M 对桉树之间直接飞行，在各对树木之间飞行所需的时间是固定的。当 JOI 君在树木之间飞行的时候，他离地面的高度会每秒下降 1 米。也就是说，如果 JOI 君现在离地高度是 h 米，在树木之间飞行需要 t 秒，那么飞行之后的离地高度就会变成 h−t 米。当 h−t 小于 0 或大于目标树木的高度时则不能飞行。 JOI 君还能沿着树的侧面上下移动，使得他的离地高度在 0 到当前所在树木高度的范围内变化。JOI 君每使自己的离地高度增加或减少 1 米都需要 1 秒的时间。 JOI 君要从 1 号树木上高度为 X 米的位置出发，到树木 N 的顶端（高度为 HN​ 米的位置）去。他想知道为了达成这个目标所需时间的最小值。 给出各棵树木的高度、JOI 君能直接飞行的树木对和 JOI 君最初所在位置的高度，请求出到达树木 N 顶端所需时间的最小值。 输入格式 第一行包含三个以空格分开的整数 N,M 和 X，意义分别与题目描述中的 N,M 和 X 相同。 接下来 N 行中，第 i(1≤i≤N) 行有一个整数 Hi​，表示树木i的高度是 Hi​ 米。 接下来 M 行中，第 j(1≤j≤M) 行有三个以空格分开的整数 Aj​,Bj​,Tj​ (1≤Aj​,Bj​≤N, Aj​=Bj​)，表示 IOI 君能花 Tj​ 秒的时间从 Aj​ 飞到 Bj​ 或从 Bj​ 飞到 Aj​。 对于任意 1≤j&lt;k≤M，满足 (Aj​,Bj​)=(Ak​,Bk​) 且 (Aj​,Bj​)=(Bk​,Ak​)。 输出格式 输出到标准输出，仅一行一个整数，表示从树木 1 上高度为 X 米处移动到树木 N 顶端所需时间的最小值（单位：秒）。如果不能到达目的地则输出 −1。 输入输出样例 样例输入 #1 样例输出 #1 样例解释 #1 下列是其中一种最优解： 沿着树木 1 向上爬 50 米。 从树木 1 飞到树木 2。 从树木 2 飞到树木 4。 从树木 4 飞到树木 5。 沿着树木 5 向上爬 10 米。 样例输入 #2 样例输出 #2 样例输出 #2 JOI 君无法从树木 1 飞到树木 2。 样例输入 #3 样例输出 #3 数据范围与约定 本题采用 Subtask 方式评测。 子任务编号 分值 数据范围 特殊性质 1 25 分 N≤1000M≤3000Hi​≤100Tj​≤100 无 2 25 分 2≤N≤1000001≤M≤3000001≤Hi​≤1091≤Tj​≤109 X=0 3 50 分 2≤N≤1000001≤M≤3000001≤Hi​≤1091≤Tj​≤109 无 表格中的 Hi​,Tj​ 满足：1≤i≤N,1≤j≤M。 所有数据满足 0≤X≤H1​。 思路 可以使用最短路算法解决本题。 对于每条边，会有以下几种情况： 到达点的高度大于树顶高度。 需要先向下爬到高度为 hv​+w 的点才能从该边飞过，可以证明这是最优选择。 在飞行途中落地。 这种情况又细分为两种情况： 从树顶开始飞行时，无法到达终点。 此种情况在加边时即可判定并丢弃这条边。 从树上某点开始飞行时，无法到达终点。 处理完上一种情况以后，树上一定存在一个高度，使得从该高度开始正好可以飞到下一个点的 0 米高处。 容易证明，先下降到高度为 w 的点再飞过该边是最优选择。 能正常飞到终点。 正常计算即可。 本题答案大小可能会超出 int 上界，因此需要使用 long long 存储。 代码 "},{"title":"有向图的强连通分量","date":"2021-12-31T14:49:28.000Z","url":"/scc/","tags":["图论","强连通分量","Tarjan"],"categories":["笔记"],"content":"定义 强连通的定义是：对于一个有向图 G 中任意一对节点 u 和 v 可以互相到达。 强连通分量的定义是：极大强连通子图。 在上面的定义中，我们称一个强连通子图 G′=(V′,E′)「极大」（其中 V′∈V,E′∈E），是指不存在包含 G′ 的更大的子图 G′′=(V′′,E′′)，满足 V′⊆V′′⊆V,E′⊆E′′⊆E，并且 G′′ 也是强连通子图。 DFS 生成树 在介绍 Tarjan 算法之前，需要先了解一下 DFS 生成树。 给定一个有向图 G=(V,E)，若存在 r∈V，满足从 r 出发能够到达 V 中的所有点，则称 G 是一个流图（Flow Graph），记为 (G,r)，其中 r 称为流图 G 的源点。 在一个流图 (G,r) 上从 r 出发进行深度优先遍历，每个点只访问一次。所有发生递归的边 x→y 构成一棵以 r 为根的树，我们称它为流图 (G,r) 的 DFS 生成树。 有向图的 DFS 生成树有四种边，以下面这个有向图为例： 树枝边：示意图中以黑色边表示（如 2→3），它是在搜索时访问到了一个还没有访问过的节点时形成的。 前向边：示意图中以绿色边表示（如 3→6），它是在搜索时遇到子树中的节点的时候形成的。 后向边：示意图中以红色边表示（如 7→1），它是在搜索时遇到祖先节点时形成的。 横叉边：示意图中以蓝色边表示（如 9→7），它是在搜索时遇到了一个已经访问过的且不是当前节点的祖先的结点时形成的。 不同书籍介绍的这四种边的名称可能不同，但定义内容基本上是一样的。 此外，在 DFS 过程中，按照每个节点第一次被访问的时间顺序，依次给流图中 n 个节点 1&nbsp;n 的整数标记，该标记被称为 DFS 序（也被称为时间戳），记作 dfn。上图中节点的圆圈内的数字便是该节点的 DFS 序。 Tarjan 算法 Tarjan 发明了许多算法。本文中的「Tarjan 算法」指的是由 Tarjan 发明的在有向图中强连通分量的算法。 提示：请勿混淆 边 与 路径 的概念。 实现 一个环一定是强连通图。如果图中既存在从 x 到 y 的路径（不仅仅是边），又存在从 y 到 x 的边，那么 x,y 显然在一个环中。因此，Tarjan 算法的基本思路就是对于每个点，尽量找到与它一起能够构成环的所有节点。 容易发现，从 x 到 y 的前向边并没有什么用处，因为 DFS 生成树上本来就存在从 x 到 y 的路径。从 x 到 y 的后向边非常有用，因为它可以和 DFS 生成树上从 y 到 x 的路径一起构成环。从 x 到 y 的横向边需要视情况而定，如果从 y 出发能找到一条路径回到 x 的祖先节点，那么这条边也是有用的，可以成为环的一部分。 为了找到通过后向边和横叉边构成的环，Tarjan 算法需要在 DFS 的同时维护一个栈。当访问到节点 x 时，栈中需要保存以下两类节点： DFS 生成树上 x 的祖先节点，记为集合 A(x)。 设 y∈A(x)，若存在后向边 x→y，则 x→y 与从 y 到 x 的路径一起形成环。 已经访问过，并且存在一条路径能够到达 A(x) 中的节点。 设节点 z 符合该要求，从 z 出发存在一条路径能到达 y∈A(x)，若存在横叉边 x→z，则这条边和从 z 到 y 的路径还有从 y 到 x 的路径可以共同形成一个环。 综上所述，栈中的节点就是能与从 x 出发的后向边和横叉边形成环的节点。 追溯值 设 S(x) 表示流图的 DFS 生成树中以 x 为根的子树。x 的追溯值 lowx​ 定义为满足以下条件的节点的最小时间戳。 该点在栈中。 存在一条从 S(x) 中出发的有向边以该点为终点。 根据定义，Tarjan 算法按照以下步骤计算追溯值： 当节点 x 第一次被访问时，将 x 入栈，初始化 lowx​=dfnx​。 扫描从 x 出发的每一条边 x→y。 若 y 从未被访问过，则说明 x→y 是树枝边，递归访问 y，从 y 回溯后，令 lowx​=min(lowx​,lowy​)。 若 y 被访问过且 y 在栈中，则令 lowx​=min(lowx​,dfny​)。 在 x 回溯之前，判断是否有 lowx​=dfnx​ 成立。若成立，则不断从栈中弹出节点，直至 x 出栈。 判定强连通分量 在追溯值的计算过程中，若从 x 回溯前有 lowx​=dfnx​ 成立，则栈中从 x 到栈顶的所有节点均在同一个强连通分量中。 此处不作证明，有兴趣的读者可以自行查找相关论文与书籍。 实现 说明请见代码注释。 例题及代码 对应题目：洛谷 - P3387 【模板】缩点 参考资料 22.5 强连通分量，《算法导论》中译本（ISBN 978-7-111-40701-0，机械工业出版社），2013 年 1 月第三版。 0x67 Tarjan 算法与有向图连接性，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 连通：有向图，图论：相关概念，OI Wiki，2021 年 8 月 23 日。 强连通分量，图论，OI Wiki，2021 年 11 月 8 日。 3.7 有向图的强连通分量，AcWing 算法提高课，闫学灿，2019 年 11 月 30 日。 本文图片由 OI Wiki 提供，在此对图片作者表示感谢。 "},{"title":"S2OJ - 1199. 90 岁的张哥哥","date":"2021-12-27T20:34:16.000Z","url":"/s2oj-1199/","tags":["模拟","线段树","S2OJ","栈"],"categories":["题解"],"content":"本题是 洛谷 - P1750 出栈序列 的加强版。 题目信息卡题目名称90 岁的张哥哥提交地址S2OJ 1199 题面 题目背景 90 岁的张哥哥躺在床上，奄奄一息，No enemy 和小叶子在两旁伺候。 ck 赶来：「lzl 块状链表调不出来，你去帮他 debug 吧。」 张哥哥：「老了，让这蒟蒻自己去调。」 风雪山神猫的林教头的林妹妹赶来（好像有什么不和谐的东西乱入了）：「后宫『着火了』又！」 张哥哥：「老了，没力气了，我相信你能搞定的。」 这时，张哥哥的手机铃声「星空使者」响起，电话那头是镕昊和克凡：「我们在 ACM 的现场，发现栈不会写……」话音未落，张哥哥腾得一声跳了起来，容光焕发：「什么？！栈都不会写，放着我来！」 这件事情告诉我们，栈，是张哥哥生前最喜欢的数据结构（与事实不符别怪我）。 题目描述 我们知道，给定一个由 N 个元素构成的序列，将其中的元素按顺序压入一个大小为 C 的栈并弹出。元素按它们的出栈顺序进行排列，会得到一个新的序列。这样的序列可能会有很多种，请输出所有新序列中第一个元素最小的序列（若第一个元素最小的序列有多个，则令第二个尽可能小；若仍有多个，则令第三个最小，以此类推）。 输入格式 第一行两个正整数 N,C。 第二行 N 个整数，表示将顺序入栈的元素的值。 输出格式 仅一行，即满足要求的序列。 输入输出样例 样例输入 #1 样例输出 #1 样例说明 #1 因为栈的大小为 2，所以 2 3 5 尽管是最小的序列，但是是不合法的。正确的做法是先将 5、3 压入栈中，弹出 3，压入 2，弹出 2，弹出 5 数据规模与约定 对于 40% 的数据，n≤12； 对于 70% 的数据，n≤10000； 对于 100% 的数据，c≤n≤300000，元素大小均在 2×109 以内。 思路 70 分 考虑贪心。 设定两个指针 l,r，初始值为 1 和 C。 循环 n 次，每次找出 [l,r] 区间中未被标记的最小的数并输出、标记，然后将 l 跳到前一个未被标记的数，r 增加 1。 可以证明这个贪心是正确的。 100 分 使用线段树维护区间最小值可以将区间最值的查询从 O(n) 降至 O(logn)。 使用栈模拟实际操作可以省去标记已入栈的数，需要遵循以下几点注意事项： 入栈时需要将当前区间内的最小值前的所有未入栈元素入栈。 确保栈内元素数量不超过栈容量。 弹出栈顶元素后从栈顶元素的后一个元素开始执行上述过程。 代码 70 分代码 100 分代码 "},{"title":"可持久化线段树学习笔记","date":"2021-12-24T21:03:09.000Z","url":"/persistent-segment-tree/","tags":["数据结构","线段树","可持久化线段树"],"categories":["笔记"],"content":"本文讲述的是 可持久化权值线段树 。这种数据结构在普通线段树的基础之上支持查询某个历史版本，同时时间复杂度与线段树是同级，空间复杂度相较而言更高一些。 下文中将以「可持久化线段树」代指「可持久化权值线段树」。 注意：可持久化线段树难以进行区间修改操作，因为进行该操作可能会修改历史信息导致查询出错误结果，或者使用标记永久化避免出现这个问题，该项内容不在本文的讨论范围内。 前置知识 线段树 原理 可持久化线段树维护的是每个节点的历史版本，而最朴素的实现方式是每次进行修改操作都新开一颗线段树，而这样操作带来的时空复杂度是不可接受的。 稍微推导一下可以发现每次修改操作需要修改的节点个数只有 log(n) 个，那么可以使用动态开点并记录历史版本的方式来节约空间和时间的消耗，这就是可持久化线段树。 实现 先进行离散化，以节约存储空间，具体实现不再过多描述。 然后以数值为基础建立权值线段树，维护每个数值区间中一共有多少个数。 node 类型的定义如下： 这和 线段树学习笔记 中的定义有一些差别。首先，l 和 r 的存储的信息从左右端点变成了左右儿子的数组下标；其次，区间维护的信息从节点的和差与最值变成了区间中数据的个数。 再来看 build 函数。 变化是线段树存储方式从原先的堆变成了动态开点，动态开点线段树可以在网上找到相关学习资料，在此不作过多赘述。 还有 insert 函数： 仍然是动态开点，新节点的初始值由 node(l, r) 变成了 tr[p] ，即以第 i−1 个版本为基础，再进行修改。 最后是 query 函数： 通过 tr[tr[q].l].c - tr[tr[p].l].c 获得 [l,r] 区间内数的个数。 注：第 r 号节点的数的个数减去第 l−1 号节点的数的个数即为 [l,r] 中的数的个数，这里使用到了前缀和的思想。 取 [l,mid] 区间的数的个数并记为 cnt，接下来分两种情况： cnt≤k：第 k 小的数在左子树上。 cnt&gt;k：第 k 小的数在右子树上，查询右子树第 k−cnt 小的数。 递归查询即可。 代码 对应题目：洛谷 - P3834 【模板】可持久化线段树 2 8d70723 参考资料 第 255 ~ 258 页，0x48 可持久化数据结构，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 可持久化线段树，OI Wiki，2021 年 12 月 11 日。 可持久化线段树，维基百科，2021 年 10 月 29 日。 4.4 可持久化数据结构，AcWing 算法提高课，闫学灿，2019 年 12 月 28 日。 "},{"title":"LibreOJ - 2130. 「NOI2015」软件包管理器","date":"2021-12-05T00:15:28.000Z","url":"/libreoj-2130/","tags":["LibreOJ","洛谷","AcWing","树链剖分","线段树"],"categories":["题解"],"content":"题目信息卡题目名称软件包管理器提交地址洛谷 P7911AcWing 4088CCF CSPJ2021C @ Hydro题目难度普及/提高-题目来源NOI2015 题面 题目背景 Linux 用户和 OSX 用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu 使用的 apt-get，Fedora/CentOS 使用的 yum，以及 OSX 下可用的 homebrew 都是优秀的软件包管理器。 题目描述 你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 a 依赖软件包 b，那么安装软件包 a 以前，必须先安装软件包 b。同时，如果想要卸载软件包 b，则必须卸载软件包 a。 现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。且依赖关系不存在环（即不会存在 m 个软件包 a1​,a2​,…,am​，对于 i&lt;m，ai​ 依赖 ai​+1，而 am​ 依赖 a1​ 的情况）。 现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。 注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为 0。 输入格式 第一行一个正整数 n，表示软件包个数，从 0 开始编号。 第二行有 n−1 个整数，第 i 个表示 i 号软件包依赖的软件包编号。 然后一行一个正整数 q，表示操作个数，格式如下： install x 表示安装 x 号软件包 uninstall x 表示卸载 x 号软件包 一开始所有软件包都是未安装的。 对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。 输出格式 输出 q 行，每行一个整数，表示每次询问的答案。 输入输出样例 样例输入 #1 样例输出 #1 样例解释 #1 一开始所有软件包都处于未安装状态。 安装 5 号软件包，需要安装 0,1,5 三个软件包。 之后安装 6 号软件包，只需要安装 6 号软件包。此时安装了 0,1,5,6 四个软件包。 卸载 1 号软件包需要卸载 1,5,6 三个软件包。此时只有 0 号软件包还处于安装状态。 之后安装 4 号软件包，需要安装 1,4 两个软件包。此时 0,1,4 处在安装状态。最后，卸载 0 号软件包会卸载所有的软件包。 样例输入 #2 样例输出 #2 数据范围与约定 思路 一道树链剖分模板题。 通过分析可得：每次执行安装操作时，把根节点到软件 X 路径上的值设为 1 ；每次执行卸载操作时，把以 X 为根节点的子树上的所有值设为 0 。 然后题目就转化为了区间和问题，操作前记录下线段树整体的和，操作后再记录一次，两者相减取绝对值即为安装状态被改变了的软件包的数量。 几点注意事项： 线段树区间覆盖的实现：在修改时将 += 改为 = 即可。 懒标记初值不要用 0 ，因为修改的时候会有 0 。 推荐从 1 开始编号，方便维护，避免因编号起始值不同带来的麻烦。 代码 "},{"title":"LibreOJ - 2633. 「BalticOI 2011 Day1」宝藏与维京海盗 Treasures and Vikings","date":"2021-11-19T18:42:14.000Z","url":"/libreoj-2633/","tags":["搜索","LibreOJ","洛谷","S2OJ"],"categories":["题解"],"content":"题目信息卡题目名称宝藏与维京海盗提交地址LibreOJ 2633洛谷 P4668S2OJ 1159题目难度提高+/省选-题目来源BalticOI 2011 Day1 题面 本题译自 BalticOI 2011 Day1 T4「Treasures and Vikings」。 题目描述 你有一张藏宝图，藏宝图可视为 N×M 的网格。每个格子可能是你的船、贼船、海、陆地或藏宝点。你只有一条船，整张图只有一条贼船。你和贼船都只能在海域移动。藏宝点在海中。 你与贼船交替移动，你移动一次 + 贼船移动一次算作一回合。每次移动，你可以移动到上下左右四个相邻格子中的一格，也可以不移动。贼船的移动同理，贼船也可以不移动。你先移动。 每一回合结束后，如果你和贼船在同一行或同一列，你就挂了；在你没挂的情况下，如果你位于藏宝点，你就拿到了宝藏。 请问：是否有一条安全的路径，使得无论贼船怎么跑你都能或者拿到宝藏。 输入格式 第一行有两个整数 N 和 M。 在接下来的 N 行中，每行 M 个字符。字符的含义如下： 字符 . I V Y T 含义 海 陆地 贼船 你 藏宝点 保证只会出现表中的五种字符，保证 V, Y, T 都只出现一次。 输出格式 输出 YES 或 NO，表示是否有一条安全的路径。 输入输出样例 样例输入 #1 样例输出 #1 样例输入 #2 样例输出 #2 样例输入 #3 样例输出 #3 数据范围与约定 对于 50% 的数据，1≤N,M≤200 。 对于 100% 的数据，1≤N,M≤700 。 思路 先使用广搜预处理一下贼船到达每个非陆地点的最小时间并存储下来，然后再使用广搜搜一下是否能到 T 点即可。 在第二遍广搜的时候需要注意，如果到达某个点的用时比贼船到达的用时长，那么这条路就是走不通的，不能扩展。 其余信息可以看代码注释. 代码 "},{"title":"CSP-J 2021 题解","date":"2021-11-15T11:45:03.000Z","url":"/csp-j-2021/","tags":["数学","模拟","NOIP"],"categories":["题解"],"content":" 本文篇幅较长，可以通过页面右下角的目录功能快速跳转。 分糖果 题目信息卡题目名称提交地址洛谷 P7909AcWing 4086CCF CSPJ2021A @ Hydro题目难度入门 题面 题目背景 红太阳幼儿园的小朋友们开始分糖果啦！ 题目描述 红太阳幼儿园有 n 个小朋友，你是其中之一。保证 n≤2 。 有一天你在幼儿园的后花园里发现无穷多颗糖果，你打算拿一些糖果回去分给幼儿园的小朋友们。 由于你只是个平平无奇的幼儿园小朋友，所以你的体力有限，至多只能拿 R 块糖回去。 但是拿的太少不够分的，所以你至少要拿 L 块糖回去。保证 n≤L≤R 。 也就是说，如果你拿了 k 块糖，那么你需要保证 L≤k≤R 。 如果你拿了 k 块糖，你将把这 k 块糖放到篮子里，并要求大家按照如下方案分糖果：只要篮子里有不少于 n 块糖果，幼儿园的所有 n 个小朋友（包括你自己）都从篮子中拿走恰好一块糖，直到篮子里的糖数量少于 n 块。此时篮子里剩余的糖果均归你所有——这些糖果是作为你搬糖果的奖励。 作为幼儿园高质量小朋友，你希望让作为你搬糖果的奖励的糖果数量（而不是你最后获得的总糖果数量！）尽可能多；因此你需要写一个程序，依次输入 n,L,R ，并输出出你最多能获得多少作为你搬糖果的奖励的糖果数量。 输入格式 输入一行，包含三个正整数 n,L,R，分别表示小朋友的个数、糖果数量的下界和上界。 输出格式 输出一行一个整数，表示你最多能获得的作为你搬糖果的奖励的糖果数量。 输入输出样例 样例输入 #1 样例输出 #1 样例解释 #1 拿 k=20 块糖放入篮子里。 篮子里现在糖果数 20≥n=7，因此所有小朋友获得一块糖； 篮子里现在糖果数变成 13≥n=7，因此所有小朋友获得一块糖； 篮子里现在糖果数变成 6&lt;n=7，因此这 6 块糖是作为你搬糖果的奖励。 容易发现，你获得的作为你搬糖果的奖励的糖果数量不可能超过 6 块（不然，篮子里的糖果数量最后仍然不少于 n，需要继续每个小朋友拿一块），因此答案是 6。 样例输入 #2 样例输出 #2 样例解释 #2 容易发现，当你拿的糖数量 k 满足 14=L≤k≤R=18 时，所有小朋友获得一块糖后，剩下的 k−10 块糖总是作为你搬糖果的奖励的糖果数量，因此拿 k=18 块是最优解，答案是 8。 数据范围与约定 测试点 n≤ R≤ R−L≤ 1 2 5 2 5 10 3 103 4 105 5 103 109 0 6 103 7 105 105 8 109 109 9 10 对于所有数据，保证 2≤n≤L≤R≤109。 思路 此题是一道结论题。 代码 网络连接 题目信息卡题目名称提交地址洛谷 P7911AcWing 4088CCF CSPJ2021C @ Hydro题目难度普及/提高- 题面 题目描述 TCP/IP 协议是网络通信领域的一项重要协议。今天你的任务，就是尝试利用这个协议，还原一个简化后的网络连接场景。 在本问题中，计算机分为两大类：服务机（Server）和客户机（Client）。服务机负责建立连接，客户机负责加入连接。 需要进行网络连接的计算机共有 n 台，编号为 1∼n，这些机器将按编号递增的顺序，依次发起一条建立连接或加入连接的操作。 每台机器在尝试建立或加入连接时需要提供一个地址串。服务机提供的地址串表示它尝试建立连接的地址，客户机提供的地址串表示它尝试加入连接的地址。 一个符合规范的地址串应当具有以下特征： 必须形如 a.b.c.d:e 的格式，其中 a,b,c,d,e 均为非负整数； 0≤a,b,c,d≤255 ， 0≤e≤65535； a,b,c,d,e 均不能含有多余的前导 0。 相应地，不符合规范的地址串可能具有以下特征： 不是形如 a.b.c.d:e 格式的字符串，例如含有多于 3 个字符 . 或多于 1 个字符 : 等情况； 整数 a,b,c,d,e 中某一个或多个超出上述范围； 整数 a,b,c,d,e 中某一个或多个含有多余的前导 0。 例如，地址串 192.168.0.255:80 是符合规范的，但 192.168.0.999:80、192.168.00.1:10、192.168.0.1:088、192:168:0:1.233 均是不符合规范的。 如果服务机或客户机在发起操作时提供的地址串不符合规范，这条操作将被直接忽略。 在本问题中，我们假定凡是符合上述规范的地址串均可参与正常的连接，你无需考虑每个地址串的实际意义。 由于网络阻塞等原因，不允许两台服务机使用相同的地址串，如果此类现象发生，后一台尝试建立连接的服务机将会无法成功建立连接；除此之外，凡是提供符合规范的地址串的服务机均可成功建立连接。 如果某台提供符合规范的地址的客户机在尝试加入连接时，与先前某台已经成功建立连接的服务机提供的地址串相同，这台客户机就可以成功加入连接，并称其连接到这台服务机；如果找不到这样的服务机，则认为这台客户机无法成功加入连接。 请注意，尽管不允许两台不同的服务机使用相同的地址串，但多台客户机使用同样的地址串，以及同一台服务机同时被多台客户机连接的情况是被允许的。 你的任务很简单：在给出每台计算机的类型以及地址串之后，判断这台计算机的连接情况。 输入格式 第一行，一个正整数 n。 接下来 n 行，每行两个字符串 op,ad，按照编号从小到大给出每台计算机的类型及地址串。 其中 op 保证为字符串 Server 或 Client 之一，ad 为一个长度不超过 25 的，仅由数字、字符 . 和字符 : 组成的非空字符串。 每行的两个字符串之间用恰好一个空格分隔开，每行的末尾没有多余的空格。 输出格式 输出共 n 行，每行一个正整数或字符串表示第 i 台计算机的连接状态。其中： 如果第 i 台计算机为服务机，则： 如果其提供符合规范的地址串且成功建立连接，输出字符串 OK。 如果其提供符合规范的地址串，但由于先前有相同地址串的服务机而无法成功建立连接，输出字符串 FAIL。 如果其提供的地址串不是符合规范的地址串，输出字符串 ERR。 如果第 i 台计算机为客户机，则： 如果其提供符合规范的地址串且成功加入连接，输出一个正整数表示这台客户机连接到的服务机的编号。 如果其提供符合规范的地址串，但无法成功加入连接时，输出字符串 FAIL。 如果其提供的地址串不是符合规范的地址串，输出字符串 ERR。 输入输出样例 样例输入 #1 样例输出 #1 样例解释 #1 计算机 1 为服务机，提供符合规范的地址串 192.168.1.1:8080，成功建立连接； 计算机 2 为服务机，提供与计算机 1 相同的地址串，未能成功建立连接； 计算机 3 为客户机，提供符合规范的地址串 192.168.1.1:8080，成功加入连接，并连接到服务机 1； 计算机 4 为客户机，提供符合规范的地址串 192.168.1.1:80，找不到服务机与其连接； 计算机 5 为客户机，提供的地址串 192.168.1.1:99999 不符合规范。 样例输入 #2 样例输出 #2 数据范围与约定 测试点编号 n≤ 特殊性质 1 10 性质 1 2 3 2∼3 100 4∼5 1000 6∼8 性质 1 2 9∼11 性质 1 12∼13 性质 2 14∼15 性质 4 16∼17 性质 5 18∼20 无特殊性质 性质 1：保证所有的地址串均符合规范； 性质 2：保证对于任意两台不同的计算机，如果它们同为服务机或者同为客户机，则它们提供的地址串一定不同； 性质 3：保证任意一台服务机的编号都小于所有的客户机； 性质 4：保证所有的地址串均形如 a.b.c.d:e 的格式，其中 a,b,c,d,e 均为不超过 109 且不含有多余前导 0 的非负整数； 性质 5：保证所有的地址串均形如 a.b.c.d:e 的格式，其中 a,b,c,d,e 均为只含有数字的非空字符串。 对于 100% 的数据，保证 1≤n≤1000。 思路 细节稍多的模拟题。 先按照题意检查读入的地址串是否合法，如果合法则继续操作，使用 map 记录即可。 代码 小熊的果篮 题目信息卡题目名称提交地址洛谷 P7912AcWing 4089CCF CSPJ2021D @ Hydro题目难度普及/提高- 题面 题目描述 小熊的水果店里摆放着一排 n 个水果。每个水果只可能是苹果或桔子，从左到右依次用正整数 1,2,…,n 编号。连续排在一起的同一种水果称为一个“块”。小熊要把这一排水果挑到若干个果篮里，具体方法是：每次都把每一个“块”中最左边的水果同时挑出，组成一个果篮。重复这一操作，直至水果用完。注意，每次挑完一个果篮后，“块”可能会发生变化。比如两个苹果“块”之间的唯一桔子被挑走后，两个苹果“块”就变成了一个“块”。请帮小熊计算每个果篮里包含的水果。 输入格式 第一行，包含一个正整数 n，表示水果的数量。 第二行，包含 n 个空格分隔的整数，其中第 i 个数表示编号为 i 的水果的种类，1 代表苹果，0 代表桔子。 输出格式 输出若干行。 第 i 行表示第 i 次挑出的水果组成的果篮。从小到大排序输出该果篮中所有水果的编号，每两个编号之间用一个空格分隔。 输入输出样例 样例输入 #1 样例输出 #1 样例解释 #1 所有水果一开始的情况是 [1,1,0,0,1,1,1,0,1,1,0,0]，一共有 6 个块。 在第一次挑水果组成果篮的过程中，编号为 1,3,5,8,9,11 的水果被挑了出来。 之后剩下的水果是 [1,0,1,1,1,0]，一共 4 个块。 在第二次挑水果组成果篮的过程中，编号为 2,4,6,12 的水果被挑了出来。 之后剩下的水果是 [1,1]，只有 1 个块。 在第三次挑水果组成果篮的过程中，编号为 7 的水果被挑了出来。 最后剩下的水果是 [1]，只有 1 个块。 在第四次挑水果组成果篮的过程中，编号为 10 的水果被挑了出来。 样例输入 #2 样例输出 #2 数据范围与约定 对于 10% 的数据，n≤5。 对于 30% 的数据，n≤1000。 对于 70% 的数据，n≤50000。 对于 100% 的数据，1≤n≤2×105。 提示：由于数据规模较大，建议 C/C++ 选手使用 scanf 和 printf 语句输入、输出。 思路 分块储存，使用队列维护并进行模拟。 在队列中相邻两块可以合并成一块进行处理。 代码 "},{"title":"洛谷 - P1004 [NOIP2000 提高组] 方格取数","date":"2021-11-11T16:00:15.000Z","url":"/luogu-p1004/","tags":["动态规划","NOIP"],"categories":["题解"],"content":"题目信息卡题目名称方格取数提交地址洛谷 P1004AcWing 1027题目难度普及+/提高题目来源NOIP 2000 提高组 题面 题目描述 设有 N×N 的方格图 (N≤9)，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 0。如下图所示（见样例）: 某人从图的左上角的 A 点出发，可以向下行走，也可以向右走，直到到达右下角的 B 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 0）。 此人从 A 点到 B 点共走两次，试找出 2 条这样的路径，使得取得的数之和为最大。 输入格式 输入的第一行为一个整数 N（表示 N×N 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 0 表示输入结束。 输出格式 只需输出一个整数，表示 2 条路径上取得的最大的和。 输入输出样例 样例输入 #1 样例输出 #1 思路 本题是一道四维动态规划模板题。 使用数组的第一维、第二维记录第一次走的路径，第三维、第四维记录第二次走的路径，容易推出转移方程： fi,j,k,l​=max{fi−1,j,k−1,l​,&nbsp;fi−1,j,k,l−1​,&nbsp;fi,j−1,k−1,l​,&nbsp;fi,j−1,k,l−1​}+wi,j​+wk,l​ 当 i=k 且 j=l 时，需要减去重复的数字： fi,j,k,l​=fi,j,k,l​−wi,j​ 。 最后 fn,n,n,n​ 即为所求。 代码 "},{"title":"洛谷 - P7913 [CSP-S 2021] 廊桥分配","date":"2021-10-29T21:55:55.000Z","url":"/luogu-p7913/","tags":["模拟","STL","NOIP"],"categories":["题解"],"content":"题目信息卡题目名称廊桥分配提交地址洛谷 P7913题目难度普及+/提高 题面 题目描述 当一架飞机抵达机场时，可以停靠在航站楼旁的廊桥，也可以停靠在位于机场边缘的远机位。乘客一般更期待停靠在廊桥，因为这样省去了坐摆渡车前往航站楼的周折。然而，因为廊桥的数量有限，所以这样的愿望不总是能实现。 机场分为国内区和国际区，国内航班飞机只能停靠在国内区，国际航班飞机只能停靠在国际区。一部分廊桥属于国内区，其余的廊桥属于国际区。 L 市新建了一座机场，一共有 n 个廊桥。该机场决定，廊桥的使用遵循“先到先得”的原则，即每架飞机抵达后，如果相应的区（国内/国际）还有空闲的廊桥，就停靠在廊桥，否则停靠在远机位（假设远机位的数量充足）。该机场只有一条跑道，因此不存在两架飞机同时抵达的情况。 现给定未来一段时间飞机的抵达、离开时刻，请你负责将 n 个廊桥分配给国内区和国际区，使停靠廊桥的飞机数量最多。 输入格式 输入的第一行，包含三个正整数 n,m1​,m2​，分别表示廊桥的个数、国内航班飞机的数量、国际航班飞机的数量。 接下来 m1​ 行，是国内航班的信息，第 i 行包含两个正整数 a1,i​,b1,i​，分别表示一架国内航班飞机的抵达、离开时刻。 接下来 m2​ 行，是国际航班的信息，第 i 行包含两个正整数 a2,i​,b2,i​，分别表示一架国际航班飞机的抵达、离开时刻。 每行的多个整数由空格分隔。 输出格式 输出一个正整数，表示能够停靠廊桥的飞机数量的最大值。 输入输出样例 样例输入 #1 样例输出 #1 样例解释 #1 在图中，我们用抵达、离开时刻的数对来代表一架飞机，如 (1,5) 表示时刻 1 抵达、时刻 5 离开的飞机；用 √ 表示该飞机停靠在廊桥，用 × 表示该飞机停靠在远机位。 我们以表格中阴影部分的计算方式为例，说明该表的含义。在这一部分中，国际区有 2 个廊桥，4 架国际航班飞机依如下次序抵达： 首先 (2,11) 在时刻 2 抵达，停靠在廊桥。 然后 (4,15) 在时刻 4 抵达，停靠在另一个廊桥。 接着 (7,17) 在时刻 7 抵达，这时前 2 架飞机都还没离开、都还占用着廊桥，而国际区只有 2 个廊桥，所以只能停靠远机位。 最后 (12,16) 在时刻 12 抵达，这时 (2,11) 这架飞机已经离开，所以有 1 个空闲的廊桥，该飞机可以停靠在廊桥。 根据表格中的计算结果，当国内区分配 2 个廊桥、国际区分配 1 个廊桥时，停靠廊桥的飞机数量最多，一共 7 架。 样例输入 #2 样例输出 #2 样例解释 #2 当国内区分配 2 个廊桥、国际区分配 0 个廊桥时，停靠廊桥的飞机数量最多，一共 4 架，即所有的国内航班飞机都能停靠在廊桥。 需要注意的是，本题中廊桥的使用遵循「先到先得」的原则，如果国际区只有 1 个廊桥，那么将被飞机 (1,19) 占用，而不会被 (3,4)、(5,6)、(7,8)、(9,10) 这 4 架飞机先后使用。 数据范围与约定 对于 20% 的数据，n≤100，m1​+m2​≤100。 对于 40% 的数据，n≤5000，m1​+m2​≤5000。 对于 100% 的数据，1≤n≤105，m1​,m2​≥1，m1​+m2​≤105，所有 a1,i​,b1,i​,a2,i​,b2,i​ 为数值不超过 108 的互不相同的正整数，且保证对于每个 i∈[1,m1​]，都有 a1,i​&lt;b1,i​，以及对于每个 i∈[1,m2​]，都有 a2,i​&lt;b2,i​。 思路 将每个航班存储为一个 pair&lt;int, int&gt; ，第一关键字表示该航班的抵达时间，第二关键字表示该航班的离开时间。 设 f(x),g(x) 分别表示有 x 个廊桥分配给国内（国际）航班时停靠廊桥的飞机数量的最大值，则最后答案可以转化成 max(f(x)+g(n−x)),&nbsp;(0≤x≤n) 。 将廊桥一条一条的分配给国内航班，并使用 set 维护当前未在廊桥上的飞机。 当一条廊桥加入后，从 set 中删去以下飞机： set 中最早抵达的飞机 p0​ ，并将当前的 cnt+1 。 在 p0​ 离开后最早抵达的飞机 p1​ ，并将当前的 cnt+1 。 在 p1​ 离开后最早抵达的飞机 p2​ ，并将当前的 cnt+1 。 以此类推，直到没有飞机可以操作为止。该操作可以使用 lower_bound 查找来降低时间复杂度。完成后将新增的可以停靠廊桥的飞机加入答案数组中。 国际航班同理，按照上述步骤操作即可。 时间复杂度 O(mlogm) 。 代码 "},{"title":"S2OJ - 90. Divisors","date":"2021-10-21T22:55:53.000Z","url":"/s2oj-90/","tags":["数学","S2OJ"],"categories":["题解"],"content":"题目信息卡题目名称Divisors提交地址S2OJ 90题目来源雅礼集训 2019.10.23 题面 题目描述 给定 m 个不同的正整数 a1​,a2​,...,am​ ，请对 0 到 m 每一个 k 计算，在区间 [1,n] 里有多少正整数是 a 中恰好 k 个数的约数。 输入格式 第一行包含两个正整数 n,m ，分别表示区间范围以及 a 数组的大小。 第二行包含 m 个不同的正整数 a1​,a2​,...,am​ ，表示 a 数组。 输出格式 输出 m+1 行，每行一个整数，其中第 i 行输出 k=i 的答案。 输入输出样例 样例输入 #1 样例输出 #1 样例输入 #2 样例输出 #3 数据规模与约定 测试点编号 n m 1 5 ≤1000 2 50 3 200 4 1 ≤109 5 6 7 200 8 9 10 思路 一句话题意：求 [1,n] 中有多少数是 ai​∼am​ 中 k 个数的约数（k∈[1,m]）。 可以使用 map 存储每一个约数是 a1​∼ai​ 中几个数的约数。 然后考虑存储答案，设 sumj​ 表示「是 a1​∼ai​ 中 j 个数的约数」的数的个数。 每当扫到一个约数的时候将 sum[b[j]]--, sum[++b[j]]++ 即可。 代码 "},{"title":"洛谷 - P2158 [SDOI2008] 仪仗队","date":"2021-10-06T08:35:12.000Z","url":"/luogu-p2158/","tags":["数学","洛谷","筛法","最大公约数","莫比乌斯反演"],"categories":["题解"],"content":"题目信息卡题目名称仪仗队提交地址洛谷 P2158POJ 3090AcWing 201题目难度提高+/省选- 本题有以下几种解法： 莫比乌斯反演（本文） 欧拉反演 题面 题目描述 作为体育委员，C 君负责这次运动会仪仗队的训练。仪仗队是由学生组成的 N×N 的方阵，为了保证队伍在行进中整齐划一，C 君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐（如下图）。 现在，C 君希望你告诉他队伍整齐时能看到的学生人数。 输入格式 一行，一个正整数 N。 输出格式 输出一行一个数，即 C 君应看到的学生人数。 输入输出样例 输入 #1 输出 #1 数据范围与说明 对于 100% 的数据，1≤N≤40000。 思路 设 C 君的坐标为原点建立一个平面直角坐标系。 容易发现相同的斜率只能有一个，否则会被挡住，可以推出当一个点的横坐标与纵坐标的最大公约数大于 1 时就会被遮挡。 所以问题就被转化成了找所有满足 gcd(x,y)=1 的整数对，使用莫比乌斯反演即可解决。 推导过程： 设 f(n) 为 gcd(x,y) 为 n 的整数对个数， F(n) 表示 n∣gcd(x,y) 的整数对个数 可得 F(n)=n∣d∑​f(d) 。 反演得 f(n)=n∣d∑​μ(nd​)F(d) 。 容易发现 F(d)=⌊dN​⌋2 。 整理得 f(n)=n∣d∑​μ(nd​)⌊dn​⌋2 。 最后求 f(1) 即为答案。 最后还需要加上 (0,1) 和 (1,0) 两个点。 还需要特判当 n=1 时的情况，因为此时仪仗队内仅有 C 君一人。 代码 "},{"title":"S2OJ - 1036. 打打牌","date":"2021-10-01T11:28:45.000Z","url":"/s2oj-1036/","tags":["数学","S2OJ","前缀和","位运算"],"categories":["题解"],"content":"题目信息卡题目名称打打牌提交地址S2OJ 1036题目来源长郡5 10.13 题面 题目描述 小胡同学是个热爱打牌的好孩子。 机房里，有 n 个同学在打牌，小胡同学和小王同学正在观战。经过若干轮的较量之后，每个人都有了个积分，第 i 个人的积分为 ai​ ，把所有的人的积分全部按位或起来即为整个牌局的总积分（也就是 a1​∣a2​∣...∣an​）。 聪明的小胡同学很快就算出了总分数，小王同学眼看小胡同学比自己算得快，非常不爽，决定刁难一下小胡同学。众所周知，小王同学有个幸运数字 x。小王让小胡从 n 个人随意挑选出一个人，将他的积分乘上 x，之后再计算牌局的总积分。小王同学问小胡同学牌局最大可能的总积分是多少，这可难倒了小胡同学，你能帮帮他吗？ 输入 第一行两个正整数 n 和 x 接下来一行有 n 个正整数，代表 a1​,a2​,...,an​ 。 输出 输出一个整数，代表最大可能的总积分。 样例输入 样例输出 数据规模与约定 对于 50% 的数据，n≤2000； 对于 100% 的数据，1≤n≤100000,2≤x≤8,0≤ai​≤109 。 思路 先预处理出来前缀或数组和后缀或数组，在计算答案时只需比较 prei−1​∣(ai​×x)∣sufi+1​ 和 ans 的大小即可。 代码 "},{"title":"S2OJ - 1034. 列车调度","date":"2021-09-30T19:50:53.000Z","url":"/s2oj-1034/","tags":["贪心","S2OJ"],"categories":["题解"],"content":"题目信息卡题目名称列车调度提交地址S2OJ 1034题目来源中山A组 2018.8.19 题面 题目描述 输入格式 输入共 2 行： 第 1 行包含 1 个正整数 N，表示 N 辆列车。 第 2 行包含 N 个正整数，为 1 至 N 的一个排列，表示进站次序。 输出格式 输出共一行，包含一个整数，表示站台内轨道数 K 的最小值。 输入样例 1 输出样例 1 输入样例 2 输出样例 2 数据规模与约定 对于 30% 的数据，N≤10; 对于 70% 的数据，N≤2000; 对于 100% 的数据，N≤100000; 思路 贪心解决。 容易想到最优方案是让列车进入队尾车辆编号刚好大于要入队的车的编号的队列，使用 set 维护队尾即可。 代码 "},{"title":"S2OJ - 1024. 子串","date":"2021-09-27T21:48:35.000Z","url":"/s2oj-1024/","tags":["数据结构","S2OJ","Trie"],"categories":["题解"],"content":"题目信息卡题目名称子串提交地址S2OJ 1024题目来源NOIP 2018 四校联训 Round 11 题面 题目描述 你有一个长度为 n 的 01 串 s，你想知道它字典序第 k 小的不同非空子串（即恰好存在 k−1 个子串比该子串字典序小，且它们（包括该子串本身）两两不同 ）。两个子串被认为不同当且仅当它们长度不同或者至少有一个位置上的字符不同。串 a 的字典序小于串 b 当且仅当 a 为 b 的一个前缀或者 a 从左往右第一个与 b 不同的字符比 b 的小。 输入格式 第一行两个正整数 n,&nbsp;k。 第二行一个长度为 n 的 01 串 s，保证 s 至少有 k 种不同的子串。 输出格式 输出一个 01 串，表示答案。 样例输入 样例输出 数据规模与约定 对于 20% 的数据，n≤100； 对于 50% 的数据，n≤1000； 对于 70% 的数据，n≤10000； 对于 100% 的数据，n≤105,&nbsp;k≤100。 思路 建一个 01 Trie ，并将 s 的所有子串存进这个 Trie 树里面。 在查询时如果左子树（代表 0）包含的数值数量大于等于 k ，那么就查询左子树内第 k 小的子串；反之则查询右子树（代表 1）的第 k−sizeleft​ 小的子串。 一直递归查询，直到查询到 s 的第 k 小字串时（即传入的 k=1 时）停止并退出程序，此时输出的内容即为答案。 代码 "},{"title":"最小生成树学习笔记","date":"2021-08-27T16:57:23.000Z","url":"/minimum-spanning-tree/","tags":["图论","最小生成树","Prim","Kruskal"],"categories":["笔记"],"content":"在 OI 中常用的最小生成树算法有 朴素版 Prim 算法 和 Kruskal 算法 。 朴素版 Prim 算法 Prim 算法是一种常见且好写的最小生成树算法。 朴素版 Prim 算法的基本思想是从一个结点开始不断加点，其时间复杂度约为 O(n2) ，适用于稠密图。 思路 朴素版的 Prim 算法思想与我在 最短路学习笔记 一文中提到的朴素版 Dijkstra 算法很相似。 大体步骤如下： 初始化一个 dist 数组，使所有距离均为 ∞ 。设集合 S 表示已经在连通块内的所有点。 进行 n 次迭代： 找到集合外 S 中的距离最近的点，将其赋值给 t 。 用 t 更新其他点到 集合 S 的距离。 将 t 添加到集合 S 中。 代码 题目： P3366 【模板】最小生成树 Kruskal 算法 时间复杂度约为 O(mlogm) ，适用于稀疏图。 思路 先将所有边按照权重从小到大排序。 枚举每条边 (a,b,c)，如果 a,b 不连通，将这条边加入集合 S 。 注：可以使用并查集维护联通块。 代码 题目： P3366 【模板】最小生成树 参考资料 最小生成树 - OI Wiki 最小生成树 - 维基百科 Prim 算法 - 维基百科 Kruskal 算法 - 维基百科 本文中 Prim 算法的演示图片原稿来自维基共享资源，原作者为 Alexander Drichel ，经本人整合后以 CC BY-SA 3.0 协议发布，初版可见 caf2ba8@OI-wiki/OI-wiki，本文其余内容的版权协议见正文下方「版权声明」处。 "},{"title":"最短路学习笔记","date":"2021-08-12T10:50:06.000Z","url":"/shortest-path/","tags":["图论","最短路","Dijkstra","Floyd","Bellman-Ford","SPFA"],"categories":["笔记"],"content":"最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由节点和路径组成的）中两节点之间的最短路径。 由于竞赛中不考查文中所述算法的证明，故本文不探讨与证明相关的内容，如有需要请自行查阅维基百科。 性质 对于边权为正的图，任意两个节点间的最短路不会重复经过某一个点或某一条边。 对于边权为正的图，任意两个节点间的最短路中的任意一条的节点数不会超过 n ，边数不会超过 n−1 。 确定起点的最短路径问题 这种问题也叫单源最短路问题，即已知起始节点，求最短路径的问题。在边权非负时适合使用 Dijkstra 算法，若边权为负时则适合使用 Bellman-ford 算法或者 SPFA 算法。 Dijkstra 算法 该算法的时间复杂度为 O(n2) ，使用堆优化后可达 O(mlogm) 。 演示 Dijkstra 算法每次取出未访问节点中距离最小的节点，并用该节点更新其他节点的距离。（在演示过程中访问过的节点会被标为红色） 实现 设起点为 1 ，终点为 n 。 初始化 dist1​=0 ，其余节点的 dist 值为 ∞ 。 找出一个未被标记的 distx​ 最小的节点 x ，并将其加入集合 S 。 扫描节点 x 的所有出边 (u,v,w) ，若 distv​&gt;distu​+w 则使用 distu​+w 更新 distv​ 。 重复 2、3 两个步骤直到 ∁U​S=∅ 。 代码 题目链接：849. Dijkstra 求最短路 I - AcWing 堆优化的 Dijkstra 算法 使用堆优化的 Dijkstra 算法的时间复杂度为 O(mlogn) 实现 使用堆代替找距离最近的点的操作即可。 由于 C++ STL 中的优先队列不支持删除元素的操作，所以队列中会有重复元素导致复杂度变为 O(mlogm) ，但比手写堆要容易许多。 代码 题目链接：850. Dijkstra 求最短路 II Bellman-Ford 算法 该算法的时间复杂度为 O(nm) （对于存在最短路的图）。 实现 遍历所有边 (u,v,w) ，若 distv​&gt;distu​+w 则使用 distu​+w 更新 distv​ ，到没有更新操作发生时停止。 在没有负环的情况下最多遍历 n 次所有边即可得到最短路。 判断负环 在第 n 次遍历后如果仍能更新最短路径长度则可以判断存在负环。 代码 SPFA 算法 SPFA 算法在国际上通称为「队列优化的 Bellman-Ford 算法」，仅在中国大陆地区称为 「SPFA 算法」（Shortest Path Fast Algorithm），在随机图上运行效率为 O(km) （ k 是一个很小的常数），但在特殊构造的图上时间复杂度会退化为为 O(nm) 。 实现 先初始化一个队列，并将起点入队。 取出队头 t ，并扫描其所有出边 (u,v,w) ，若 distv​&gt;distu​+w 则使用 distu​+w 更新 distv​ ，并将 v 入队。 重复上述步骤直到队列为空。 SPFA 判负环 在每次更新 dist[x] 的同时记录当前所走过的边数 cnt[x] = cnt[t] + 1 ，若 cnt[n] 大于等于 n 则可以证明存在图中负环。 由于从 1 号点开始走不能保证走到所有的负环，因此需要将节点 1∼n 都入队进行查找。 卡 SPFA 生成一棵以起点为根的树，树高尽量高（比如 1 为起点时，可以令每个点 i 的父亲在 max(i−5,1) 到 i−1 随机），边权随机，作为最短路径树，同时直接递推求出每个点的带权深度 di​ 对于剩下的边，端点 (a,b) 随机，边权在 ∣db​−da​∣ 到 ∣db​−da​∣+5 随机（如果是有向图则去掉绝对值符号， 5 可以换成其他较小的正数） 这样生成的图中，次短路的条数非常的多，而 SPFA 一旦错误地进入了次短路的分支，就会使得一整棵子树被赋错误的距离，从而在后期不得不重新更新。而由于边权接近，剪枝的效果会受到很大影响。 代码 SPFA 求最短路 题目：851. spfa 求最短路 - AcWing SPFA 判负环 题目：852. spfa 判断负环 - AcWing 确定终点的最短路径问题 与确定起点的问题相反，该问题是已知终结节点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。 只需要反向存图然后再跑一遍单源最短路即可。 确定起点终点的最短路径问题 即已知起点和终点，求两节点之间的最短路径。 可以使用单源最短路算法并进行剪枝：在处理完到终点的最短路径后直接停止计算最短路。 全局最短路径问题 全局最短路径问题也叫多源最短路问题，可以求出图中所有的最短路径。适合使用 Floyd 算法，时间复杂度为 O(n3) 。 实现 设 fk,i,j​ 表示经过若干个编号不超过 k 的节点从 i 到 j 的最短路径长度。 容易发现，这个问题可以拆分为两个子问题：经过若干个编号不超过 k−1 的节点从 i 到 j ，或者从 i 经过 k 再到 j 。可以得出递推式： f∗k,i,j=min(f∗k−1,i,j,f∗k−1,i,k+f∗k−1,k,j) 那么接下来考虑优化，在每次循环中只会用到 fk−1​ 中的数据，可以使用滚动数组的思想压缩数组，所以递推式可以简化为： f∗i,j=min(f∗i,j,f∗i,k+f∗k,j) 这样即可将空间复杂度优化到 O(n2) 。 代码 参考资料 最短路 - 图论 - OI Wiki 最短路问题 - 维基百科 戴克斯特拉算法 (Dijkstra 算法) - 维基百科 Floyd-Warshall 算法 - 维基百科 Bellman-ford 算法 - 维基百科 如何看待 SPFA 算法已死这种说法？ - immortalCO 的回答 - 知乎 0x61 最短路，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 9 月。 "},{"title":"第三届 “图灵杯” 趣味网络邀请赛","date":"2021-08-09T19:34:17.000Z","url":"/xjoi-3rd-turing-cup/","tags":["数学","数据结构","模拟","比赛","学军"],"categories":["题解"],"content":"题目结构 初级 A. 信友队 B. 蔚蓝 C. 括号匹配 D. 质数 中级 A. 括号匹配 B. 质数 C. 机器人 D. 欧拉回路 高级 A. 机器人 B. 欧拉回路 C. 划分 D. 正则表达式 信友队 时间限制：1000ms ，空间限制 512MB 题面 题目描述 欢迎参加图灵杯！ 集天下英才、育天下人，信友队已经培养出了非常多优秀的人才。 现在，信友队给了你三块 (2n+1)×(2n+1) 的网格画板，请你给每个格子填充黑色或白色，写下大大的 X,&nbsp;Y,&nbsp;D （信友队的三个首字母）！ 输入格式 一个正整数表示 n 。 输出格式 依次输出 3 个 (2n+1)×(2n+1) 的字母 X,&nbsp;Y,&nbsp;D ，相邻两个字母之间用一个空行隔开。 黑色字母用 + 表示，白色用空格表示。 思路 由于数据不大，直接模拟即可。 代码 打表版 时间复杂度 O(1) 模拟版 时间复杂度严格小于 O(n2) 。 蔚蓝 时间限制：1000ms ，空间限制：256MB 题面 题目描述 F 神打开了他的 Celeste，开始了快乐的跑酷。一旁的 L 神看到了，怀疑起 F 神的操作，认为他开了无敌挂和穿墙挂。 现在告诉你 F 神的行动路径和障碍，请你判断 F 神是否一定开了挂。 为了简化题意，人物抽象为点，你只需要判断输入的 n 个判定点是否和输入的 m 个矩形障碍重合（包括在矩形边缘）即可。 所有矩形障碍的边均平行于坐标轴，矩形有可能退化为线或点。 输入格式 第一行两个整数 n,m ，表示判定点数和障碍数。 接下来 n 行每行两个整数 xi​,yi​ ，表示第 i 个判定点的坐标。 接下来 行每行四个整数 lxi​,lyi​,rxi​,ryi​ ，表示第 i 个矩形障碍的左下角和右上角。 输出格式 一行一个字符串，若 F 神一定开了挂，输出 Yes ，否则输出 No 。 输入输出样例 输入样例 #1 输出样例 #1 输入样例 #2 输出样例 #2 数据范围与约定 本题采取 Subtask 评测的方式，对于所有数据保证 1≤n,m≤1000,&nbsp;1≤xi​,yi​,lxi​,lyi​,rxi​,ryi​≤109,&nbsp;xi​≤rxi​,&nbsp;lxi​≤rxi​,&nbsp;lyi​≤ryi​ 。 子任务编号 n,m≤ xi​,yi​,lxi​,lyi​,rxi​,ryi​≤ 分值 1 1 10 20 2 50 100 3 500 1000 4 1000 109 40 思路 先暂存所有经过的点，然后每输入一个矩形就遍历之前暂存的所有点，如果重合则直接输出 Yes 并退出程序，否则在程序末尾输出 No 。 代码 时间复杂度 O(nm) 括号匹配 时间限制：1000ms ，空间限制：256MB 题面 题目描述 众所周知，任何一个现代编辑器都有括号匹配功能。当你编辑代码的时候，把光标移到一个括号上，编辑器就会提示你与之对应的括号。小 F 想研究这个功能的原理。 为了简化问题，小 F 打算只研究代码中的大括号。去掉其它字符后，代码中只有 { （左大括号）和 } （右大括号）两种字符，总长度为 n 。 括号匹配的规则是： {} 是最简单的括号序列，其左右括号互相匹配； 如果 S 是一个括号序列，那么 {S} 也是一个括号序列，其左边的左括号和右边的右括号互相匹配； 如果 A,&nbsp;B 都是一个括号序列，那么 AB （将 A 和 B 直接拼接）也是一个括号序列。 小 F 现在打开了这份简化后的代码，他的光标正指向第 p 个字符（从 1 开始）。小 F 希望知道与这个字符相匹配的括号是第几个字符。 小 F 研究了三天三夜，还没研究出来。无奈之下，他请你给他写一个程序，完成这个功能。 输入格式 第一行两个整数 n,p ，表示程序的长度和光标的位置。 第二行一个字符串 s ，表示小 F 的程序。 输出格式 一行一个正整数，表示与之匹配的光标的位置。 输入输出样例 输入样例 #1 输出样例 #1 输入样例 #2 输出样例 #2 数据范围与约定 本题使用子任务评测方式。你的程序能够得到一个子任务的分数当且仅当你的程序通过了所有满足该子任务限制的数据点。 对于所有数据， 1≤≤105,&nbsp;1≤p≤n,&nbsp;∣s∣=n,&nbsp;si​∈{{}} 子任务编号 n≤ 分值 1 2 10 2 4 20 3 105 70 思路 使用一个栈存 { 在给定字符串中的位置，当遇到 { 时将位置入栈。 遇到 } 时如果光标与栈顶字符的位置相同则输出当前位置并退出程序，如果光标与当前位置相同则输出栈顶字符的位置并退出程序，均不符合则将栈顶出栈。 代码 时间复杂度为 O(n) 质数 时间限制：1000ms ，空间限制：512MB 题面 题目描述 输入一个正整数 a ，请你找出最小的质数 p ，使得 ap 和 pa 这两个正整数的（十进制）末位数字相同。如果不存在这样的质数，请输出 −1 。 一组输入中包含多个询问。 输入格式 第一行一个正整数 T ，表示询问数量。 接下来 T 行每行一个正整数 a 。 输出格式 对于每组数据输出一行答案。 输入输出样例 输入样例 #1 输出样例 #1 思路 先预处理出 106 内的质数，然后按照题意遍历计算即可，无解输出 -1 。 代码 机器人 题面 题目描述 一个机器人在数轴上移动，机器人所在的坐标始终为整数（可以是负数，零，或正数）。假设机器人当前在数轴上 x 点，当收到指令 (d,k) 后（其中 d 是整数， k 是正整数），机器人会移动到数轴上 (x+d) 点的位置，并获得 ∣2kx+kd∣ 的分数。 机器人初始时在数轴上的原点。现在给定了 n 个指令 ，机器人需要执行其中每一个指令恰好一次，但是执行指令的先后次序还没有确定。请你合理安排执行这些指令的顺序，使得机器人获得的总分数最大化。你只需要输出最大总分即可。 输入格式 第一行一个整数 n 表示指令的数量。 接下来 n 行每行两个正整数 di​,ki​ 表示一个指令。 输出格式 输出一个非负整数，表示最大积分。 输入输出样例 输入样例 #1 输出样例 #1 代码 后记 本次的比赛相比前两次的比赛来说难度有所降低，其他无感。 这次我 AK 了初级组，也算是意料之中了。 "},{"title":"洛谷 - P2412 查单词","date":"2021-07-04T15:32:22.000Z","url":"/luogu-p2412/","tags":["洛谷","线段树","字符串"],"categories":["题解"],"content":"题目信息卡题目名称提交地址洛谷 P2412题目难度普及/提高- 思路 题目大意：输出区间字典序最大的字符串，比对过程中大小写不敏感，但是输出必须输出原单词。 由题可得设计出的程序需要支持区间查询的操作，进而想到使用线段树（可以参考我的这篇博文：线段树学习笔记）。 这里有一个坑点（R52371435）：C++ 中字符顺序是按照 ASCII 码来比较的，如 A&nbsp;&lt;&nbsp;B&nbsp;&lt;&nbsp;a ，所以需要统一转换为大写或小写，转换后可以使用 std::map 存储字符对应关系。 之后按照正常线段树操作编写程序即可。 代码 评测记录 R52376877 - 洛谷 "},{"title":"S2OJ - 441. 记分牌","date":"2021-07-02T16:10:49.000Z","url":"/s2oj-441/","tags":["数学","S2OJ"],"categories":["题解"],"content":"题目信息卡题目名称记分牌提交地址S2OJ 441 题面 题目描述 比赛中记分牌上的得分数，由标有数字 0 ~ 9 的 10 类卡片组合而成，例如得分 225 由两张标有 2 的卡片和一张标有 5 的卡片组合而成。 然而，在一场比赛前，粗心的记分员只拿了包含 0 在内的 m 类卡片（假定每类卡片数目无限）。为了不延误比赛，记分员决定用这 m 类卡片表示比赛分数，表示规则为：按从小到大的顺序，用第 i 个能以这 m 类卡片表示的十进制数代表得分 i，其中 i≥0。例如，若所带卡片只有 {0,2,4,5} 四类，则可组合成的十进制数从小到大分别为 {0,2,4,5,20,22,24,25,40,42,44,…} ，依次分别对应于得分 {0,1,2,3,4,5,6,7,8,9,10,…} 。 当这 m 类卡片所组合成数字的位数很多时，记分员自己也不知道到底现在分数是多少，请你编写程序帮助他/她计算准确的得分。其次，比赛还有一个关键得分 s ，记分员还想知道得分为 s 时记分牌上的数字会是多少。 输入格式 第一行为正整数 m ，表示目前可用数字卡片的种类数。 第二行为 m 个各不相同的一位阿拉伯数字，以空格分隔，且其中肯定包含 0 。表示 m 种可用的卡片。 第三行为记分牌上的一个非负整数 x ，其所有数位均取自第二行给定的 m 个数字，且最高位非 0 。 第四行为一个非负整数 s ，你需要输出对应记分牌上的数字。 输出格式 两行，第一行为十进制非负整数，对应于 x 所表示的十进制得分。 第二行为一个非负整数，表示了分数为 s 时对应的记分牌上的数字，保证此项输出不超过 2147483647 。 输入输出样例 输入样例 #1 输出样例 # 1 7 27 样例说明 #1 所给卡片从小到大排列为 {0,2,4,7,20,22,24,27,…} ，对应得分为 {0,1,2,3,4,5,6,7,…} 。 所以记分牌数字 27 对应得分为 7 ，得分 7 对应记分牌数字为 27 。 数据规模与约定 对于 20% 的数据，m≤3 ； 对于 40% 的数据，x≤32767 ， s≤32767 ； 对于 100% 的数据，2≤m≤10 ， x≤2147483647 。 思路 观察样例可知，卡片的排列可以看作是 m 进制与 10 进制间的转换。 记分牌进制数024720222427​⟷⟷⟷⟷⟷⟷⟷⟷⟷…​m&nbsp;进制数012310111213​⟷⟷⟷⟷⟷⟷⟷⟷⟷​10&nbsp;进制数01234567​ 故可以使用 std::map 来实现从记分牌与 m 进制数之间的转换。 将读入的卡片先排序，然后建立映射： 此处 m1 是从 m 进制到 「记分牌进制」 的转换， m2 是从 「记分牌进制」 到 m 进制的转换。 先将读入的 x 转为 m 进制数： 再将这个 m 进制数转为 10 进制数： 综合起来，就是下面这样： 之后输出 ans1 即可。 同样地，对 s 的处理就是一个逆向过程。 先将读入的 s 转换为 m 进制数，再将这个 m 进制数转换为 「记分牌进制」 数，合并以后就是这样： 之后输出 ans2 即可。 代码 提交记录 #12569 - S2OJ "},{"title":"S2OJ - 438. bamboo","date":"2021-07-01T17:51:50.000Z","url":"/s2oj-438/","tags":["S2OJ","最短路"],"categories":["题解"],"content":"题目信息卡题目名称bamboo提交地址S2OJ 438 题面 题目描述 话说茅山道士散功重修已足足九九八十一天，这天子时，月上中天，道观前清辉点点。 只听得訇然一声，闭关之处整个炸裂开来，烟雾散尽后，只见茅山道士纤尘不染地立于瓦砾之中，抬头望月，面上一片悲悯之色，喃喃道：「孽缘啊……」 果不其然，一名黑衣剑客从旁窜出，剑尖遥遥指向茅山道士，大喝道：「茅山妖道，我已在此等你多时，多年来的恩恩怨怨，就此了断吧！」 言不及毕，左手捏了一个剑诀，便欺身上前，直攻茅山下盘。 茅山道士看着黑衣剑客有些稚嫩的剑法，眼中掠过复杂的神色：「不如我们换个地方吧，你若能追得上我，我再和你大战一场！」 说完向后纵身一跃，就此隐入竹林之中不知所踪。 黑衣剑客知道茅山是个念旧的人，这次必然是要到竹林中的一处隐秘所在。但黑衣剑客的轻功并不高明，每次只能从一棵竹子顶端跳到水平距离不超过 r ，高度差不超过 d 的另一棵竹子顶端，所花的时间为两个顶点间的直线距离除以 v。 你能帮助黑衣剑客以最快的速度追上茅山道士么？ 输入格式 第一行是四个整数 n、r、d、v，表示竹子的数目、最大水平跳跃距离、最大竖直跳跃距离以及黑衣剑客飞行的速度。 接下来 n 行每行三个整数 x、y、h，表示每棵竹子的坐标及高度，高度大于 0 。 你可以假定起点在 1 ，终点在 n 。同一坐标可能有不同竹子。 输出格式 输出一行为从 1 到 n 的最短时间。保留小数点后三位输出。如果无法到达终点则输出 No Solution 。 输入输出样例 输入样例 #1 输出样例 #1 数据规模与约定 输入的所有数据均为不超过 1000 的非负整数。 思路 要点总结 本题实质是求加权无向图的最短路径。 本题主要代码均与速度无关，因此程序只需在输出时计算时间。 需要先计算各个互相可达的点之间的路程，再求从 1 号竹子到 n 号竹子的最短路径。 计算可达性与路程 由题知计算可达性需要两个条件： 水平距离不超过 r 高度差不超过 d d=(Δx)2+(Δy)2​=(x1​−x2​)2+(y1​−y2​)2​ 可以根据 同一平面上两点间的距离公式 写出求同一平面上两点间的距离的函数： 然后判断黑衣剑客是否能跳到那棵竹子上： 判断条件为 s水平​≤r 且 s垂直​≤d 。 d=(Δx)2+(Δy)2+(Δz)2​=(x1​−x2​)2+(y1​−y2​)2+(z1​−z2​)2​ 同样也可以根据 三维空间中两点间的距离公式 写出求三维空间中两点间的距离的函数： 然后直接向邻接表中存入数据即可。 求解最短路 由于时限比较宽松，所以此处选用代码难度较低的 Floyd 算法。 首先需要初始化，初始化需要放在路程计算前。 之后使用 Floyd 算法求解最短路即可： 最后输出从 1 到 n 的最短路径长度时需要特判无解的情况并输出 No Solution 。 代码 提交记录 #12492 - S2OJ "},{"title":"洛谷 - P2234 [HNOI2002] 营业额统计","date":"2021-01-03T19:25:00.000Z","url":"/luogu-p2234/","tags":["数学","洛谷"],"categories":["题解"],"content":"题目信息卡题目名称营业额统计提交地址洛谷 P2234LibreOJ 10143AcWing 265题目难度提高+/省选-题目来源HNOI2002 题面 题目描述 Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。 Tiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：当最小波动值越大时，就说明营业情况越不稳定。 而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。 第一天的最小波动值为第一天的营业额。 该天的最小波动值=min(∣该天以前某一天的营业额−该天营业额∣) 。 输入格式 第一行为正整数 n（n≤32767） ，表示该公司从成立一直到现在的天数，接下来的 n 行每行有一个整数 ai​ (∣ai​∣≤1000000) ，表示第 i 天公司的营业额，可能存在负数。 输出格式 一个正整数，表示 ∑每一天的最小波动值 ，数据保证结果小于 231 。 输入输出样例 输入样例 #1 输出样例 #1 样例说明 #1 ==​&nbsp;5+∣1−5∣+∣2−1∣+∣5−5∣+∣4−5∣+∣6−5∣&nbsp;5+4+1+0+1+1&nbsp;12​ 思路 由 该天的最小波动值=min(∣该天以前某一天的营业额−该天营业额∣) 可以判断出当前波动值与前面有关，设当天营业额为 x ，则需要查找到某一天营业额 y 满足 ∣y−x∣ 最小。 接着想到二分查找，使用 STL 库函数 lower_bound 和 upper_bound 即可完成。 二分查找需要保证数组有序，所以边读入边处理既能保证数组有序，又可以简单地查询出该天的最小波动值。 为了防止越界，开始前先向 a 中 push_back 一个满足要求的\"极小值\" −1061109568 。 时间复杂度： O(nlog2​n) 。 代码 提交详情：R44587104 参考资料 std::lower_bound - cppreference std::upper_bound - cppreference "},{"title":"S2OJ - 217. QQ空间的说说","date":"2021-01-02T16:52:45.000Z","url":"/s2oj-217/","tags":["数学","S2OJ"],"categories":["题解"],"content":"题目信息卡题目名称QQ空间的说说提交地址S2OJ 217 题面 题目链接：S2OJ - #217 QQ 空间的说说 难度：暂无评定 题目背景 You-Know-Who 是一名有时候很菜的 OIer，有时候会颓废去刷 QQ 空间。 一天，他看到了这样的一条说说《最近很火的 ABO 性别测试。我是男 O，你们呢？》。内容是这样的： 反正 You-Know-Who 才不会相信这些假假的东西，于是他每次都是随机地选择一个选项，然后跳到对应的题目，继续随机地选择，直到选择出一个测试结果为止。 题目描述 我们形式化地定义一下这样类型的测试： 测试总共有 n 道题； 第 i 题有 mi​ 个选项； 第 i 题的第 j 个选项，要么是一个数字 x 要么是一个大写英文字母 α，表示你如果选择了这个选项，你将得到测试结果 α，结束测试。 Steaunk 想知道对于一个给定的形如上面描述的测试，如果 You-Know-Who 一开始从第一道题开始作答，每次都是等概率随机地选择其中一个选项，然后执行对应的操作，直到得到一个大写英文字母 α 表示的测试结果，结束测试，那么对于 A∼Z 中的每一个测试结果被选中的概率是多少？ 输入格式 第一行共一个正整数 n，表示题目的数量。 接下来有 n 行，每行第一个正整数 mi​ 表示第 i 道题有 mi​ 个选项； 接着有 mi​ 个由空格分开的字符串，表示选项； 这个字符串要么可以表示为一个正整数 x，满足 i &lt; x \\le n，表示选择这个选项你会跳转到第 x 题继续作答； 要么是一个大写英文字母 α，表示选择这个选项，你得到测试结果 α，结束测试。 输出格式 一行共 26 个非负整数，分别表示 A∼Z 型被选中的概率，模 998244353 后的值。 提示：(x,p)=1,xp−1≡1(modp)。 输入输出样例 输入样例#1 输出样例#1 样例说明#1 显然 You-Know-Who 有 21​ 的概率得到测试结果 A，21​ 的概率得到测试结果 B，测试结果 C∼Z 都不可能得到。 数据规模与约定 对于 100% 的数据：n≤5×106,∑i=1n​mi​≤107 时间限制：2s 空间限制：256MB 思路 记从第 1 题开始作答，跳转到某一题目 x 的概率为 P(x)，跳转到某一答案 α 的概率为 P(α)。 很容易可以得出一个初始条件 P(1)=1。 所求的答案即为 P(A),P(B),P(C),…,P(Z) 。 如果对于题目 i ，设它能跳转到题目或答案 x1​,x2​,x3​,…,xmi​​，那么可以推出一个递推式：P(xj​)←P(xj​)+mi​p(i)​ ，之后按照该式递推即可。 坑点：概率 和 到达次数总和各点到达次数​ 是不一样的，要把出发点概率乘上选项的数量，并分配到每一个终点（考场上我因为不知道这个写炸了）。 代码 "},{"title":"洛谷 - P3879 [TJOI2010] 阅读理解","date":"2020-12-30T19:26:51.000Z","url":"/luogu-p3879/","tags":["洛谷","字符串"],"categories":["题解"],"content":"题目信息卡题目名称阅读理解提交地址洛谷 P3879题目难度提高+/省选-题目来源TJOI2010 题面 难度：提高+/省选- 标签：字符串 哈希 概率论,统计 字典树,Trie 树 各省省选 天津 高性能 2010 题目描述 英语老师留了 N 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。 输入格式 第一行为整数 N ，表示短文篇数，其中每篇短文只含空格和小写字母。 按下来的 N 行，每行描述一篇短文。每行的开头是一个整数 L ，表示这篇短文由 L 个单词组成。接下来是 L 个单词，单词之间用一个空格分隔。 然后为一个整数 M ，表示要做几次询问。后面有 M 行，每行表示一个要统计的生词。 输出格式 对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。 输入输出样例 输入 #1 输出 #1 说明 对于 30% 的数据， 1≤M≤103 。 对于 100% 的数据，1≤M≤104，1≤N≤103 。 每篇短文长度（含相邻单词之间的空格）≤5×103 字符，每个单词长度 ≤20 字符。 每个测试点时限 2 秒。 思路 开一个 map 来存单词与文章之间的对应关系，使用 set 去重。 每次检索的时候先使用 m.count(s)[1] 判断是否存在该单词（防止创建无用元素浪费内存），如果不存在就输出空行。 一些坑点： 输出时行尾如果有多余空格会 WA 。 判断是否为末尾的前一个数时不能用 it + 1 != m[s].end() ，应该用 it != --m[s].end() ，否则会报错 no match for 'operator+' (operand types are 'std::set&lt;int&gt;::iterator' {aka 'std::_Rb_tree_const_iterator&lt;int&gt;'} and 'int')。 速度优化 可以将 map 替换为 unordered_map ，速度快了许多（1057ms -&gt; 593ms） 在 cppreference.com 上可以查到： unordered_map 的时间复杂度平均情况下为常数，最坏情况下则与大小成线性[2][3]；map 的时间复杂度与容器大小成对数[4][5]。 可以使用更快的输入输出方式，如 scanf printf 或自己的快读快写。 代码 也可在 GitHub 上查看最新更新。 参考资料 [1] std::map&lt;Key,T,Compare,Allocator&gt;::count - cppreference [2] std::unordered_map&lt;Key,T,Hash,KeyEqual,Allocator&gt;::operator[] - cppreference [3] std::unordered_map&lt;Key,T,Hash,KeyEqual,Allocator&gt;::count - cppreference [4] std::map&lt;Key,T,Compare,Allocator&gt;::operator[] - cppreference [5] std::map&lt;Key,T,Compare,Allocator&gt;::count - cppreference "},{"title":"NOIP 2020 题解","date":"2020-12-05T17:30:03.000Z","url":"/noip-2020/","tags":["数学","NOIP","搜索"],"categories":["题解"],"content":"排水系统（water） 题目描述 对于一个城市来说，排水系统是极其重要的一个部分。 有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 n 个排水结点（它们从 1∼n 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。 排水系统的结点中有 m 个污水接收口，它们的编号分别为 1,2,…,m，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。 现在各个污水接收口分别都接收了 1 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。 现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。 输入格式 第一个两个用单个空格分隔的整数 n,m。分别表示排水结点数与接收口数量。 接下来 n 行，第 i 行用于描述结点 i 的所有排出管道。其中每行第一个整数 di​ 表示其排出管道的数量，接下来 di​ 个用单个空格分隔的整数 a1​,a2​,…,adi​​ 依次表示管道的目标排水结点。 保证不会出现两条起始结点与目标结点均相同的管道。 输出格式 输出若干行，按照编号从小到大的顺序，给出每个最终排水口排出的污水体积。其中体积使用分数形式进行输出，即每行输出两个用单个空格分隔的整数 p，q，表示排出的污水体积为 qp​。要求 p 与 q 互素，q=1 时也需要输出 q。 输入输出样例 输入 输出 解释 1 号结点是接收口，4,5 号结点没有排出管道，因此是最终排水口。 1 吨污水流入 1 号结点后，均等地流向 2,3,5 号结点，三个结点各流入 31​ 吨污水。 2 号结点流入的 31​ 吨污水将均等地流向 4,5 号结点，两结点各流入 61​ 吨污水。 3 号结点流入的 31​ 吨污水将均等地流向 4,5 号结点，两结点各流入 61​ 吨污水。 最终，4 号结点排出 61​+61​=31​ 吨污水，5 号结点排出 31​+61​+61​=32​ 吨污水。 数据范围 测试点编号 n≤ m≤ 1∼3 10 1 4∼6 103 7∼8 105 9∼10 10 对于全部的测试点，保证 1≤n≤105，1≤m≤10，0≤di​≤5。 数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 10 个中间排水结点（即接收口和最终排水口不算在内）。 思路 从 1∼m 节点开始向下搜索，如果搜到没有排水口的节点就更新节点的 ans 。 ▲ 样例 1 的搜索过程 需要注意的分子和分母需要单独存，不能使用浮点型存储，否则会有精度问题。 在均分的时候只需要将分母除以节点数即可，如下方所示： ===​32​÷432​×41​3×42​122​=​61​​ 在相加的时候可以这样做： ====​32​+43​3×42×4​+3×43×3​3×42×4+3×4​1220​35​​ 赛场 AC 用时：1 小时。 别忘了开 long long 。 代码 考场代码：OI题库100分，洛谷90分，官方数据80分 AC 代码 考后第二天就用 __int128 水过了这道题（懒得打高精）。 使用流输出 __int128 的时候还糊了个输出函数（因为没内置）。 "},{"title":"线段树学习笔记","date":"2020-12-02T08:08:39.000Z","url":"/segment-tree/","tags":["数据结构","线段树"],"categories":["笔记"],"content":"线段树（Segment Tree）是一种用来维护区间的数据结构。 与树状数组相比，线段树可以实现时间复杂度在 O(logn) 级别的区间修改，还可以同时支持多种操作（加、乘、最值等）。 操作列表 上传（pushup） 建树（build） 下放懒标记（pushdown） 区间查询（query） 区间修改（modify） 通用操作 存储线段树 线段树是一个典型的二叉树，因此我们可以使用一个数组来存储线段树。 分析：很容易就知道线段树的深度为 ⌈logn⌉ ，可得线段树的节点个数为 2⌈logn⌉+1−1，粗略估计开大小为 4n 的数组即可（可以使用位运算写成 n &lt;&lt; 2）。 变量名 用途 l 区间的左端点 r 区间的右端点 s 区间和 d 懒标记 上传（pushup） 之所以把上传放在建树前面说，是因为建树的时候要用到它。 将两个子节点所代表的区间的和相加即为父区间的和。 建树（build） 先初始化当前区间，接下来分两种情况： 若当前区间长度等于 1&nbsp;&nbsp;(l=r) ，则直接将当前区间的区间和赋值为 a[l] 即可。 若当前区间长度大于 1&nbsp;&nbsp;(l&lt;r) ，则将区间平均分成两部分（即从 ⌊(l+r)/2⌋ 处断开分为两个区间，可写作 l + r &gt;&gt; 1），继续向下递归建立左右子树即可。 需要注意的是两个子区间没有交集，因此左子树的左端点是 l 、右端点是 mid ，右子树的左端点是 mid+1 、右端点是 r 。 区间查询（query） 如果这个区间被包含，直接返回该区间的和。 如果和左儿子区间有交集，则继续向左儿子区间递归查询。 如果和右儿子区间有交集，则继续向右儿子区间递归查询。 需要注意的是在递归查询左右儿子区间之前要先下放懒标记（pushdown），否则会出问题。 区间加 本部分以 洛谷 P3372 【模板】线段树 1 为例子来简述一下线段树区间加的实现。 下放懒标记（pushdown） 这部分代码其实很简单。 将左、右子树的懒标记加上父节点的懒标记，区间和加上 (r−l+1)×d （r,l 分别表示儿子区间的左、右端点，d表示父节点的懒标记），最后清空父节点的懒标记即可。 区间修改（modify） 区间修改和区间查询的实现相似。 如果当前区间被包含，直接添加懒标记并修改区间和。 如果和左儿子区间有交集，则继续向左儿子区间递归修改。 如果和右儿子区间有交集，则继续向右儿子区间递归修改。 需要注意的是在递归修改左右儿子区间之前要先下放懒标记（pushdown），修改完成以后要上传新信息（pushup），否则会出问题。 区间加、乘 本部分以 洛谷 P3373 【模板】线段树 2 为例子来简述一下线段树区间加、乘的实现。 在编写之前，结构体中需要先添加一个乘法的懒标记 x ，并将其赋初值为 1 ，修改之后的结构体如下所示。 下放懒标记（pushdown） 此处遵循先乘后加的原则，先修改区间和，再修改乘法懒标记，最后修改加法懒标记，不要忘记 mod&nbsp;p。 注意：此处清除懒标记的时候，乘法懒标记应修改为 1 。 区间修改（modify） 大体上和加法的修改函数一样，而在修改时与下放懒标记做法相同，遵循先乘后加的原则。 调用的时候若只需要使用乘法部分，加数设置为 0 即可。若只需要使用加法部分，乘数设置为 1 即可。 全部代码 到这里基本操作就说完了，下面是全部的 AC 代码。 区间加 区间加、乘 "},{"title":"CSP-J 2020 题解","date":"2020-11-16T17:24:54.000Z","url":"/csp-j-2020/","tags":["动态规划","模拟","NOIP","比赛","搜索"],"categories":["题解"],"content":"优秀的拆分 题目信息卡题目名称提交地址洛谷 P7071AcWing 2767CCF CSPJ2020A @ Hydro题目难度普及-题目来源CSP-J 2020 前置知识：位运算。 题面 题目描述 一般来说，一个正整数可以拆分成若干个正整数的和。 例如，1=1，10=1+2+3+4 等。对于正整数 n 的一种特定拆分，我们称它为\"优秀的\"，当且仅当在这种拆分下，n 被分解为了若干个不同的 2 的正整数次幂。注意，一个数 x 能被表示成 2 的正整数次幂，当且仅当 x 能通过正整数个 2 相乘在一起得到。 例如，10=8+2=23+21 是一个优秀的拆分。但是，7=4+2+1=22+21+20 就不是一个优秀的拆分，因为 1 不是 2 的正整数次幂。 现在，给定正整数 n，你需要判断这个数的所有拆分中，是否存在优秀的拆分。若存在，请你给出具体的拆分方案。 输入格式 输入只有一行，一个整数 n，代表需要判断的数。 输出格式 如果这个数的所有拆分中，存在优秀的拆分。那么，你需要从大到小输出这个拆分中的每一个数，相邻两个数之间用一个空格隔开。可以证明，在规定了拆分数字的顺序后，该拆分方案是唯一的。 若不存在优秀的拆分，输出 -1。 思路 首先，如果 n 是奇数，那么肯定不可能拆分成若干个不同的 2 的正整数次幂。 以 11 的拆分结果 11=23+21+20 为例，可以看到结果里面存在一个 2 的 0 次幂。 所以当 n 是奇数时不存在优秀的拆分，输出 −1 即可。 将 1 左移 n 位（1&lt;&lt;n）和 2n 是等效的。同理，将 1 右移 n 位（1&gt;&gt;n）等同于 1÷2n 。取 x 的二进制第 i 位可以写成 x &gt;&gt; i &amp; 1 。 我们观察一下 10 转换成二进制后的结果：(1010)2​，再将它转换成十进制的式子列出来： (1010)2​​=1×23+0×22+1×21+0×20=23+21=8+2=10​ 再看下数据范围，24 次幂就足够了。 代码 直播获奖 题目信息卡题目名称提交地址洛谷 P7072AcWing 2768CCF CSPJ2020B @ Hydro题目难度普及-题目来源CSP-J 2020 题面 题目描述 NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 w%，即当前排名前 w% 的选手的最低成绩就是即时的分数线。 更具体地，若当前已评出了 p 个选手的成绩，则当前计划获奖人数为 max(1,⌊p∗w%⌋)，其中 w 是获奖百分比，⌊x⌋ 表示对 x 向下取整，max(x,y) 表示 x 和 y 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。 作为评测组的技术人员，请你帮 CCF 写一个直播程序。 输入输出格式 输入格式 第一行有两个整数 n,w。分别代表选手总数与获奖率。 第二行有 n 个整数，依次代表逐一评出的选手成绩。 输出格式 只有一行，包含 n 个非负整数，依次代表选手成绩逐一评出后，即时的获奖分数线。相邻两个整数间用一个空格分隔。 思路 每读入一个数，使用二分插入到 vector 中，然后按照题意输出即可。 注意：score 数组内成绩是由小到大排列的，所以输出的时候要使用 score.size() - max(1, i * w / 100) 作为下标。 代码 方格取数 题目信息卡题目名称提交地址洛谷 P7074AcWing 2770CCF CSPJ2020D @ Hydro题目难度普及/提高-题目来源CSP-J2020 题面 题目描述 设有 n×m 的方格图，每个方格中都有一个整数。现有一只小熊，想从图的左上角走到右下角，每一步只能向上、向下或向右走一格，并且不能重复经过已经走过的方格，也不能走出边界。小熊会取走所有经过的方格中的整数，求它能取到的整数之和的最大值。 输入输出格式 输入格式 第一行有两个整数 n,m。 接下来 n 行每行 m 个整数，依次代表每个方格中的整数。 输出格式 一个整数，表示小熊能取到的整数之和的最大值。 思路 设 Fi,j,0​ 表示从一个格子上方走到该格子的路径最大和，Fi,j,1​ 表示从一个格子下方走到该格子的路径最大和。 若搜到以前搜过的状态则直接返回搜过的最大和（也就是 F 中的值），否则继续搜索到达该格时的最大和。 代码 "},{"title":"牛客网 - 7612. 2020 牛客 NOIP 赛前集训营 - 普及组（第五场）","date":"2020-10-29T19:52:19.000Z","url":"/nowcoder-contest-7612/","tags":["数学","模拟","比赛","字符串","牛客网"],"categories":["题解"],"content":"比赛链接： A-购物 题面 题目描述 超市进行了买 k 送一的活动，商品的单价是 x 元，牛妹想至少买 n 件商品， 输出最少需要花费多少钱。 输入描述 第一行一个整数 T≤100，表示 T 组数据。 接下来 T 行，每行 3 个整数 n,k,x(1≤n,x≤1000,1≤k≤100) 输出描述 对于每组数据输出一行表示答案。 样例 样例输入 #1 样例输出 #1 思路 签到题，模拟即可。 代码 B-交换 题面 题目描述 给一个长度为 n 的 01 序列 s1​,s2​,....,sn​，现在可以至多进行 1 次如下操作： 选择 1≤x&lt;n，将 s 序列变成 {sx+1​,sx+2​,.....,sn​,s1​,s2​,....sx​} 输出最长的全为 1 的子区间长度。 输入描述 一个 01 字符串，表示序列 s。(1≤∣s∣≤100000) 输出描述 输出一个整数表示答案。 样例 样例输入 #1 样例输出 #1 样例输入 #2 样例输出 #2 样例输入 #3 样例输出 #3 思路 给定的字符串首尾相接就会成一个环，那么可以破环成列，在 s 的末尾在添加一个 s，以样例 10111010 为例，处理过后则变成了 1011101010111010，那么这样就可以找出最长的全为 1 的子区间长度。 注意当给定的字符串全为 1 时，有可能会出现 fi​≥n 的情况，按照题意， fi​≤n ，所以当 si​ 为 '1' 时，递推式为 fi​=min(fi−1​+1,n) 。 最终的答案就是 max({f1​,f2​,...,fn​}) 代码 C-最少移动 题面 题目描述 给一个长度为 n 的正整数序列 {a1​,a2​,...,an​}，每次操作可以选择两个相邻的位置，让一个元素 −1 另一个元素 +1，输出最少几次操作，能让所有元素相等，如果不可能实现，请输出 -1。 输入描述 第一行一个整数 T(T≤20)，表示 T 组数据。 每组数据第一行一个整数 n，第二行 n 个数字表示 a 序列，1≤ai​≤100000 输出描述 对于每组数据，输出一个整数表示答案。 样例 样例输入 #1 样例输出 #1 思路 这道题可以用前缀和做。 asum​={1,2,3,1,3}={1,3,6,7,10}​ ai​ 为序列元素， sumi​ 为前缀和元素。 不难发现，当 ai​+1,ai+1​−1 时，sumi​=sumi​+1 ，而 sumi​+1 不变。 同理，当 ai​−1,ai+1​+1 时，sumi​=sumi​−1 ，而 sumi​+1 仍不变。 当 a 中所有元素相等时，sum 一定是一个等差数列。 举个例子： asum​={2,2,2,2,2}={2,4,6,8,10}​ 所以可以得到结论：当 fn​modn=0 时， sum 中的元素不可能成等差数列，因此 a 中的元素不可能相等，无解。 反之则有解。 由上方发现的规律可知：在变换过程中，sumn​ 总是不变的，因此可以自后向前逆推：设公差为g，则 fi​=fi+1​−g(0&lt;i&lt;n)，所以将 fi​ 变成 fi+1​−g 所需的步数为 abs(i∗g−fi​)。 提示：此题必须开 long long！ 代码 D-飞行棋 题面 题目描述 牛牛在玩飞行棋。 有无限个格子排成一行，从左到右，标号为 0,1,....,n,......,∞ 终点为 0 ，有一架飞机一开始在 n 号位置。 排骨龙每回合可以先投掷一次 d 面的骰子，1 到 d 等概率出现。 投出点数 x 后，飞机会移动 x 步，每步移动一格，方向初始向左移动，若到达终点，会向右移动。 若投出的点数为 d 点，可以继续投掷，直到投出的点数不是 d 点。 求让这架飞机停在终点回合数的期望。 输入描述 第一行一个数字 T 表示 T (T≤100) 组数据。 接下来每行两个正整数 n,d(2≤d,n≤100000) 输出描述 输出 T 行，每行保留两位小数输出答案。 样例 样例输入 #1 样例输出 #1 思路 设 fx​ 为从 x 走到 1 的 步数。 当 x≥d 时，fx​=∑i=1d​ddpx−i​​ 当 x&lt;d 时， 期望为 d−1 。 来源：2020 牛客 NOIP 赛前集训营-普及组（第五场）题解 代码 "},{"title":"Codeforces - 1433A Boring Apartments","date":"2020-10-22T16:36:23.000Z","url":"/codeforces-1433a/","tags":["Codeforces","模拟"],"categories":["题解"],"content":"题目信息卡题目名称Boring Apartments提交地址Codeforces 1433A洛谷 CF1433A题目难度入门题目来源Codeforces Round #677 (Div. 3) 题面 题目描述 我们把仅由一个或多个相同的数位组成的数字叫作「无聊的数字」。我们把 ≤10000 的这种数按照以下规则排列： 首先，将仅由 1 组成的 ≤10000 的「无聊的数字」按照升序排列：1,11,111,1111,…。 再将仅由 2 组成的 ≤10000 的「无聊的数字」按照升序排列：2,22,222,2222,…。 以此类推。 给出 t 次询问，每次询问给定一个无聊的数字 x，请求出当数列排到 x 时，x 以及前面所有的“无聊的数字”的位数之和。 输入输出样例 样例输入 #1 样例输出 #1 数据范围与约定 对于 100% 的数据，1≤t≤36,1≤x≤9999。 思路 先手算一下，可以找出规律： (nummod10)−1 是结果的十位上的数字。 数字长度为 i 时，个位上的数字就是 1+2+3+...+i 。 可以得到如下代码： 代码 打表版 Codeforces 提交记录 非打表版 洛谷提交记录 Codeforces 提交记录 "},{"title":"牛客网 - 7606. 2020 牛客 NOIP 赛前集训营 - 普及组（第二场）","date":"2020-10-20T22:35:21.000Z","url":"/nowcoder-contest-7606/","tags":["数学","模拟","比赛","牛客网"],"categories":["题解"],"content":"A-面试 提交记录：45258014 思路 统计 A B C D 四个字母的出现次数。 根据题目中所描述的内容： 如果面试者在四轮中有一次发挥被评为 D，或者两次发挥被评为 C，就不会通过面试。如果面试者没有一次被评为 D，并且有三个或以上的 A，则会获得 special offer。其余情况会获得普通 offer。 可以写出如下代码 代码 B-纸牌游戏 提交记录：45267496 代码 参考资料 7606B 纸牌游戏题解 - wzkdh 的牛客博客 C-涨薪 提交记录： 45259535 思路 分析 当 m≥2 时，会有 n−(x+y) 名员工被辞退，需要计算以下内容： {ai​×3mai​×2m​(0≤i&lt;x)(x≤i&lt;x+y)​ 当 m=1 时，没有员工被开除，需要计算以下内容： ⎩⎨⎧​ai​×3ai​×2ai​​(0≤i&lt;x)(x≤i&lt;x+y)(x+y≤i&lt;n)​ 如果纯暴力的话复杂度是 O(nm) 所以用快速幂优化下，就变成了 O(nlogm) 的复杂度。 代码模板 快速幂板子（带 mod 版本）： 代码 参考资料 模意义下取幂 - 快速幂 - OI Wiki D-变换 这道题没做出来，比赛结束后官方题解没看懂，待填坑。 "},{"title":"洛谷 - P1724 东风谷早苗","date":"2020-10-04T16:16:41.000Z","url":"/luogu-p1724/","tags":["洛谷","字符串"],"categories":["题解"],"content":"题目信息卡题目名称东风谷早苗提交地址洛谷 P1724题目难度普及- 题面 难度：普及- 标签：模拟 字符串 题目描述 在幻想乡，东风谷早苗是以高达控闻名的高中生宅巫女。某一天，早苗终于入手了最新款的钢达姆模型。作为最新的钢达姆，当然有了与以往不同的功能了，那就是它能够自动行走。 早苗的新模型可以按照输入的命令进行移动，命令包含 E S W N 四种，分别对应四个不同的方向，依次为东、南、西、北。执行某个命令时，它会向着对应方向移动一个单位。作为新型机器人，模型自然不会只单单执行一个命令，它可以执行命令串。对于输入的命令串，每一秒它会按照命令行动一次。而执行完命令串最后一个命令后，会自动从头开始循环。在 0 秒时早苗将钢达姆放置在了 (0,0) 的位置，并且输入了命令串。 向东移动，坐标改变改变为 (x+1,&nbsp;y) 向南移动，坐标改变改变为 (x,&nbsp;y−1) 向西移动，坐标改变改变为 (x−1,&nbsp;y) 向北移动，坐标改变改变为 (x,&nbsp;y+1) 现在她想要知道 T 秒后钢达姆所在的位置坐标。 输入格式 第 1 行：一个字符串，表示早苗输入的命令串，保证至少有 1 个命令。 第 2 行：一个正整数 T 。 输出格式 第 1 行：两个整数，表示 T 秒时，钢达姆的坐标。 输入输出样例 输入 #1 输出 #1 思路 60 分 按照题意模拟即可 100 分 由于题目数据范围过大，单纯模拟无法通过此题，所以需要寻找一些规律。 而执行完命令串最后一个命令后，会自动从头开始循环。 通过仔细读题可以发现，在运行中命令串可能会被执行多次，因此可以先算出命令串被执行了几次，再模拟出最终结果。 代码 60 分 纯暴力做法 100 分 "},{"title":"洛谷 - P4994 终于结束的起点","date":"2020-10-03T03:44:01.000Z","url":"/luogu-p4994/","tags":["数学","洛谷","斐波那契"],"categories":["题解"],"content":"题目信息卡题目名称终于结束的起点提交地址洛谷 P4994题目难度普及- 题面 题目描述 广为人知的斐波拉契数列 fib(n) 是这么计算的： fib(n)=⎩⎨⎧​0,1,fib(n−1)+fib(n−2),​n=0n=1n&gt;1​ 也就是 0,1,1,2,3,5,8,13,…，每一项都是前两项之和。 小 F 发现，如果把斐波拉契数列的每一项对任意大于 1 的正整数 M 取模的时候，数列都会产生循环。 当然，小 F 很快就明白了，因为 (fib(n−1)modM) 和 (fib(n−2)modM) 最多只有 M2 种取值，所以在 M2 次计算后一定出现过循环。 甚至更一般地，我们可以证明，无论取什么模数 M，最终模 M 下的斐波拉契数列都会是 0,1,⋯,0,1,⋯。 现在，给你一个模数 M，请你求出最小的 n&gt;0，使得 fib(n)modM=0,fib(n+1)modM=1。 输入格式 输入一行一个正整数 M 。 输出格式 输出一行一个正整数 n 。 输入输出样例 输入 #1 输出 #1 输入 #2 输出 #2 思路 暴力+优化 = AC 代码 "},{"title":"洛谷 - P5738 歌唱比赛","date":"2020-09-22T19:46:59.000Z","url":"/luogu-p5738/","tags":["模拟","洛谷"],"categories":["题解"],"content":"题目信息卡题目名称歌唱比赛提交地址洛谷 P5738题目难度普及- 题面 题目描述 n(n≤100) 名同学参加歌唱比赛，并接受 m(m≤20) 名评委的评分，评分范围是 0 到 10 分。这名同学的得分就是这些评委给分中去掉一个最高分，去掉一个最低分，剩下 m−2 个评分的平均数。请问得分最高的同学分数是多少？评分保留 2 位小数。 输入格式 无 输出格式 无 输入输出样例 输入#1 输出#1 思路 首先定义一个结构体，里面存放各个评委给出的分数、总分数和平均分。 然后写一个初始化函数： 再写一个处理函数： 这个处理函数分为了三部分：读入、排序和按题目要求计算平均分。 代码 "},{"title":"洛谷 - P5660 数字游戏","date":"2020-09-13T18:16:55.000Z","url":"/luogu-p5660/","tags":["模拟","NOIP","洛谷"],"categories":["题解"],"content":"题目信息卡题目名称数字游戏提交地址洛谷 P5660题目难度入门题目来源CSP-J 2019 题面 题目描述 小 K 同学向小 P 同学发送了一个长度为 8 的 01 字符串来玩数字游戏，小 P 同学想要知道字符串中究竟有多少个 1。 注意：01 字符串为每一个字符是 0 或者 1 的字符串，如\"101\"（不含双引号）为一个长度为 3 的 01 字符串。 输入格式 输入文件只有一行，一个长度为 8 的 01 字符串 s。 输出格式 输出文件只有一行，包含一个整数，即 01 字符串中字符 1 的个数。 输入输出样例 输入 #1 输出 #1 输入 #2 输出 #2 说明 【输入输出样例 1 说明】 该 01 字符串中有 2 个字符 1。 【输入输出样例 2 说明】 该 01 字符串中有 8 个字符 1。 【数据规模与约定】 对于 20% 的数据，保证输入的字符全部为 0。 对于 100% 的数据，输入只可能包含字符 0 和字符 1，字符串长度固定为 8。 做法一 思路 按字符统计给出的 01 字符串中字符 1 的个数。 代码 做法二 思路 还是按字符统计给出的 01 字符串中字符 1 的个数，只不过是换了个方法统计而已。 代码 神秘代码： =zhu1YI1JIAN1cha6 "},{"title":"洛谷 - P5661 公交换乘","date":"2019-11-30T19:32:27.000Z","url":"/luogu-p5661/","tags":["模拟","NOIP","洛谷"],"categories":["题解"],"content":"先说说在考场上看到这道题时候的心情：好简单呀！这道题真水！ 于是我写出了这样的代码： 自己打了打随机数据，AC！！！ 此时我看到了大样例，准备去一显身手上来就 TLE 了。 然后我打了一个优化： 然而还是 TLE 了… 考完出来想了想~~（厕所是个好地方）~~ 终于想出了 100 分代码： 其中只把这一个 for 循环改了改： 为什么要改这个呢？ 还记得题目中有这样的一句话吗？ 在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟 我们可以从这里入手。既然我们需要枚举优惠票，那么只需要枚举当前序号的前 45 个就行了。 为什么？ 其实题目已经告诉我们了： 我们保证出行记录是按照开始乘车的时间顺序给出的，且不会有两次乘车记录出现在同一分钟。 我个人认为这种做法的难度比前面大佬的队列什么的简单多了。 "},{"title":"洛谷 - P1200 [USACO1.1] 你的飞碟在这儿 Your Ride Is Here","date":"2019-01-30T18:55:28.000Z","url":"/luogu-p1200/","tags":["模拟","洛谷"],"categories":["题解"],"content":"题目信息卡题目名称你的飞碟在这儿提交地址洛谷 P1200题目难度入门 题面 难度：入门 标签：数论，数学 字符串 USACO 题目描述 众所周知，在每一个彗星后都有一只 UFO。这些 UFO 时常来收集地球上的忠诚支持者。不幸的是，他们的飞碟每次出行都只能带上一组支持者。因此，他们要用一种聪明的方案让这些小组提前知道谁会被彗星带走。他们为每个彗星起了一个名字，通过这些名字来决定这个小组是不是被带走的那个特定的小组（你认为是谁给这些彗星取的名字呢？）。关于如何搭配的细节会在下面告诉你；你的任务是写一个程序，通过小组名和彗星名来决定这个小组是否能被那颗彗星后面的 UFO 带走。 小组名和彗星名都以下列方式转换成一个数字：最终的数字就是名字中所有字母的积，其中 A 是 1 ， Z 是 26 。例如，USACO 小组就是 21×19×1×3×15=17955 。如果小组的数字 mod47 等于彗星的数字 mod47 ，你就得告诉这个小组需要准备好被带走！（记住 amodb 是 a 除以 b 的余数；34mod10=4） 写出一个程序，读入彗星名和小组名并算出用上面的方案能否将两个名字搭配起来，如果能搭配，就输出 GO，否则输出 STAY。小组名和彗星名均是没有空格或标点的一串大写字母（不超过 6 个字母）。 输入格式 第 1 行：一个长度为 1 到 6 的大写字母串，表示彗星的名字。 第 2 行：一个长度为 1 到 6 的大写字母串，表示队伍的名字。 输出格式 无。 输入输出样例 输入 #1 输出 #1 输入 #2 输出 #2 思路 按照题意计算即可。 代码 后记 Update1：2019-07-10 Update2：2020-10-12 优化代码 弃用不安全的 gets 函数。 "},{"title":"Hello World","date":"2019-01-30T00:00:00.000Z","url":"/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment "},{"title":"关于","date":"2022-05-31T12:54:25.962Z","url":"/about/index.html","content":"主博客 | OI 博客 关于博主 2021 级 HE 高一 OIer 一枚，现就读于 石家庄二中实验学校。 OI 生涯 初中时期：2018.12 ~ 2021.2 高中时期：2021.6 ~ 现在。 Codeforces AtCoder 更多信息可以前往 主博客的关于页面 页面查看。 统计信息 {@ stat: siteTotalPosts @} 篇文章 {@ stat: siteTotalCategories @} 个分类 {@ stat: siteTotalTags @} 个标签 {@ stat: siteWordCount[0] @} {@ stat: siteWordCount[1] @} 代码仓库 该仓库中存放了 AC 代码和部分测试数据。 语言环境信息 本博客中所有示例代码本地编译环境如下： 语言 编译器版本 编译命令 C gcc (Ubuntu 10.3.0-1ubuntu1~20.04) 10.3.0 gcc code.c -o code -std=c11 -O2 -lm C++ g++ (Ubuntu 10.3.0-1ubuntu1~20.04) 10.3.0 g++ code.cpp -o code -std=c++14 -O2 -lm Python Python 3.9.5 (default, May 19 2021, 11:32:47) [GCC 9.3.0] python code.py 运行环境如下： CPU Intel(R) Core(TM) i7-9750H @ 2.60GHz 内存 32GiB 系统版本 Ubuntu 20.04.3 LTS on Windows 10 x86_64 内核版本 5.10.60.1-microsoft-standard-WSL2 更新记录 2019/01/30 开通博客，托管于 洛谷博客 上。 2019/08/20 注册 baoshuo.ren 域名。 2020/01/27 切换到 Typecho 平台，使用 handsome 主题。 2020/06/23 切换到 Gridea 平台，使用 Pure 主题，旧博文大部分丢失。 2020/07/22 更换到新域名 baoshuo.blog，从国内迁出。 2020/11/25 将所有图片迁移到 SM.MS 图床上。 2020/12/06 换回旧域名 blog.baoshuo.ren ，迁回到国内服务器。 2021/02/01 切换到 Hexo 平台，使用自行移植的 Pure 主题。 2021/02/23 重构主题。 2021/08/26 再次重构主题，修复了一些问题。 2021/09/16 使用 GitHub Actions 自动构建博客（相关文章：浅谈静态博客的自动部署方案）。 2021/09/22 将 OI 相关内容移至本博客，使用 Miracle 主题。 2021/12/09 图片迁移至 SM.MS 国内 CDN 上。 2022/01/12 切换到自行编写的博客主题。 2022/01/18 增加搜索功能。 2022/03/14 增加文章加密功能（测试）。 2022/03/30 重新整理博客文章目录结构。 2022/04/13 使用 xTom Analytics 统计访客信息。 2022/05/30 增加题目信息卡功能。 免责声明 本博客所载的材料和信息，包括但不限于文本、图片、网页或链接，虽然我们力图在博客中提供准确的材料和信息，但我们并不保证这些材料和内容的准确、完整、充分和可靠性，并且明确声明不对这些材料和内容的错误或遗漏承担责任，也不对这些材料和内容作出任何明示或默示的、包括但不限于有关所有权担保、没有侵犯第三方权利、质量和没有计算机病毒的保证。 我们可以在没有任何通知或提示的情况下随时对本博客上的内容进行修改，请定期访问本博客以获取最新信息。 如无明确说明，在本博客上所提及的一切第三方服务均是为了提供相关信息，并不构成对这些产品、服务的认可或推荐。 根据相关法律法规的要求，本博客不设置评论系统。 隐私政策 请参见本博客的 隐私政策 页面。 版权声明 博客上所有文章除特别声明或加密外，均采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际许可协议 进行许可。转载请在文中明显位置注明出处。 鸣谢 本博客的主题设计参考或使用了以下网站、博客或项目（按字典序排序）： GitHub Markdown CSS hexo-blog-encrypt Hexo Theme Miracle Sukka’s Blog 本博客直接或间接使用到的开源项目（按字典序排序）： Autoprefixer (MIT License) clean-css (MIT License) Hexo (MIT License) html-minifier-terser (MIT License) instant.page (MIT License) KaTeX (MIT License) markdown-it (MIT License) modern-normalize (MIT License) Preact (MIT License) Sass (MIT License) SWC (Apache-2.0 License) Terser (BSD License) 本博客使用到了以下第三方服务： xTom Analytics SM.MS Image Hosting 本博客的 SSL 证书由 Google Trust Services LLC 提供。 在此一并表示感谢。 "},{"title":"友情链接","date":"2022-05-31T12:54:25.978Z","url":"/friends/index.html","content":" 链接 学校 年级 状态 RenaMoe 石家庄二中实验学校（河北省实验中学） 2020 级 LawrenceSivan 退役 rsdbkhusky XYY1411 退役 youwike 2021 级 CloudySky 退役 JohnSonloy KaiserWilheim Acestar 石家庄市第二中学 xixike RevolutionBP ztx 石家庄石门实验学校 2020 级初中 Menci 山东省临沂第一中学 2015 级 毕业 StudyingFather 新疆乌鲁木齐市第一中学 2018 级 本博客友链仅接受 OIer 添加，您可以通过面谈、Email、QQ、Telegram 等方式联系我添加友链。 "}]