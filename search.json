[{"title":"BZOJ - 4127. Abs","date":"2022-07-29T16:09:44.000Z","url":"/bzoj-4127/","tags":["数据结构","BZOJ","S2OJ","线段树","树链剖分"],"categories":["题解"],"content":" 题面 题目描述 给定一棵有 n 个节点的树，你需要在这棵树上进行以下操作： 1 u v d 将从 u 到 v 的路径上的所有点的权值增加 d； 2 u v 询问从 u 到 v 的路径上的点权 绝对值 的和。 输入格式 第一行两个整数 n 和 m，表示结点个数和操作数。 接下来一行 n 个整数 ai​，表示点 i 的权值。 接下来 n−1 行，每行两个整数 u,v 表示存在一条从 u 到 v 的边。 接下来 m 行，每行一个操作，格式见题目描述。 输出格式 对于每个询问输出答案。 样例输入输出 样例输入 #1 4 4 -4 1 5 -2 1 2 2 3 3 4 2 1 3 1 1 4 3 2 1 3 2 3 4 样例输出 #1 10 13 9 提示 对于 100% 的数据，n,m≤105 且 0≤d,∣ai​∣≤108。 思路 一道偏板子的树剖。 维护两棵线段树，一棵存正数，一棵存负数，零不影响答案，存哪里都无所谓。线段树中维护区间内正/负数的个数、区间最大值、区间和三个信息即可。 由于数据范围中给定了每次增加的数一定不为负数，因此节点只可能从负数的线段树上转移到正数的线段树上一次，所以暴力转移的复杂度是正确的。 场上的时候困得要死忘记在 pushdown 之后将懒标记置零，导致我浪费了半个小时宝贵的睡觉时间。 代码 #include &lt;iostream&gt; #include &lt;limits&gt; #include &lt;vector&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5; int n, m, a[N]; std::vector&lt;int&gt; g[N]; int cnt, id[N], rid[N], fa[N], dep[N], top[N], son[N], siz[N]; struct node &#123; int l, r; long long sum, max, d; size_t size; node() : l(0), r(0), sum(0), max(std::numeric_limits&lt;long long&gt;::min()), d(0), size(0) &#123;&#125; node(int _l, int _r) : l(_l), r(_r), sum(0), max(std::numeric_limits&lt;long long&gt;::min()), d(0), size(0) &#123;&#125; &#125; tr1[N &lt;&lt; 2], tr2[N &lt;&lt; 2]; void dfs1(int u, int f) &#123; fa[u] = f; dep[u] = dep[f] + 1; siz[u] = 1; for (int v : g[u]) &#123; if (v == f) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[son[u]] &lt; siz[v]) son[u] = v; &#125; &#125; void dfs2(int u, int t) &#123; id[u] = ++cnt; rid[id[u]] = u; top[u] = t; if (!son[u]) return; dfs2(son[u], t); for (int v : g[u]) &#123; if (v == fa[u] || v == son[u]) continue; dfs2(v, v); &#125; &#125; inline void pushup(node* tr, int u) &#123; tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; tr[u].max = std::max(tr[u &lt;&lt; 1].max, tr[u &lt;&lt; 1 | 1].max); tr[u].size = tr[u &lt;&lt; 1].size + tr[u &lt;&lt; 1 | 1].size; &#125; inline void pushdown(node* tr, int u) &#123; if (tr[u].d) &#123; tr[u &lt;&lt; 1].sum += tr[u].d * tr[u &lt;&lt; 1].size; if (tr[u &lt;&lt; 1].size) tr[u &lt;&lt; 1].max += tr[u].d; tr[u &lt;&lt; 1].d += tr[u].d; tr[u &lt;&lt; 1 | 1].sum += tr[u].d * tr[u &lt;&lt; 1 | 1].size; if (tr[u &lt;&lt; 1 | 1].size) tr[u &lt;&lt; 1 | 1].max += tr[u].d; tr[u &lt;&lt; 1 | 1].d += tr[u].d; tr[u].d = 0; &#125; &#125; void build(int u, int l, int r) &#123; tr1[u] = node(l, r); tr2[u] = node(l, r); if (l == r) &#123; if (a[rid[l]] &gt;= 0) &#123; tr1[u].sum = a[rid[l]]; tr1[u].max = a[rid[l]]; tr1[u].size = 1; &#125; else &#123; tr2[u].sum = a[rid[l]]; tr2[u].max = a[rid[l]]; tr2[u].size = 1; &#125; return; &#125; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(tr1, u); pushup(tr2, u); &#125; long long query_sum(int u, int l, int r) &#123; if (l &lt;= tr1[u].l &amp;&amp; tr1[u].r &lt;= r) &#123; return tr1[u].sum - tr2[u].sum; &#125; int mid = tr1[u].l + tr1[u].r &gt;&gt; 1; long long res = 0; pushdown(tr1, u); pushdown(tr2, u); if (l &lt;= mid) res += query_sum(u &lt;&lt; 1, l, r); if (r &gt; mid) res += query_sum(u &lt;&lt; 1 | 1, l, r); return res; &#125; long long query_max(node* tr, int u, int l, int r) &#123; if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) &#123; return tr[u].max; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; long long res = std::numeric_limits&lt;long long&gt;::min(); pushdown(tr1, u); pushdown(tr2, u); if (l &lt;= mid) res = std::max(res, query_max(tr, u &lt;&lt; 1, l, r)); if (r &gt; mid) res = std::max(res, query_max(tr, u &lt;&lt; 1 | 1, l, r)); return res; &#125; void swap_max(int u, int l, int r) &#123; if (tr2[u].max &lt;= 0) return; if (tr2[u].l == tr2[u].r) &#123; tr1[u] = tr2[u]; tr2[u] = node(l, r); return; &#125; int mid = tr1[u].l + tr1[u].r &gt;&gt; 1; pushdown(tr1, u); pushdown(tr2, u); if (l &lt;= mid) swap_max(u &lt;&lt; 1, l, r); if (r &gt; mid) swap_max(u &lt;&lt; 1 | 1, l, r); pushup(tr1, u); pushup(tr2, u); &#125; void modify(int u, int l, int r, int d) &#123; if (l &lt;= tr1[u].l &amp;&amp; tr1[u].r &lt;= r) &#123; tr1[u].sum += d * tr1[u].size; tr1[u].d += d; if (tr1[u].size) tr1[u].max += d; tr2[u].sum += d * tr2[u].size; tr2[u].d += d; if (tr2[u].size) tr2[u].max += d; return; &#125; int mid = tr1[u].l + tr1[u].r &gt;&gt; 1; pushdown(tr1, u); pushdown(tr2, u); if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, d); if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, d); pushup(tr1, u); pushup(tr2, u); &#125; void modify_path(int u, int v, int d) &#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) std::swap(u, v); modify(1, id[top[u]], id[u], d); swap_max(1, id[top[u]], id[u]); u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) std::swap(u, v); modify(1, id[v], id[u], d); swap_max(1, id[v], id[u]); &#125; long long query_path(int u, int v) &#123; long long res = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) std::swap(u, v); res += query_sum(1, id[top[u]], id[u]); u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) std::swap(u, v); res += query_sum(1, id[v], id[u]); return res; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1, u, v; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; v; g[u].emplace_back(v); g[v].emplace_back(u); &#125; dfs1(1, 0); dfs2(1, 1); build(1, 1, n); while (m--) &#123; int op, u, v; cin &gt;&gt; op &gt;&gt; u &gt;&gt; v; if (op == 1) &#123; int d; cin &gt;&gt; d; modify_path(u, v, d); &#125; else &#123; // op == 2 cout &lt;&lt; query_path(u, v) &lt;&lt; endl; &#125; &#125; return 0; &#125; "},{"title":"S2OJ - 45. 机房的新生活委员","date":"2022-07-28T15:38:16.000Z","url":"/s2oj-45/","tags":["动态规划","S2OJ","状态压缩"],"categories":["题解"],"content":" 题面 题目描述 大家都知道，R_rank_Pyram 在两次搜索专题比赛中都雄踞排行榜首位。林老师会给他个什么官当当呢？其实讲真，老师也很矛盾……直到有一天，lgj 发现机房的一些日用品需要更新了，比如扫把啦，抹布啦，畚斗啦……那不然就奖励 R_rank_Pyram 同学当机房的新生活委员吧！ 新官上任三把火，R_rank_Pyram 一上台就要为机房购置 m 种日用品（编号从 1 到 m），R_rank_Pyram 会选择在 n 家商店购买。由于 R_rank_Pyram 不想带着买好的商品在商店间穿梭，他每次从机房出发到一家店铺买完东西后，会把东西带回机房，再出发去另一家店铺…… 已知从机房往返第 i 家店铺的交通费为 feei​，并且每件商品在不同店铺购买价格也不同，第 i 件商品在第 j 家店铺的价格为 costi,j​。精打细算的生活委员想知道，购买这 m 件商品最少需要花多少钱？ 输入格式 第一行包含两个正整数 n,m，表示店铺数量和需要购买的物品种类数。 接下来 n 行，每行第一个正整数 feei​ 表示机房到第 i 家商店的往返路费，接下来 m 个正整数，依次表示 costi,j​。 输出格式 输出一个正整数，即最小花费。 样例输入输出 样例输入 #1 3 4 5 7 3 7 9 2 1 20 3 2 8 1 20 1 1 样例输出 #1 16 样例解释 #1 生活委员会在 1 号店买 2 号商品，在 2 号店买 1,3,4 号商品。 数据规模与约定 对于 40% 的数据：n,m≤10； 对于 60% 的数据，n≤50； 对于 100% 的数据，1≤n≤100，1≤m≤16，1≤feei​≤106，1≤costi,j​≤106。 思路 一看数据范围就知道是一个很显然的状压 DP。 对于每个状态可以从三种情况转移得出答案： 保持当前购买情况不变，没有新增开销； 上一个物品也是在当前商店内购买的，直接加上物品 k 的价格； 从其他商店赶来后再购买物品 k，除了物品价格外还需要支付路费。 每轮转移完成后与之前的答案比较，取最优的存储即可。 详细实现可以查看下方代码。 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 105, M = 17; int n, m, fee[N], cost[N][M], f[N][1 &lt;&lt; M], ans = 0x3f3f3f3f; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; fee[i]; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; cost[i][j]; &#125; &#125; memset(f, 0x3f, sizeof(f)); f[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; 1 &lt;&lt; m; j++) &#123; for (int k = 0; k &lt; m; k++) &#123; if (j &amp; (1 &lt;&lt; k)) continue; // 已经购买过物品 k 则跳过 f[i][j | (1 &lt;&lt; k)] = std::min(&#123; f[i][j | (1 &lt;&lt; k)], // 保持当前购买情况不变，没有新增开销 f[i][j] + cost[i][k], // 上一个物品也是在当前商店内购买的，直接加上物品 k 的价格 f[i - 1][j] + fee[i] + cost[i][k], // 从其他商店赶来后再购买物品 k，除了物品价格外还需要支付路费 &#125;); &#125; &#125; for (int j = 0; j &lt; 1 &lt;&lt; m; j++) &#123; f[i][j] = std::min(f[i][j], f[i - 1][j]); // 与之前的答案比较，取最优的 &#125; &#125; cout &lt;&lt; f[n][(1 &lt;&lt; m) - 1] &lt;&lt; endl; return 0; &#125; "},{"title":"S2OJ - 1486. 数据结构","date":"2022-07-27T22:08:24.000Z","url":"/s2oj-1486/","tags":["数学","S2OJ","组合数学","二项式定理","数论","杨辉三角"],"categories":["题解"],"content":" 题面 题目描述 维护一个正整数多重集合 S，初始为空，支持两个操作： 插入：插入一个新数 x； 修改：令集合中所有数加 1。 每次操作结束后，输出 S 中所有数的 k 次方和，k 预先给定，对 109+7 取模。 输入格式 第一行两个数 m,k，其中 m 表示操作次数。 接下来 m 行，每行可能为以下两种之一： 0 x ，表示插入一个大小为 x 的新元素。 1，表示令集合 S 里所有数加一。 输出格式 输出 m 行，第 i 行表示第 i 次操作结束之后，S 中所有数的 k 次方和。 样例输入输出 样例输入 #1 3 2 0 1 0 1 1 样例输出 #1 1 2 8 数据范围与约定 对于 100% 的数据，m≤2×105，1≤k≤50，0≤x≤105。 思路 这道题考场上大家都是直接把二项式定理拿出来用 A 掉的，复杂度是 O(nk2)，可惜就我一个菜鸡把二项式定理忘掉了，所以通过杨辉三角手推完二项式定理之后顺带着出来了一种 O(mk) 的做法。可惜的是考场上忘记处理负数取模的问题导致猛挂到 20 分。下面带来我的考场思路，可能会有些许罗嗦： 首先题目要求在每次操作完成后输出多重集合 S 中所有数的 k 次方和，因此可以从这里下手。 插入操作的数的 k 次方可以直接加进全局和中，因此只需要考虑如何处理全局加 1 的问题即可。 先写出一些加 1 后 k 次方和的式子进行观察： 当 k=1 时， =​(x1​+1)1+(x2​+1)+⋯+(xn​+1)1×(x1​+x2​+⋯+xn​)+1×n 个 1(1+1+⋯+1)​​​ 当 k=2 时， ==​(x1​+1)2+(x2​+1)2+⋯+(xn​+1)2(x12​+2x1​+1)+(x22​+2x2​+1)+⋯+(xn2​+2xn​+1)1×(x12​+x22​+⋯+xn2​)+2×(x1​+x2​+⋯+xn​)+1×n 个 1(1+1+⋯+1)​​​ 当 k=3 时， ==​(x1​+1)3+(x2​+1)3+⋯+(xn​+1)3(x13​+3x12​+3x1​+1)+(x23​+3x22​+3x2​+1)+⋯+(xn3​+3xn2​+3xn​+1)1×(x13​+x23​+⋯+xn3​)+3×(x12​+x22​+⋯+xn2​)+3×(x1​+x2​+⋯+xn​)+1×n 个 1(1+1+⋯+1)​​​ 当 k=4 时， ==​(x1​+1)4+(x2​+1)4+⋯+(xn​+1)4(x14​+4x13​+6x12​+4x1​+1)+(x24​+4x23​+6x22​+4x2​+1)+⋯+(xn4​+4xn3​+6xn2​+4xn​+1)1×(x14​+x24​+⋯+xn4​)+4×(x13​+x23​+⋯+xn3​)+6×(x12​+x22​+⋯+xn2​)+4×(x1​+x2​+⋯+xn​)+1×n 个 1(1+1+⋯+1)​​​ 可以观察到系数呈现出了杨辉三角的形式： 111121133114641​ 那么可以考虑记录全局累计增加的数 Δ，然后每次全局加之后都将 Δ+1，再重新计算全局和。此时需要将新插入的数 x 作为 x−Δ 存入以便计算。 现在再来看一看 (xi​+Δ)k 的问题，有一种想法是可以将其按照 ((xi​+(Δ−1))+1)k 的形式递归展开，比如 (x+2)2 就可以这样展开： ===​(x+2)2(x+1)2+2(x+1)+1(x2+2x+1)+2(x+1)+1x2+4x+4​ 当 k=2 时，系数分布如下图所示： 1×201×201×211×202×211×221×203×213×221×231×204×216×224×231×24​ 推广得： 1×k01×k01×k11×k02×k11×k21×k03×k13×k21×k31×k04×k16×k24×k31×k4​ 举个稍大一些的例子： ==​(x1​+2)4+(x2​+2)4(x14​+8x13​+24x12​+32x1​+24)+(x24​+8x23​+24x22​+32x2​+24)(x14​+x24​)+8×(x13​+x23​)+24×(x12​+x22​)+32×(x1​+x2​)+(24+24)​ 设左对齐的杨辉三角的第 i 行第 j 列上的数为 fi,j​，那么可以将总和记为： i=0∑k​(fk,i​×Δi×j=1∑n​xjk−i​) 显然 ∑j=1n​xjk−i​ 可以使用前缀和优化到 O(1)，记为 sum，最终形式为： i=0∑k​(fk,i​×Δi×sumk−i) 复杂度为 O(mk)。 代码 #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 2e5 + 5, K = 55; const int mod = 1e9 + 7; int m, k, d, cnt; long long f[K][K], s[K], sum; long long binpow(long long a, long long b) &#123; a %= mod; long long res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; m &gt;&gt; k; f[0][0] = 1; for (int i = 1; i &lt;= k; i++) &#123; f[i][0] = 1; for (int j = 1; j &lt;= i; j++) &#123; f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % mod; &#125; &#125; while (m--) &#123; int op; cin &gt;&gt; op; if (op == 0) &#123; int x; long long p = 1; cin &gt;&gt; x; s[0] = (s[0] + 1) % mod; for (int i = 1; i &lt;= k; i++) &#123; p = (p * (x - d) % mod + mod) % mod; s[i] = (s[i] + p) % mod; &#125; sum = (sum + binpow(x, k)) % mod; &#125; else &#123; // op == 1 d++; sum = 0; for (int i = 0; i &lt;= k; i++) &#123; sum = (sum + f[k][i] * binpow(d, i) % mod * s[k - i] % mod) % mod; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"树套树学习笔记","date":"2022-07-26T11:55:53.000Z","url":"/tree-in-tree/","tags":["数据结构","线段树","平衡树","STL","树套树"],"categories":["笔记"],"content":"树套树是处理区间问题或二维数点问题的一种常见的数据结构。 其实树套树的原理很简单，就是利用外层树的树高为 O(logn) 和内层树允许动态开点的性质。经过一系列处理可以使得时空复杂度均保持在 O(nlog2n) 的级别。 但树套树处理问题的局限性在于询问需要可以被分成 logn 段区间分别处理后合并。 线段树套 STL 支持操作 修改某一位置上的数值； 查询 x 在区间内的前驱（前驱定义为小于 x，且最大的数）。 理论上还可以支持以下操作： 查询 x 在区间内的后继（后继定义为大于 x，且最小的数）。 代码 #include &lt;iostream&gt; #include &lt;limits&gt; #include &lt;set&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 5e4 + 5; int n, m, a[N]; struct node : std::multiset&lt;int&gt; &#123; int l, r; node() : l(0), r(0) &#123;&#125; node(int _l, int _r) : l(_l), r(_r) &#123; insert(std::numeric_limits&lt;int&gt;::min()); insert(std::numeric_limits&lt;int&gt;::max()); &#125; &#125; tr[N &lt;&lt; 2]; void build(int u, int l, int r) &#123; tr[u] = node(l, r); for (int i = l; i &lt;= r; i++) &#123; tr[u].insert(a[i]); &#125; if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); &#125; void modify(int u, int p, int x) &#123; tr[u].erase(tr[u].find(a[p])); tr[u].insert(x); if (tr[u].l == tr[u].r) return; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (p &lt;= mid) modify(u &lt;&lt; 1, p, x); else modify(u &lt;&lt; 1 | 1, p, x); &#125; int query(int u, int l, int r, int x) &#123; if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) &#123; return *--tr[u].lower_bound(x); &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int res = std::numeric_limits&lt;int&gt;::min(); if (l &lt;= mid) res = std::max(res, query(u &lt;&lt; 1, l, r, x)); if (r &gt; mid) res = std::max(res, query(u &lt;&lt; 1 | 1, l, r, x)); return res; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); while (m--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int p, x; cin &gt;&gt; p &gt;&gt; x; modify(1, p, x); a[p] = x; &#125; else &#123; // op == 2 int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; query(1, l, r, x) &lt;&lt; endl; &#125; &#125; return 0; &#125; 线段树套平衡树 支持操作 查询 x 在区间内的排名； 查询区间内排名为 k 的值； 修改某一位置上的数值； 查询 x 在区间内的前驱（前驱定义为小于 x，且最大的数）； 查询 x 在区间内的后继（后继定义为大于 x，且最小的数）。 代码 线段树套 Splay线段树套 FHQ Treap这份代码在洛谷上被卡 TLE 了两个测试点，在 LibreOJ 上测试要比 FHQ Treap 版本慢上 1000 多毫秒，还比 FHQ Treap 长不少。 #include &lt;iostream&gt; #include &lt;limits&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 5e4 + 5; class Splay &#123; private: struct node &#123; int value; node *lchild, *rchild, *parent, **root; size_t size, count; node() : value(0), lchild(nullptr), rchild(nullptr), parent(nullptr), root(nullptr), size(0), count(0) &#123;&#125; node(const int &amp;_value, node *_parent, node **_root) : value(_value), lchild(nullptr), rchild(nullptr), parent(_parent), root(_root), size(1), count(1) &#123;&#125; ~node() &#123; if (lchild != nullptr) delete lchild; if (rchild != nullptr) delete rchild; &#125; node *&amp;child(unsigned int x) &#123; return !x ? lchild : rchild; &#125; unsigned relation() const &#123; return this == parent-&gt;lchild ? 0 : 1; &#125; size_t lsize() const &#123; return lchild == nullptr ? 0 : lchild-&gt;size; &#125; size_t rsize() const &#123; return rchild == nullptr ? 0 : rchild-&gt;size; &#125; void pushup() &#123; size = lsize() + count + rsize(); &#125; void rotate() &#123; node *old = parent; unsigned x = relation(); if (old-&gt;parent != nullptr) &#123; old-&gt;parent-&gt;child(old-&gt;relation()) = this; &#125; parent = old-&gt;parent; if (child(x ^ 1) != nullptr) &#123; child(x ^ 1)-&gt;parent = old; &#125; old-&gt;child(x) = child(x ^ 1); child(x ^ 1) = old; old-&gt;parent = this; old-&gt;pushup(); pushup(); &#125; void splay(node *target = nullptr) &#123; while (parent != target) &#123; if (parent-&gt;parent == target) &#123; rotate(); &#125; else if (relation() == parent-&gt;relation()) &#123; parent-&gt;rotate(); rotate(); &#125; else &#123; rotate(); rotate(); &#125; &#125; if (target == nullptr) *root = this; &#125; node *predecessor() &#123; node *pred = lchild; while (pred-&gt;rchild != nullptr) &#123; pred = pred-&gt;rchild; &#125; return pred; &#125; node *successor() &#123; node *succ = rchild; while (succ-&gt;lchild != nullptr) &#123; succ = succ-&gt;lchild; &#125; return succ; &#125; &#125; * root; node *_insert(const int &amp;value) &#123; node **target = &amp;root, *parent = nullptr; while (*target != nullptr &amp;&amp; (*target)-&gt;value != value) &#123; parent = *target; parent-&gt;size++; if (value &lt; parent-&gt;value) &#123; target = &amp;parent-&gt;lchild; &#125; else &#123; target = &amp;parent-&gt;rchild; &#125; &#125; if (*target == nullptr) &#123; *target = new node(value, parent, &amp;root); &#125; else &#123; (*target)-&gt;count++; (*target)-&gt;size++; &#125; (*target)-&gt;splay(); return root; &#125; node *find(const int &amp;value) &#123; node *node = root; while (node != nullptr &amp;&amp; value != node-&gt;value) &#123; if (value &lt; node-&gt;value) &#123; node = node-&gt;lchild; &#125; else &#123; node = node-&gt;rchild; &#125; &#125; if (node != nullptr) &#123; node-&gt;splay(); &#125; return node; &#125; void erase(node *u) &#123; if (u == nullptr) return; if (u-&gt;count &gt; 1) &#123; u-&gt;splay(); u-&gt;count--; u-&gt;size--; return; &#125; node *pred = u-&gt;predecessor(), *succ = u-&gt;successor(); pred-&gt;splay(); succ-&gt;splay(pred); delete succ-&gt;lchild; succ-&gt;lchild = nullptr; succ-&gt;pushup(); pred-&gt;pushup(); &#125; public: Splay() : root(nullptr) &#123; insert(std::numeric_limits&lt;int&gt;::min()); insert(std::numeric_limits&lt;int&gt;::max()); &#125; ~Splay() &#123; delete root; &#125; void insert(const int &amp;value) &#123; _insert(value); &#125; void erase(const int &amp;value) &#123; erase(find(value)); &#125; unsigned rank(const int &amp;value) &#123; node *node = find(value); if (node == nullptr) &#123; node = _insert(value); int res = node-&gt;lsize(); erase(node); return res; &#125; return node-&gt;lsize(); &#125; const int &amp;predecessor(const int &amp;value) &#123; node *node = find(value); if (node == nullptr) &#123; node = _insert(value); const int &amp;result = node-&gt;predecessor()-&gt;value; erase(node); return result; &#125; return node-&gt;predecessor()-&gt;value; &#125; const int &amp;successor(const int &amp;value) &#123; node *node = find(value); if (node == nullptr) &#123; node = _insert(value); const int &amp;result = node-&gt;successor()-&gt;value; erase(node); return result; &#125; return node-&gt;successor()-&gt;value; &#125; &#125;; struct node : Splay &#123; int l, r; node *lchild, *rchild; node() : l(0), r(0), lchild(nullptr), rchild(nullptr) &#123;&#125; node(const int &amp;_l, const int &amp;_r) : l(_l), r(_r), lchild(nullptr), rchild(nullptr) &#123;&#125; ~node() &#123; if (lchild != nullptr) delete lchild; if (rchild != nullptr) delete rchild; &#125; &#125; * root; int n, m, a[N]; void build(node *&amp;u, int l, int r) &#123; u = new node(l, r); for (int i = l; i &lt;= r; i++) &#123; u-&gt;insert(a[i]); &#125; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(u-&gt;lchild, l, mid); build(u-&gt;rchild, mid + 1, r); &#125; int query_rank(node *u, int l, int r, int x) &#123; if (l &lt;= u-&gt;l &amp;&amp; u-&gt;r &lt;= r) &#123; return u-&gt;rank(x) - 1; &#125; int mid = (u-&gt;l + u-&gt;r) &gt;&gt; 1; int res = 0; if (l &lt;= mid) res += query_rank(u-&gt;lchild, l, r, x); if (r &gt; mid) res += query_rank(u-&gt;rchild, l, r, x); return res; &#125; int query_kth(int _l, int _r, int k) &#123; int l = -1e8, r = 1e8, res = -1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (query_rank(root, _l, _r, mid) + 1 &lt;= k) &#123; l = mid + 1; res = mid; &#125; else &#123; r = mid - 1; &#125; &#125; return res; &#125; void modify(node *u, int p, int x) &#123; u-&gt;erase(a[p]); u-&gt;insert(x); if (u-&gt;l == u-&gt;r) return; int mid = (u-&gt;l + u-&gt;r) &gt;&gt; 1; if (p &lt;= mid) modify(u-&gt;lchild, p, x); else modify(u-&gt;rchild, p, x); &#125; int query_pre(node *u, int l, int r, int x) &#123; if (l &lt;= u-&gt;l &amp;&amp; u-&gt;r &lt;= r) &#123; return u-&gt;predecessor(x); &#125; int mid = (u-&gt;l + u-&gt;r) &gt;&gt; 1; int res = std::numeric_limits&lt;int&gt;::min(); if (l &lt;= mid) res = std::max(res, query_pre(u-&gt;lchild, l, r, x)); if (r &gt; mid) res = std::max(res, query_pre(u-&gt;rchild, l, r, x)); return res; &#125; int query_suc(node *u, int l, int r, int x) &#123; if (l &lt;= u-&gt;l &amp;&amp; u-&gt;r &lt;= r) &#123; return u-&gt;successor(x); &#125; int mid = (u-&gt;l + u-&gt;r) &gt;&gt; 1; int res = std::numeric_limits&lt;int&gt;::max(); if (l &lt;= mid) res = std::min(res, query_suc(u-&gt;lchild, l, r, x)); if (r &gt; mid) res = std::min(res, query_suc(u-&gt;rchild, l, r, x)); return res; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; build(root, 1, n); while (m--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; query_rank(root, l, r, x) + 1 &lt;&lt; endl; &#125; else if (op == 2) &#123; int l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; query_kth(l, r, k) &lt;&lt; endl; &#125; else if (op == 3) &#123; int p, x; cin &gt;&gt; p &gt;&gt; x; modify(root, p, x); a[p] = x; &#125; else if (op == 4) &#123; int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; query_pre(root, l, r, x) &lt;&lt; endl; &#125; else &#123; // op == 5 int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; query_suc(root, l, r, x) &lt;&lt; endl; &#125; &#125; delete root; return 0; &#125;这份代码在洛谷上开了 O2 优化之后是可以以 2.00s 的运行时间刚好卡过去 P3380 【模板】二逼平衡树（树套树） 的：R81169175。 #include &lt;iostream&gt; #include &lt;chrono&gt; #include &lt;limits&gt; #include &lt;random&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 5e4 + 5; class Treap &#123; private: struct node &#123; node *lchild, *rchild; int size, value, key; node() : lchild(nullptr), rchild(nullptr), size(0), value(0), key(rand()) &#123;&#125; node(int _value) : lchild(nullptr), rchild(nullptr), size(1), value(_value), key(rand()) &#123;&#125; ~node() &#123; delete lchild; delete rchild; &#125; inline void pushup() &#123; size = 1; if (lchild != nullptr) size += lchild-&gt;size; if (rchild != nullptr) size += rchild-&gt;size; &#125; &#125; * root; inline int getNodeSize(node *node) &#123; return node == nullptr ? 0 : node-&gt;size; &#125; std::pair&lt;node *, node *&gt; split(node *p, int k) &#123; if (p == nullptr) return std::make_pair(nullptr, nullptr); if (k &lt;= getNodeSize(p-&gt;lchild)) &#123; auto o = split(p-&gt;lchild, k); p-&gt;lchild = o.second; p-&gt;pushup(); o.second = p; return o; &#125; auto o = split(p-&gt;rchild, k - getNodeSize(p-&gt;lchild) - 1); p-&gt;rchild = o.first; p-&gt;pushup(); o.first = p; return o; &#125; std::pair&lt;node *, node *&gt; splitByValue(node *p, int value) &#123; if (p == nullptr) return std::make_pair(nullptr, nullptr); if (p-&gt;value &lt; value) &#123; auto o = splitByValue(p-&gt;rchild, value); p-&gt;rchild = o.first; p-&gt;pushup(); o.first = p; return o; &#125; auto o = splitByValue(p-&gt;lchild, value); p-&gt;lchild = o.second; p-&gt;pushup(); o.second = p; return o; &#125; node *merge(node *x, node *y) &#123; if (x == nullptr) return y; if (y == nullptr) return x; if (x-&gt;key &gt; y-&gt;key) &#123; x-&gt;rchild = merge(x-&gt;rchild, y); x-&gt;pushup(); return x; &#125; y-&gt;lchild = merge(x, y-&gt;lchild); y-&gt;pushup(); return y; &#125; public: Treap() : root(nullptr) &#123;&#125; ~Treap() &#123; delete root; &#125; inline void insert(int value) &#123; auto o = splitByValue(root, value); o.first = merge(o.first, new node(value)); root = merge(o.first, o.second); &#125; inline void erase(int value) &#123; auto o = splitByValue(root, value); auto t = split(o.second, 1); if (t.first-&gt;value == value) &#123; delete t.first; &#125; root = merge(o.first, t.second); &#125; inline int rank(int value) &#123; auto x = splitByValue(root, value); int r = getNodeSize(x.first) + 1; root = merge(x.first, x.second); return r; &#125; inline int kth(int k) &#123; auto x = split(root, k - 1); auto y = split(x.second, 1); Treap::node *o = y.first; root = merge(x.first, merge(y.first, y.second)); return o == nullptr ? 0 : o-&gt;value; &#125; inline int pre(int x) &#123; int k = rank(x) - 1; return k &gt; 0 ? kth(k) : std::numeric_limits&lt;int&gt;::min() + 1; &#125; inline int suc(int x) &#123; int k = rank(x + 1); return k &gt; getNodeSize(root) ? std::numeric_limits&lt;int&gt;::max() : kth(k); &#125; &#125;; struct node : Treap &#123; int l, r; node *lchild, *rchild; node() : l(0), r(0), lchild(nullptr), rchild(nullptr) &#123;&#125; node(const int &amp;_l, const int &amp;_r) : l(_l), r(_r), lchild(nullptr), rchild(nullptr) &#123;&#125; ~node() &#123; if (lchild != nullptr) delete lchild; if (rchild != nullptr) delete rchild; &#125; &#125; * root; int n, m, a[N]; void build(node *&amp;u, int l, int r) &#123; u = new node(l, r); for (int i = l; i &lt;= r; i++) &#123; u-&gt;insert(a[i]); &#125; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(u-&gt;lchild, l, mid); build(u-&gt;rchild, mid + 1, r); &#125; int query_rank(node *u, int l, int r, int x) &#123; if (l &lt;= u-&gt;l &amp;&amp; u-&gt;r &lt;= r) &#123; return u-&gt;rank(x) - 1; &#125; int mid = (u-&gt;l + u-&gt;r) &gt;&gt; 1; int res = 0; if (l &lt;= mid) res += query_rank(u-&gt;lchild, l, r, x); if (r &gt; mid) res += query_rank(u-&gt;rchild, l, r, x); return res; &#125; int query_kth(int _l, int _r, int k) &#123; int l = 0, r = 1e8, res = -1; while (l &lt;= r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (query_rank(root, _l, _r, mid) + 1 &lt;= k) &#123; l = mid + 1; res = mid; &#125; else &#123; r = mid - 1; &#125; &#125; return res; &#125; void modify(node *u, int p, int x) &#123; u-&gt;erase(a[p]); u-&gt;insert(x); if (u-&gt;l == u-&gt;r) return; int mid = (u-&gt;l + u-&gt;r) &gt;&gt; 1; if (p &lt;= mid) modify(u-&gt;lchild, p, x); else modify(u-&gt;rchild, p, x); &#125; int query_pre(node *u, int l, int r, int x) &#123; if (l &lt;= u-&gt;l &amp;&amp; u-&gt;r &lt;= r) &#123; return u-&gt;pre(x); &#125; int mid = (u-&gt;l + u-&gt;r) &gt;&gt; 1; int res = std::numeric_limits&lt;int&gt;::min() + 1; if (l &lt;= mid) res = std::max(res, query_pre(u-&gt;lchild, l, r, x)); if (r &gt; mid) res = std::max(res, query_pre(u-&gt;rchild, l, r, x)); return res; &#125; int query_suc(node *u, int l, int r, int x) &#123; if (l &lt;= u-&gt;l &amp;&amp; u-&gt;r &lt;= r) &#123; return u-&gt;suc(x); &#125; int mid = (u-&gt;l + u-&gt;r) &gt;&gt; 1; int res = std::numeric_limits&lt;int&gt;::max(); if (l &lt;= mid) res = std::min(res, query_suc(u-&gt;lchild, l, r, x)); if (r &gt; mid) res = std::min(res, query_suc(u-&gt;rchild, l, r, x)); return res; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; build(root, 1, n); while (m--) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; query_rank(root, l, r, x) + 1 &lt;&lt; endl; &#125; else if (op == 2) &#123; int l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; query_kth(l, r, k) &lt;&lt; endl; &#125; else if (op == 3) &#123; int p, x; cin &gt;&gt; p &gt;&gt; x; modify(root, p, x); a[p] = x; &#125; else if (op == 4) &#123; int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; query_pre(root, l, r, x) &lt;&lt; endl; &#125; else &#123; // op == 5 int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; cout &lt;&lt; query_suc(root, l, r, x) &lt;&lt; endl; &#125; &#125; delete root; return 0; &#125; "},{"title":"AGC018C - Coins","date":"2022-07-22T19:00:00.000Z","url":"/atcoder-agc018c/","tags":["AtCoder","贪心","反悔贪心"],"categories":["题解"],"content":" 题面 Statement There are X+Y+Z people, conveniently numbered 1 through X+Y+Z. Person i has Ai​ gold coins, Bi​ silver coins and Ci​ bronze coins. Snuke is thinking of getting gold coins from X of those people, silver coins from Y of the people and bronze coins from Z of the people. It is not possible to get two or more different colors of coins from a single person. On the other hand, a person will give all of his/her coins of the color specified by Snuke. Snuke would like to maximize the total number of coins of all colors he gets. Find the maximum possible number of coins. Samples Sample Input #1 1 2 1 2 4 4 3 2 1 7 6 7 5 2 3 Sample Output #1 18 Sample Explanation #1 Get silver coins from Person 1, silver coins from Person 2, bronze coins from Person 3 and gold coins from Person 4. In this case, the total number of coins will be 4+2+7+5=18. It is not possible to get 19 or more coins, and the answer is therefore 18. Sample Input #2 3 3 2 16 17 1 2 7 5 2 16 12 17 7 7 13 2 10 12 18 3 16 15 19 5 6 2 Sample Output #2 110 Sample Input #3 6 2 4 33189 87907 277349742 71616 46764 575306520 8801 53151 327161251 58589 4337 796697686 66854 17565 289910583 50598 35195 478112689 13919 88414 103962455 7953 69657 699253752 44255 98144 468443709 2332 42580 752437097 39752 19060 845062869 60126 74101 382963164 Sample Output #3 3093929975 Limits 1≤X,Y,Z X+Y+Z≤105 1≤Ai​,Bi​,Ci​≤109 题解 反悔贪心。 先钦定所有人全拿铜牌，然后再考虑拿金牌、银牌的情况。那么问题就转化为了选出 x 人给 ai​−ci​ 元，y 人给 bi​−ci​ 元。 容易想到按照 ai​−bi​ 降序排序来确定拿金牌的选手到底是哪些。接下来维护金牌的前缀和和银牌的后缀和即可，由于数组已经以 ai​−bi​ 为关键字排过序了，所以这样维护是正确的。 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5; int n, x, y, z; long long pre[N], suf[N], sum, ans; struct node &#123; int a, b, c, id; &#125; a[N]; std::priority_queue&lt;int&gt; q1, q2; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; n = x + y + z; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].c; sum += a[i].c; // 先钦定全选铜牌 a[i].id = i; &#125; std::sort(a + 1, a + 1 + n, [](node a, node b) &#123; return a.a - a.b &gt; b.a - b.b; // 按照 a - b 降序排序 &#125;); for (int i = 1; i &lt;= n; i++) &#123; q1.push(a[i].c - a[i].a); // 计算更换为铜牌的代价并插入堆中 pre[i] = pre[i - 1] + a[i].a - a[i].c; if (q1.size() &gt; x) &#123; // 如果金牌数量超出要求则将最小的更改为铜牌 pre[i] += q1.top(); q1.pop(); &#125; &#125; for (int i = n; i; i--) &#123; q2.push(a[i].c - a[i].b); // 计算更换为铜牌的代价并插入堆中 suf[i] = suf[i + 1] + a[i].b - a[i].c; if (q2.size() &gt; y) &#123; // 如果银牌数量超出要求则更改为铜牌 suf[i] += q2.top(); q2.pop(); &#125; &#125; for (int i = x; i + y &lt;= n; i++) &#123; ans = std::max(ans, sum + pre[i] + suf[i + 1]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 原题来自 AGC018C - Coins。 "},{"title":"组合数学基础","date":"2022-07-17T22:18:52.000Z","url":"/combinatorics/","tags":["数学","组合数学","计数原理","排列组合","二项式定理","Lucas 定理","Catalan 数"],"categories":["笔记"],"content":" 计数原理 加法原理 完成某件事有 n 种途径，每种途径有 pi​ 个不同的方案，则完成这件事的方案总数为 i=1∑n​pi​ 乘法原理 完成某件事需要进行 n 个步骤，每个步骤有 pi​ 个不同的方案，则完成这件事的方案总数为 i=1∏n​pi​ 排列组合 排列数 定义 从 n 个不同的元素中取出 m 个不同的元素作为一个排列，产生的不同排列数量记为 Anm​。排列数的计算公式为： Anm​=n(n−1)(n−2)⋯(n−m+1)=(n−m)!n!​ 特化 当 m=0 时，只有一种方案即什么都不选； 当 m=n 时，排列为全排列 Anm​=Ann​=n!； 当 m&gt;n 时，排列数为 0。 组合数 定义 从 n 个不同元素种取出 m 个元素作为一个集合，产生的不同集合数量记为 Cnm​，也常用 (mn​) 表示。组合数的计算公式为： Cnm​=Amm​Anm​​=m!(n−m)!n!​ 特化 当 m=0 时，只有一种方案即什么都不选； 当 m=n 时，只有一种方案即全选； 当 m&gt;n 时，组合数为 0。 性质 (mn​)=(n−mn​)，选择 m 个相当于选择 n−m 个留下来； Pascal 公式：(mn​)=(mn−1​)+(m−1n−1​)，常用于递推求组合数； m=0∑n​(mn​)=2n； k=0∑n​(−1)k(in​)=[n=0]； k=0∑n​(kn​)2=(n2n​)； 斐波那契数列：Fn+1​=k=0∑n​(kn−k​)。 多重集的排列数 多重集是指包含重复元素的广义集合。设 S={n1​⋅a1​,n2​⋅a2​,⋯,nk​⋅ak​} 表示由 n1​ 个 a1​，n2​ 个 a2​，…，nk​ 个 ak​ 组成的多重集，S 的全排列个数为： ∏i=1k​ni​!n!​=n1​!n2​!⋯nk​!n!​ 多重集的组合数 设 S={n1​⋅a1​,n2​⋅a2​,⋯,nk​⋅ak​} 表示由 n1​ 个 a1​，n2​ 个 a2​，…，nk​ 个 ak​ 组成的多重集。那么对于整数 r（r&lt;ni​,∀i∈[1,k]），从 S 中选择 r 个元素组成一个多重集的方案数就是 多重集的组合数。这个问题等价于 x1​+x2​+⋯+xk​=r 的非负整数解的数目，可以用插板法解决，答案为： (k−1r+k−1​) 二项式定理 (a+b)n=k=0∑n​(kn​)akbn−k 证明 可以应用数学归纳法来证明二项式定理。 当 n=1 时，有： ==​(a+b)1(0n​)a0b1+(1n​)a1b0a+b​ 此情况下命题成立。 假设 n=m 时命题成立，令 n=m+1，有： (a+b)n​=(a+b)(a+b)m=(a+b)k=0∑m​(km​)akbm−k=ak=0∑m​(km​)akbm−k+bk=0∑m​(km​)akbm−k=k=0∑m​(km​)ak+1bm−k+bk=0∑m​(km​)akbm−k+1=k=1∑m+1​(k−1m​)akbm−k+1+bk=0∑m​(km​)akbm−k+1=k=0∑m+1​((k−1m​)+(km​))ak+bm−k+1=k=0∑m+1​(km+1​)ak+bm−k+1=k=0∑n​(kn​)ak+bn−k​ 故命题成立。证毕。 自然数平方和公式 i=1∑n​i2=6n(n+1)(2n+1)​ OEIS：A000330。 证明 可以应用数学归纳法来证明自然数平方和公式。 当 n=1 时，有： 12​=1=61×2×3​=1​ 此情况下公式成立。 假设 n=k 时公式成立，令 n=k+1，有： =======​12+22+32+⋯+(n−1)2+n212+22+32+⋯+k2+(k+1)26k(k+1)(2k+1)​+(k+1)26k(k+1)(2k+1)+6(k+1)2​6(k+1)[k(2k+1)+6(k+1)]​6(k+1)(2k2+7k+6)​6(k+1)(2k+3)(k+2)​6n(n+1)(2n+1)​​ 故公式成立。证毕。 Lucas 定理 对于质数 p，有： (mn​)modp=(⌊m/p⌋⌊n/p⌋​)⋅(mmodpnmodp​)modp 代码 完整代码请在 GitSB 上查看。 int lucas(int n, int m, int p) &#123; if (!m) return 1; return static_cast&lt;long long&gt;(C(n % p, m % p, p)) * lucas(n / p, m / p, p) % p; &#125; Catalan 数（卡特兰数） 定义 Catn​={1∑i=1n​Cati−1​⋅Catn−i​​(n∈{1,2})(n≥2,n∈N∗)​ 递推定义： Catn​=n+14n−2​Catn−1​ 通项公式： Catn​=n+1(n2n​)​ (n≥2,n∈N∗) 组合意义 给定 n 个 0 和 n 个 1，他们按照某种顺序排成一个长度为 2n 的序列，满足任意前缀中 0 的个数都不少于 1 的个数的序列的数量可以记作 Catn​； 一个栈的进栈序列为 1,2,3,…,n，不同的出栈序列的方案数； n 个节点可以构造的二叉树数目； 在圆上选择 2n 个点，将这些点成对连接起来使得所得到的 n 条线段不相交的方法数； 等等。 参考资料 0x36 组合计数，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 排列组合，OI Wiki，2022 年 7 月 17 日。 卡特兰数，OI Wiki，2022 年 2 月 25 日。 组合数学，石家庄市第二中学信息学竞赛集训，张闰清，2022 年 1 月 19 日。 "},{"title":"「HNOI2010」弹飞绵羊","date":"2022-07-15T22:07:12.000Z","url":"/hnoi2010-bounce/","tags":["数据结构","BZOJ","洛谷","HNOI","2010","动态树","Link-Cut Tree","Splay"],"categories":["题解"],"content":" 题面 题目描述 某天，Lostmonkey 发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。 游戏一开始，Lostmonkey 在地上沿着一条直线摆上 n 个装置，每个装置设定初始弹力系数 ki​，当绵羊达到第 i 个装置时，它会往后弹 ki​ 步，达到第 i+ki​ 个装置，若不存在第 i+ki​ 个装置，则绵羊被弹飞。 绵羊想知道当它从第 i 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey 可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 输入格式 第一行包含一个整数 n，表示地上有 n 个装置，装置的编号从 0∼n−1。 接下来一行有 n 个正整数，依次为那 n 个装置的初始弹力系数。 第三行有一个正整数 m，表示操作次数。接下来 m 行每行至少有两个数 i,j。 若 i=1，你要输出从 j 出发被弹几次后被弹飞； 若 i=2，则还会再输入一个正整数 k，表示第 j 个弹力装置的系数被修改成 k。 输出格式 对于每个 i=1 的操作，输出一行一个整数表示答案。 输入输出样例 样例输入 #1 4 1 2 1 1 3 1 1 2 1 1 1 1 样例输出 #1 2 3 数据范围与约定 对于 20% 的数据，1≤n,m≤104； 对于 100% 的数据，1≤n≤2×105，1≤m≤105。 思路 首先将题中给的所有编号 +1 方便计算。 设节点 n+1 为终点，从所有可以弹飞的点连一条边到这个点上，就可以用 LCT 来求出路径上的节点数了。也有作为森林维护的方法，此处不再做过多说明。 代码 #include &lt;iostream&gt; #include &lt;stack&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 2e5 + 5; int n, m, a[N]; class LinkCutTree &#123; private: struct node &#123; size_t l, r, f; unsigned s; bool rev; node() : l(0), r(0), f(0), s(0), rev(false) &#123;&#125; node(size_t _f) : l(0), r(0), f(_f), s(1), rev(false) &#123;&#125; size_t &amp;child(unsigned x) &#123; return !x ? l : r; &#125; &#125; tr[N]; inline void pushup(size_t u) &#123; tr[u].s = tr[tr[u].l].s + 1 + tr[tr[u].r].s; &#125; inline void pushdown(const size_t &amp;u) &#123; if (!tr[u].rev) return; std::swap(tr[u].l, tr[u].r); tr[tr[u].l].rev = !tr[tr[u].l].rev; tr[tr[u].r].rev = !tr[tr[u].r].rev; tr[u].rev = false; &#125; unsigned relation(const size_t &amp;u) &#123; return u == tr[tr[u].f].l ? 0 : 1; &#125; bool isRoot(const size_t &amp;u) &#123; return tr[tr[u].f].l != u &amp;&amp; tr[tr[u].f].r != u; &#125; void rotate(size_t u) &#123; size_t p = tr[u].f; unsigned x = relation(u); if (!isRoot(p)) &#123; tr[tr[p].f].child(relation(p)) = u; &#125; tr[u].f = tr[p].f; if (tr[u].child(x ^ 1)) &#123; tr[tr[u].child(x ^ 1)].f = p; &#125; tr[p].child(x) = tr[u].child(x ^ 1); tr[u].child(x ^ 1) = p; tr[p].f = u; pushup(p); pushup(u); &#125; void splay(size_t u) &#123; std::stack&lt;size_t&gt; st; size_t cur = u; st.push(cur); while (!isRoot(cur)) &#123; st.push(tr[cur].f); cur = tr[cur].f; &#125; while (!st.empty()) &#123; pushdown(st.top()); st.pop(); &#125; while (!isRoot(u)) &#123; if (isRoot(tr[u].f)) &#123; rotate(u); &#125; else if (relation(u) == relation(tr[u].f)) &#123; rotate(tr[u].f); rotate(u); &#125; else &#123; rotate(u); rotate(u); &#125; &#125; &#125; void access(size_t u) &#123; for (size_t f = 0; u; u = tr[f = u].f) &#123; splay(u); tr[u].r = f; pushup(u); &#125; &#125; void makeRoot(const size_t &amp;u) &#123; access(u); splay(u); tr[u].rev = !tr[u].rev; &#125; size_t findRoot(size_t u) &#123; access(u); splay(u); while (tr[u].l) &#123; u = tr[u].l; &#125; return u; &#125; void split(const size_t &amp;x, const size_t &amp;y) &#123; makeRoot(x); access(y); splay(y); &#125; public: unsigned query(int x, int y) &#123; split(x, y); return tr[y].s; &#125; void link(const int &amp;x, const int &amp;y) &#123; makeRoot(x); if (findRoot(y) != x) &#123; tr[x].f = y; &#125; &#125; void cut(int x, int y) &#123; split(x, y); if (tr[y].l == x) &#123; tr[y].l = 0; tr[x].f = 0; &#125; &#125; &#125; lct; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; lct.link(i, std::min(i + a[i], n + 1)); &#125; cin &gt;&gt; m; while (m--) &#123; int op, x, y; cin &gt;&gt; op; if (op == 1) &#123; cin &gt;&gt; x; cout &lt;&lt; lct.query(x + 1, n + 1) - 1 &lt;&lt; endl; &#125; else &#123; // op == 2 cin &gt;&gt; x &gt;&gt; y; x++; lct.cut(x, std::min(x + a[x], n + 1)); lct.link(x, std::min(x + (a[x] = y), n + 1)); &#125; &#125; return 0; &#125; "},{"title":"Link-Cut Tree 学习笔记","date":"2022-07-15T21:52:19.000Z","url":"/link-cut-tree/","tags":["数据结构","Treap","动态树","Link-Cut Tree","Splay"],"categories":["笔记"],"content":"Link-Cut Tree 是一种用来解决动态树问题的数据结构。 它采用类似树链剖分的轻重边路径剖分，把树边分为实边和虚边，并用 Splay 来维护每一条实路径。Link-Cut Tree 的基本操作复杂度为均摊 O(logn)，但常数因子较大，一般效率会低于树链剖分。 主要操作 Splay 相关 LCT 中的 Splay 与原版 Splay 之间存在一定差别。 isRoot 函数 判断节点 u 是否为其所属 Splay 的根。 bool isRoot(const size_t &amp;u) &#123; return tr[tr[u].f].l != u &amp;&amp; tr[tr[u].f].r != u; &#125; 旋转（rotate）操作 判断根不能以父亲节点是否存在为依据，而应该使用上文中的 isRoot() 函数。 对比代码 void rotate(size_t u) &#123; size_t p = tr[u].f; unsigned x = relation(u); - if (tr[p].f) &#123; + if (!isRoot(p)) &#123; tr[tr[p].f].child(relation(p)) = u; &#125; tr[u].f = tr[p].f;void rotate(size_t u) &#123; size_t p = tr[u].f; unsigned x = relation(u); if (!isRoot(p)) &#123; tr[tr[p].f].child(relation(p)) = u; &#125; tr[u].f = tr[p].f; if (tr[u].child(x ^ 1)) &#123; tr[tr[u].child(x ^ 1)].f = p; &#125; tr[p].child(x) = tr[u].child(x ^ 1); tr[u].child(x ^ 1) = p; tr[p].f = u; pushup(p); pushup(u); &#125; Splay 操作 要先自顶到下将路径上的所有节点 pushdown 后再进行 Splay 操作。 对比代码-void splay(size_t u, size_t t = 0) &#123; +void splay(size_t u) &#123; + std::stack&lt;size_t&gt; st; + size_t cur = u; + st.push(cur); + while (!isRoot(cur)) &#123; + st.push(tr[cur].f); + cur = tr[cur].f; + &#125; + while (!st.empty()) &#123; + pushdown(st.top()); + st.pop(); + &#125; - while (tr[u].f != t) &#123; - if (tr[tr[u].f].f == t) &#123; + while (!isRoot(u)) &#123; + if (isRoot(tr[u].f)) &#123; rotate(u); &#125; else if (relation(u) == relation(tr[u].f)) &#123; rotate(tr[u].f); rotate(u); &#125; else &#123; rotate(u); rotate(u); &#125; &#125; - - if (!t) root = u; &#125;void splay(size_t u) &#123; std::stack&lt;size_t&gt; st; size_t cur = u; st.push(cur); while (!isRoot(cur)) &#123; st.push(tr[cur].f); cur = tr[cur].f; &#125; while (!st.empty()) &#123; pushdown(st.top()); st.pop(); &#125; while (!isRoot(u)) &#123; if (isRoot(tr[u].f)) &#123; rotate(u); &#125; else if (relation(u) == relation(tr[u].f)) &#123; rotate(tr[u].f); rotate(u); &#125; else &#123; rotate(u); rotate(u); &#125; &#125; &#125; Access 操作 该操作意为「访问」节点 u，被访问过的节点会有一条实路径连接到根节点，且该节点在这条路径的头部（最下端）。 void access(size_t u) &#123; for (size_t f = 0; u; u = tr[f = u].f) &#123; splay(u); tr[u].r = f; pushup(u); &#125; &#125; makeRoot 操作 使节点 u 成为原树的根。 void makeRoot(const size_t &amp;u) &#123; access(u); splay(u); tr[u].rev = !tr[u].rev; &#125; Split 操作 将 x∼y 的路径单独抽成一棵 Splay。 void split(const size_t &amp;x, const size_t &amp;y) &#123; makeRoot(x); access(y); splay(y); &#125; Link 操作 在 x 节点和 y 节点之间连一条边，使其成为同一棵树内的两个节点。 void link(const int &amp;x, const int &amp;y) &#123; makeRoot(x); if (findRoot(y) != x) &#123; tr[x].f = y; &#125; &#125; Cut 操作 切断 x 和 y 之间的路径。 void cut(int x, int y) &#123; split(x, y); if (tr[y].l == x) &#123; // 只有路径存在时才删除 tr[y].l = 0; tr[x].f = 0; &#125; &#125; 代码 SplayFHQ Treap#include &lt;iostream&gt; #include &lt;stack&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5; class LinkCutTree &#123; private: struct node &#123; size_t l, r, f; unsigned v, s; bool rev; node() : l(0), r(0), f(0), s(0), v(0), rev(false) &#123;&#125; node(unsigned _v, size_t _f) : l(0), r(0), f(_f), s(_v), v(_v), rev(false) &#123;&#125; size_t &amp;child(unsigned x) &#123; return !x ? l : r; &#125; &#125; tr[N]; inline void pushup(size_t u) &#123; tr[u].s = tr[tr[u].l].s ^ tr[u].v ^ tr[tr[u].r].s; &#125; inline void pushdown(const size_t &amp;u) &#123; if (!tr[u].rev) return; std::swap(tr[u].l, tr[u].r); tr[tr[u].l].rev = !tr[tr[u].l].rev; tr[tr[u].r].rev = !tr[tr[u].r].rev; tr[u].rev = false; &#125; unsigned relation(const size_t &amp;u) &#123; return u == tr[tr[u].f].l ? 0 : 1; &#125; bool isRoot(const size_t &amp;u) &#123; return tr[tr[u].f].l != u &amp;&amp; tr[tr[u].f].r != u; &#125; void rotate(size_t u) &#123; size_t p = tr[u].f; unsigned x = relation(u); if (!isRoot(p)) &#123; tr[tr[p].f].child(relation(p)) = u; &#125; tr[u].f = tr[p].f; if (tr[u].child(x ^ 1)) &#123; tr[tr[u].child(x ^ 1)].f = p; &#125; tr[p].child(x) = tr[u].child(x ^ 1); tr[u].child(x ^ 1) = p; tr[p].f = u; pushup(p); pushup(u); &#125; void splay(size_t u) &#123; std::stack&lt;size_t&gt; st; size_t cur = u; st.push(cur); while (!isRoot(cur)) &#123; st.push(tr[cur].f); cur = tr[cur].f; &#125; while (!st.empty()) &#123; pushdown(st.top()); st.pop(); &#125; while (!isRoot(u)) &#123; if (isRoot(tr[u].f)) &#123; rotate(u); &#125; else if (relation(u) == relation(tr[u].f)) &#123; rotate(tr[u].f); rotate(u); &#125; else &#123; rotate(u); rotate(u); &#125; &#125; &#125; void access(size_t u) &#123; for (size_t f = 0; u; u = tr[f = u].f) &#123; splay(u); tr[u].r = f; pushup(u); &#125; &#125; void makeRoot(const size_t &amp;u) &#123; access(u); splay(u); tr[u].rev = !tr[u].rev; &#125; size_t findRoot(size_t u) &#123; access(u); splay(u); while (tr[u].l) &#123; u = tr[u].l; &#125; return u; &#125; void split(const size_t &amp;x, const size_t &amp;y) &#123; makeRoot(x); access(y); splay(y); &#125; public: void set(int p, int v) &#123; tr[p].s = tr[p].v = v; &#125; unsigned query(int x, int y) &#123; split(x, y); return tr[y].s; &#125; void link(const int &amp;x, const int &amp;y) &#123; makeRoot(x); if (findRoot(y) != x) &#123; tr[x].f = y; &#125; &#125; void cut(int x, int y) &#123; split(x, y); if (tr[y].l == x) &#123; tr[y].l = 0; tr[x].f = 0; &#125; &#125; void change(int p, int v) &#123; access(p); splay(p); tr[p].v = v; pushup(p); &#125; &#125; lct; int n, m; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1, x; i &lt;= n; i++) &#123; cin &gt;&gt; x; lct.set(i, x); &#125; while (m--) &#123; int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; switch (op) &#123; case 0: &#123; cout &lt;&lt; lct.query(x, y) &lt;&lt; endl; break; &#125; case 1: &#123; lct.link(x, y); break; &#125; case 2: &#123; lct.cut(x, y); break; &#125; case 3: &#123; lct.change(x, y); break; &#125; &#125; &#125; return 0; &#125;#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;stack&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5; // Link-Cut Tree class LinkCutTree &#123; private: std::stack&lt;bool&gt; st; struct node &#123; int p, // 父亲节点 l, // 左儿子 r; // 右儿子 int pre; int val, // 节点值 sum; // 异或和 int key; // 权值 bool rev; // 翻转标记 node() : p(0), l(0), r(0), pre(0), val(0), sum(0), key(rand()), rev(false) &#123;&#125; &#125; tr[N]; void pushup(int u) &#123; // 计算异或和 tr[u].sum = tr[tr[u].l].sum ^ tr[u].val ^ tr[tr[u].r].sum; // 标记父亲节点 if (tr[u].l) tr[tr[u].l].p = u; if (tr[u].r) tr[tr[u].r].p = u; &#125; void pushdown(int u) &#123; if (!tr[u].rev) return; tr[u].rev = false; std::swap(tr[u].l, tr[u].r); tr[tr[u].l].rev ^= 1; tr[tr[u].r].rev ^= 1; &#125; std::pair&lt;int, int&gt; split(int u) &#123; if (st.empty()) &#123; pushdown(u); auto t = std::make_pair(u, tr[u].r); tr[u].r = 0; pushup(u); return t; &#125; bool d = st.top() ^ tr[u].rev; st.pop(); pushdown(u); if (d) &#123; auto t = split(tr[u].l); tr[u].l = t.second; pushup(u); return std::make_pair(t.first, u); &#125; auto t = split(tr[u].r); tr[u].r = t.first; pushup(u); return std::make_pair(u, t.second); &#125; // 合并 int merge(int x, int y) &#123; if (!x || !y) return x | y; if (tr[x].key &lt; tr[y].key) &#123; pushdown(x); tr[x].r = merge(tr[x].r, y); pushup(x); return x; &#125; pushdown(y); tr[y].l = merge(x, tr[y].l); pushup(y); return y; &#125; // 是否是根节点 bool isRoot(int u) &#123; return !tr[u].p || (tr[tr[u].p].l != u &amp;&amp; tr[tr[u].p].r != u); &#125; // 查找根节点 int findRoot(int u) &#123; while (!st.empty()) st.pop(); while (!isRoot(u)) &#123; // pushdown(u); st.push(tr[tr[u].p].l == u); u = tr[u].p; &#125; return u; &#125; int findLeft(int u) &#123; u = findRoot(u); pushdown(u); while (tr[u].l) &#123; u = tr[u].l; pushdown(u); &#125; return u; &#125; int access(int u) &#123; int lst = 0; while (u) &#123; auto t = split(findRoot(u)); tr[findLeft(lst)].pre = 0; lst = merge(t.first, lst); tr[findLeft(t.second)].pre = u; u = tr[findLeft(lst)].pre; &#125; return lst; &#125; void makeRoot(int u) &#123; tr[access(u)].rev ^= 1; &#125; public: int getRoot(int u) &#123; return findLeft(access(u)); &#125; void link(int x, int y) &#123; makeRoot(x); tr[x].pre = y; &#125; void cut(int x, int y) &#123; makeRoot(x); access(y); access(x); tr[y].pre = 0; &#125; int query(int x, int y) &#123; makeRoot(x); access(y); auto t = split(findRoot(y)); int res = tr[t.first].sum; merge(t.first, t.second); return res; &#125; void change(int u, int val) &#123; makeRoot(u); auto t = split(findRoot(u)); tr[u].val = val; merge(t.first, t.second); &#125; void set(int u, int val) &#123; tr[u].sum = tr[u].val = val; &#125; &#125; lct; int n, m; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1, x; i &lt;= n; i++) &#123; cin &gt;&gt; x; lct.set(i, x); &#125; while (m--) &#123; int op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; switch (op) &#123; case 0: &#123; cout &lt;&lt; lct.query(x, y) &lt;&lt; endl; break; &#125; case 1: &#123; if (lct.getRoot(x) != lct.getRoot(y)) &#123; lct.link(x, y); &#125; break; &#125; case 2: &#123; lct.cut(x, y); break; &#125; case 3: &#123; lct.change(x, y); break; &#125; &#125; &#125; return 0; &#125; 参考资料 平衡树 &amp; LCT，石家庄市第二中学信息学奥赛集训（线下授课），张闰清，2022 年 7 月 12 日。 "},{"title":"Splay 学习笔记","date":"2022-07-15T09:07:48.000Z","url":"/splay/","tags":["数据结构","平衡树","Splay"],"categories":["笔记"],"content":"Splay 是一种二叉查找树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链。它可以在 O(logn) 的时间内完成基于 Splay 操作的修改与查询。 本文提供使用原生指针和数组模拟指针两种方法实现的代码，可以点击代码块上方的切换按钮查看两种不同版本的代码。 辅助函数 / 类 node 结构体 以下为每个 Splay 节点的定义。 指针数组struct node &#123; int value; node *lchild, *rchild, *parent, **root; size_t size, count; node() : value(0), lchild(nullptr), rchild(nullptr), parent(nullptr), root(nullptr), size(0), count(0) &#123;&#125; node(const int &amp;_value, node *_parent, node **_root) : value(_value), lchild(nullptr), rchild(nullptr), parent(_parent), root(_root), size(1), count(1) &#123;&#125; ~node() &#123; if (lchild != nullptr) delete lchild; if (rchild != nullptr) delete rchild; &#125; &#125;; 节点中的 root 表示指向根节点的指针的指针。这样做可以方便从任意一个节点找到整棵 Splay 的根节点，并修改它。 size 表示以当前节点为根的 Splay 共有多少个节点（包括自身），有了 size，就可以轻松地实现选择和排名操作。 此处在 node 的析构函数中递归释放所有内存以避免内存泄漏。struct node &#123; size_t l, r, f, c, s; int v; node() : l(0), r(0), f(0), c(0), s(0), v(0) &#123;&#125; node(T _v, size_t _f) : l(0), r(0), f(_f), c(1), s(1), v(_v) &#123;&#125; &#125;; s 表示以当前节点为根的 Splay 共有多少个节点（包括自身），有了它就可以轻松地实现选择和排名操作。 关系（relation） / 儿子（child） 为了旋转操作的方便，我们给每个节点设置一个「关系」属性，表示该节点与其父节点的关系，若该节点为左孩子，则「关系」为 0，反之则为 1。relation() 方法用来计算这个「关系」，而 child() 方法返回与该节点「关系」为 x 的子节点的引用。 指针数组node *&amp;child(unsigned int x) &#123; return !x ? lchild : rchild; &#125; unsigned relation() const &#123; // 如果当前节点是其父亲节点的左儿子则返回 0，否则返回 1 return this == parent-&gt;lchild ? 0 : 1; &#125;struct node &#123; // ... size_t &amp;child(unsigned x) &#123; return !x ? l : r; &#125; // ... &#125;; unsigned relation(const size_t &amp;u) &#123; // 如果当前节点是其父亲节点的左儿子则返回 0，否则返回 1 return u == tr[tr[u].f].l ? 0 : 1; &#125; 上传信息（pushup） 易错：不要忘记加上 count。 指针数组void pushup() &#123; size = lsize() + count + rsize(); &#125;inline void pushup(const size_t &amp;u) &#123; tr[u].s = tr[tr[u].l].s + tr[tr[u].r].s + tr[u].c; &#125; 主要操作 旋转（rotate） 为了使 Splay 保持平衡而进行旋转操作，旋转的本质是将某个节点上移一个位置。 旋转需要保证： 整棵 Splay 的中序遍历不变（不能破坏二叉查找树的性质）。 受影响的节点维护的信息依然正确有效。 root 必须指向旋转后的根节点。 在 Splay 中旋转分为两种：左旋和右旋。 以左旋（当前节点为父节点的左儿子为例），旋转分为三个步骤： 将祖父节点与自身连接； 将自己的右孩子接到自己的父节点的左孩子的位置（替代自己）； 将父节点接到自己的右孩子的位置。 指针数组void rotate() &#123; // 旧的父节点 node *old = parent; // 当前节点与父节点的关系 unsigned x = relation(); // 当前节点 &lt;-&gt; 父节点的父节点 if (old-&gt;parent != nullptr) &#123; old-&gt;parent-&gt;child(old-&gt;relation()) = this; &#125; parent = old-&gt;parent; // 原先的另一个子节点 &lt;-&gt; 父节点 if (child(x ^ 1) != nullptr) &#123; child(x ^ 1)-&gt;parent = old; &#125; old-&gt;child(x) = child(x ^ 1); // 原先的父节点 -&gt; 子节点 child(x ^ 1) = old; old-&gt;parent = this; // 更新节点信息 old-&gt;pushup(); pushup(); &#125;void rotate(size_t u) &#123; // 旧的父节点 size_t p = tr[u].f; // 当前节点与父节点之间的关系 unsigned x = relation(u); // 当前节点 &lt;-&gt; 父节点的父节点 if (tr[p].f) &#123; tr[tr[p].f].child(relation(p)) = u; &#125; tr[u].f = tr[p].f; // 原先的另一个子节点 &lt;-&gt; 父节点 if (tr[u].child(x ^ 1)) &#123; tr[tr[u].child(x ^ 1)].f = p; &#125; tr[p].child(x) = tr[u].child(x ^ 1); // 原先的父节点 -&gt; 子节点 tr[u].child(x ^ 1) = p; tr[p].f = u; // 更新节点信息 pushup(p); pushup(u); &#125; Splay Splay 规定：每访问一个节点后都要强制将其旋转到根节点。此时旋转操作具体分为 6 种情况讨论（其中 x 为需要旋转到根的节点） 如果 x 的父亲是根节点，直接将 x 左旋或右旋（图 1, 2）。 如果 x 的父亲不是根节点，且 x 和父亲节点的「关系」和父亲和父亲的父亲节点的「关系」相同，首先将其父亲左旋或右旋，然后将 x 右旋或左旋（图 3, 4）。 如果 x 的父亲不是根节点，且 x 和父亲节点的「关系」和父亲和父亲的父亲节点的「关系」不同，将 x 左旋再右旋、或者右旋再左旋（图 5, 6）。 如果 Splay 操作的目标为 nullptr 则更新根节点。 指针数组// 旋转到给定的位置（target），默认行为为旋转为根节点 void splay(node *target = nullptr) &#123; while (parent != target) &#123; // 父节点不是目标节点 if (parent-&gt;parent == target) &#123; // 祖父节点是目标节点 rotate(); &#125; else if (relation() == parent-&gt;relation()) &#123; // 关系相同 parent-&gt;rotate(); rotate(); &#125; else &#123; rotate(); rotate(); &#125; &#125; // 更新根节点 if (target == nullptr) *root = this; &#125;// 旋转到给定的位置（target），默认行为为旋转为根节点 void splay(size_t u, size_t t = 0) &#123; while (tr[u].f != t) &#123; if (tr[tr[u].f].f == t) &#123; rotate(u); &#125; else if (relation(u) == relation(tr[u].f)) &#123; rotate(tr[u].f); rotate(u); &#125; else &#123; rotate(u); rotate(u); &#125; &#125; // 更新根节点 if (!t) root = u; &#125; 插入（insert） 根据 BST 的性质二分查找插入即可。 指针数组node *_insert(const int &amp;value) &#123; node **target = &amp;root, *parent = nullptr; while (*target != nullptr &amp;&amp; (*target)-&gt;value != value) &#123; parent = *target; parent-&gt;size++; // 根据大小向左右子树迭代 if (value &lt; parent-&gt;value) &#123; target = &amp;parent-&gt;lchild; &#125; else &#123; target = &amp;parent-&gt;rchild; &#125; &#125; if (*target == nullptr) &#123; *target = new node(value, parent, &amp;root); &#125; else &#123; // 存在现有节点直接修改节点信息即可 (*target)-&gt;count++; (*target)-&gt;size++; // 易忘：修改节点信息后需要更新节点大小 &#125; (*target)-&gt;splay(); return root; &#125;size_t _insert(const int &amp;v) &#123; size_t u = root, f = 0; while (u &amp;&amp; tr[u].v != v) &#123; f = u; // 根据数值大小向左右子树迭代 u = v &lt; tr[u].v ? tr[u].l : tr[u].r; &#125; if (u) &#123; tr[u].c++; tr[u].s++; // 易忘：修改节点信息后需要更新节点大小 &#125; else &#123; tr[u = ++cnt] = node(v, f); if (f) tr[f].child(v &gt; tr[f].v) = u; // 易忘：更新父节点信息 &#125; splay(u); return root; &#125; 为了下文操作中的方便，在建树时可以预先插入两个哨兵节点以防越界。 查找（find） 同样地，根据 BST 的性质二分查找即可。 指针数组// 查找指定的值对应的节点 node *find(const int &amp;value) &#123; node *node = root; // 从根节点开始查找 while (node != nullptr &amp;&amp; value != node-&gt;value) &#123; // 根据数值大小向左右子树迭代 node = value &lt; node-&gt;value ? node-&gt;lchild : node-&gt;rchild; &#125; if (node != nullptr) &#123; node-&gt;splay(); &#125; return node; &#125;size_t _find(const int &amp;v) &#123; size_t u = root; while (u &amp;&amp; tr[u].v != v) &#123; // 根据数值大小向左右子树迭代 u = v &lt; tr[u].v ? tr[u].l : tr[u].r; &#125; if (u) splay(u); return u; &#125; 排名（rank） 排名函数返回树中比给定值小的数的个数。 指针数组unsigned rank(const int &amp;value) &#123; node *node = find(value); if (node == nullptr) &#123; // 不存在则插入一个方便查找 node = _insert(value); // 此时 node 已经成为根节点，直接计算即可 unsigned res = node-&gt;lsize(); // 由于「哨兵」的存在，此处无需 -1 erase(node); return res; &#125; // 此时 node 已经成为根节点，直接计算即可 return node-&gt;lsize(); &#125;unsigned rank(const int &amp;v) &#123; size_t u = _find(v); if (!u) &#123; // 不存在则插入一个方便查找 u = _insert(v); // 此时 u 已经成为根节点，直接取左子树大小即可 unsigned r = tr[tr[u].l].s; _erase(u); return r; &#125; return tr[tr[u].l].s; &#125; 选择（select） 选择函数返回树中第 k 大的元素。传入的 k 应保证不大于树中元素个数。 指针数组const int &amp;select(unsigned k) &#123; node *node = root; while (k &lt; node-&gt;lsize() || k &gt;= node-&gt;lsize() + node-&gt;count) &#123; if (k &lt; node-&gt;lsize()) &#123; // 所需的节点在左子树中 node = node-&gt;lchild; &#125; else &#123; k -= node-&gt;lsize() + node-&gt;count; node = node-&gt;rchild; &#125; &#125; node-&gt;splay(); return node-&gt;value; &#125;const int &amp;select(unsigned k) &#123; size_t u = root; while (k &lt; tr[tr[u].l].s || k &gt;= tr[tr[u].l].s + tr[u].c) &#123; if (k &lt; tr[tr[u].l].s) &#123; u = tr[u].l; &#125; else &#123; k -= tr[tr[u].l].s + tr[u].c; u = tr[u].r; &#125; &#125; splay(u); return tr[u].v; &#125; 节点的前驱（predecessor）和后继（successor） 由 BST 的性质，前驱为左子树中最靠右的节点，后继为右子树中最靠左的节点。 指针数组// 前驱 // // 左子树的最右点 node *predecessor() &#123; node *pred = lchild; while (pred-&gt;rchild != nullptr) &#123; pred = pred-&gt;rchild; &#125; return pred; &#125; // 后继 // // 右子树的最左点 node *successor() &#123; node *succ = rchild; while (succ-&gt;lchild != nullptr) &#123; succ = succ-&gt;lchild; &#125; return succ; &#125;// 前驱 // // 左子树的最右点 size_t _predecessor(const size_t &amp;u) &#123; size_t cur = tr[u].l; while (tr[cur].r) &#123; cur = tr[cur].r; &#125; return cur; &#125; // 后继 // // 右子树的最左点 size_t _successor(const size_t &amp;u) &#123; size_t cur = tr[u].r; while (tr[cur].l) &#123; cur = tr[cur].l; &#125; return cur; &#125; 值的前驱（predecessor）和后继（successor） 使用 find() 函数找到对应的节点，再查询节点的前驱与后继即可。如果不存在则新建一个节点来辅助查询。 指针数组// 前驱 const int &amp;predecessor(const int &amp;value) &#123; node *node = find(value); if (node == nullptr) &#123; node = _insert(value); const int &amp;result = node-&gt;predecessor()-&gt;value; erase(node); return result; &#125; return node-&gt;predecessor()-&gt;value; &#125; // 后继 const int &amp;successor(const int &amp;value) &#123; node *node = find(value); if (node == nullptr) &#123; node = _insert(value); const int &amp;result = node-&gt;successor()-&gt;value; erase(node); return result; &#125; return node-&gt;successor()-&gt;value; &#125;// 前驱 const int &amp;predecessor(const int &amp;v) &#123; size_t u = _find(v); if (!u) &#123; // 不存在则插入一个方便查找 u = _insert(v); const int &amp;r = tr[_predecessor(u)].v; _erase(u); // 删除 return r; &#125; return tr[_predecessor(u)].v; &#125; // 后继 const int &amp;successor(const int &amp;v) &#123; size_t u = _find(v); if (!u) &#123; // 不存在则插入一个方便查找 u = _insert(v); const int &amp;r = tr[_successor(u)].v; _erase(u); // 删除 return r; &#125; return tr[_successor(u)].v; &#125; 删除（erase） 如果该节点上有多个相同的值，删除其中一个即可。否则删除节点。 指针数组// 删除节点 void erase(node *u) &#123; if (u == nullptr) return; if (u-&gt;count &gt; 1) &#123; // 存在重复的数 u-&gt;splay(); u-&gt;count--; u-&gt;size--; return; &#125; node *pred = u-&gt;predecessor(), *succ = u-&gt;successor(); pred-&gt;splay(); // 将前驱旋转到根节点 succ-&gt;splay(pred); // 将后继旋转到根节点的右儿子 delete succ-&gt;lchild; // 此时要删的节点为根节点的左儿子且为叶子节点 succ-&gt;lchild = nullptr; // 更新节点信息 succ-&gt;pushup(); pred-&gt;pushup(); &#125; // 删除值 void erase(const int &amp;value) &#123; erase(find(value)); &#125;// 删除节点 void _erase(size_t u) &#123; if (!u) return; if (tr[u].c &gt; 1) &#123; // 存在重复的数 splay(u); tr[u].c--; tr[u].s--; return; &#125; size_t pred = _predecessor(u), succ = _successor(u); splay(pred); // 将前驱旋转到根节点 splay(succ, pred); // 将后继旋转到根节点的右儿子 tr[succ].l = 0; // 此时要删的节点为根节点的左儿子且为叶子节点 // 更新节点信息 pushup(succ); pushup(pred); &#125; // 删除值 void erase(const int &amp;v) &#123; _erase(_find(v)); &#125; 代码 指针数组#include &lt;limits&gt; template &lt;typename T&gt; class Splay &#123; private: struct node &#123; T value; node *lchild, *rchild, *parent, **root; size_t size, count; node() : value(0), lchild(nullptr), rchild(nullptr), parent(nullptr), root(nullptr), size(0), count(0) &#123;&#125; node(const T &amp;_value, node *_parent, node **_root) : value(_value), lchild(nullptr), rchild(nullptr), parent(_parent), root(_root), size(1), count(1) &#123;&#125; ~node() &#123; if (lchild != nullptr) delete lchild; if (rchild != nullptr) delete rchild; &#125; node *&amp;child(unsigned int x) &#123; return !x ? lchild : rchild; &#125; unsigned relation() const &#123; // 如果当前节点是其父亲节点的左儿子则返回 0，否则返回 1 return this == parent-&gt;lchild ? 0 : 1; &#125; // 左儿子大小 size_t lsize() const &#123; return lchild == nullptr ? 0 : lchild-&gt;size; &#125; // 右儿子大小 size_t rsize() const &#123; return rchild == nullptr ? 0 : rchild-&gt;size; &#125; // 上传信息 void pushup() &#123; size = lsize() + count + rsize(); &#125; // 旋转 void rotate() &#123; // 旧的父节点 node *old = parent; // 当前节点与父节点的关系 unsigned x = relation(); // 当前节点 &lt;-&gt; 父节点的父节点 if (old-&gt;parent != nullptr) &#123; old-&gt;parent-&gt;child(old-&gt;relation()) = this; &#125; parent = old-&gt;parent; // 原先的另一个子节点 &lt;-&gt; 父节点 if (child(x ^ 1) != nullptr) &#123; child(x ^ 1)-&gt;parent = old; &#125; old-&gt;child(x) = child(x ^ 1); // 原先的父节点 -&gt; 子节点 child(x ^ 1) = old; old-&gt;parent = this; // 更新节点信息 old-&gt;pushup(); pushup(); &#125; // Splay // // 旋转到给定的位置（target），默认行为为旋转为根节点 void splay(node *target = nullptr) &#123; while (parent != target) &#123; // 父节点不是目标节点 if (parent-&gt;parent == target) &#123; // 祖父节点是目标节点 rotate(); &#125; else if (relation() == parent-&gt;relation()) &#123; // 关系相同 parent-&gt;rotate(); rotate(); &#125; else &#123; rotate(); rotate(); &#125; &#125; // 更新根节点 if (target == nullptr) *root = this; &#125; // 前驱 // // 左子树的最右点 node *predecessor() &#123; node *pred = lchild; while (pred-&gt;rchild != nullptr) &#123; pred = pred-&gt;rchild; &#125; return pred; &#125; // 后继 // // 右子树的最左点 node *successor() &#123; node *succ = rchild; while (succ-&gt;lchild != nullptr) &#123; succ = succ-&gt;lchild; &#125; return succ; &#125; &#125; * root; // 插入（内部函数） node *_insert(const T &amp;value) &#123; node **target = &amp;root, *parent = nullptr; while (*target != nullptr &amp;&amp; (*target)-&gt;value != value) &#123; parent = *target; parent-&gt;size++; // 根据大小向左右子树迭代 if (value &lt; parent-&gt;value) &#123; target = &amp;parent-&gt;lchild; &#125; else &#123; target = &amp;parent-&gt;rchild; &#125; &#125; if (*target == nullptr) &#123; *target = new node(value, parent, &amp;root); &#125; else &#123; // 存在现有节点直接修改节点信息即可 (*target)-&gt;count++; (*target)-&gt;size++; // 易忘：修改节点信息后需要更新节点大小 &#125; (*target)-&gt;splay(); return root; &#125; // 查找指定的值对应的节点 node *find(const T &amp;value) &#123; node *node = root; // 从根节点开始查找 while (node != nullptr &amp;&amp; value != node-&gt;value) &#123; if (value &lt; node-&gt;value) &#123; node = node-&gt;lchild; &#125; else &#123; node = node-&gt;rchild; &#125; &#125; if (node != nullptr) &#123; node-&gt;splay(); &#125; return node; &#125; // 删除 void erase(node *u) &#123; if (u == nullptr) return; if (u-&gt;count &gt; 1) &#123; // 存在重复的数 u-&gt;splay(); u-&gt;count--; u-&gt;size--; return; &#125; node *pred = u-&gt;predecessor(), *succ = u-&gt;successor(); pred-&gt;splay(); // 将前驱旋转到根节点 succ-&gt;splay(pred); // 将后继旋转到根节点的右儿子 delete succ-&gt;lchild; // 此时要删的节点为根节点的左儿子且为叶子节点 succ-&gt;lchild = nullptr; // 更新节点信息 succ-&gt;pushup(); pred-&gt;pushup(); &#125; public: Splay() : root(nullptr) &#123; // 哨兵节点 insert(std::numeric_limits&lt;T&gt;::min()); insert(std::numeric_limits&lt;T&gt;::max()); &#125; ~Splay() &#123; delete root; &#125; // 插入 void insert(const T &amp;value) &#123; _insert(value); &#125; // 删除 void erase(const T &amp;value) &#123; erase(find(value)); &#125; // 排名 unsigned rank(const T &amp;value) &#123; node *node = find(value); if (node == nullptr) &#123; node = _insert(value); // 此时 node 已经成为根节点，直接计算即可 int res = node-&gt;lsize(); // 由于「哨兵」的存在，此处无需 -1 erase(node); return res; &#125; // 此时 node 已经成为根节点，直接计算即可 return node-&gt;lsize(); &#125; // 选择 const T &amp;select(unsigned k) &#123; node *node = root; while (k &lt; node-&gt;lsize() || k &gt;= node-&gt;lsize() + node-&gt;count) &#123; if (k &lt; node-&gt;lsize()) &#123; // 所需的节点在左子树中 node = node-&gt;lchild; &#125; else &#123; k -= node-&gt;lsize() + node-&gt;count; node = node-&gt;rchild; &#125; &#125; node-&gt;splay(); return node-&gt;value; &#125; // 前驱 const T &amp;predecessor(const T &amp;value) &#123; node *node = find(value); if (node == nullptr) &#123; node = _insert(value); const T &amp;result = node-&gt;predecessor()-&gt;value; erase(node); return result; &#125; return node-&gt;predecessor()-&gt;value; &#125; // 后继 const T &amp;successor(const T &amp;value) &#123; node *node = find(value); if (node == nullptr) &#123; node = _insert(value); const T &amp;result = node-&gt;successor()-&gt;value; erase(node); return result; &#125; return node-&gt;successor()-&gt;value; &#125; &#125;;#include &lt;limits&gt; template &lt;typename T&gt; class Splay &#123; private: size_t root, cnt; struct node &#123; size_t l, r, f, c, s; T v; node() : l(0), r(0), f(0), c(0), s(0), v(0) &#123;&#125; node(T _v, size_t _f) : l(0), r(0), f(_f), c(1), s(1), v(_v) &#123;&#125; size_t &amp;child(unsigned x) &#123; return !x ? l : r; &#125; &#125; tr[N]; // 上传信息 inline void pushup(const size_t &amp;u) &#123; tr[u].s = tr[tr[u].l].s + tr[tr[u].r].s + tr[u].c; &#125; // 节点关系 unsigned relation(const size_t &amp;u) &#123; // 如果当前节点是其父亲节点的左儿子则返回 0，否则返回 1 return u == tr[tr[u].f].l ? 0 : 1; &#125; void rotate(size_t u) &#123; // 旧的父节点 size_t p = tr[u].f; // 当前节点与父节点之间的关系 unsigned x = relation(u); // 当前节点 &lt;-&gt; 父节点的父节点 if (tr[p].f) &#123; tr[tr[p].f].child(relation(p)) = u; &#125; tr[u].f = tr[p].f; // 原先的另一个子节点 &lt;-&gt; 父节点 if (tr[u].child(x ^ 1)) &#123; tr[tr[u].child(x ^ 1)].f = p; &#125; tr[p].child(x) = tr[u].child(x ^ 1); // 原先的父节点 -&gt; 子节点 tr[u].child(x ^ 1) = p; tr[p].f = u; // 更新节点信息 pushup(p); pushup(u); &#125; // Splay // // 旋转到给定的位置（target），默认行为为旋转为根节点 void splay(size_t u, size_t t = 0) &#123; while (tr[u].f != t) &#123; if (tr[tr[u].f].f == t) &#123; rotate(u); &#125; else if (relation(u) == relation(tr[u].f)) &#123; rotate(tr[u].f); rotate(u); &#125; else &#123; rotate(u); rotate(u); &#125; &#125; // 更新根节点 if (!t) root = u; &#125; // 前驱 // // 左子树的最右点 size_t _predecessor(const size_t &amp;u) &#123; size_t cur = tr[u].l; while (tr[cur].r) &#123; cur = tr[cur].r; &#125; return cur; &#125; // 后继 // // 右子树的最左点 size_t _successor(const size_t &amp;u) &#123; size_t cur = tr[u].r; while (tr[cur].l) &#123; cur = tr[cur].l; &#125; return cur; &#125; size_t _find(const T &amp;v) &#123; size_t u = root; while (u &amp;&amp; tr[u].v != v) &#123; // 根据数值大小向左右子树迭代 u = v &lt; tr[u].v ? tr[u].l : tr[u].r; &#125; if (u) splay(u); return u; &#125; size_t _insert(const T &amp;v) &#123; size_t u = root, f = 0; while (u &amp;&amp; tr[u].v != v) &#123; f = u; // 根据数值大小向左右子树迭代 u = v &lt; tr[u].v ? tr[u].l : tr[u].r; &#125; if (u) &#123; tr[u].c++; tr[u].s++; &#125; else &#123; tr[u = ++cnt] = node(v, f); if (f) tr[f].child(v &gt; tr[f].v) = u; &#125; splay(u); return root; &#125; void _erase(size_t u) &#123; if (!u) return; if (tr[u].c &gt; 1) &#123; // 存在重复的数 splay(u); tr[u].c--; tr[u].s--; return; &#125; size_t pred = _predecessor(u), succ = _successor(u); splay(pred); // 将前驱旋转到根节点 splay(succ, pred); // 将后继旋转到根节点的右儿子 tr[succ].l = 0; // 此时要删的节点为根节点的左儿子且为叶子节点 // 更新节点信息 pushup(succ); pushup(pred); &#125; public: Splay() : root(0), cnt(0) &#123; // 插入哨兵节点 insert(std::numeric_limits&lt;T&gt;::min()); insert(std::numeric_limits&lt;T&gt;::max()); &#125; // 插入 void insert(const T &amp;v) &#123; _insert(v); &#125; // 删除 void erase(const T &amp;v) &#123; _erase(_find(v)); &#125; // 排名 unsigned rank(const T &amp;v) &#123; size_t u = _find(v); if (!u) &#123; // 不存在则插入一个方便查找 u = _insert(v); // 此时 u 已经成为根节点，直接取左子树大小即可 unsigned r = tr[tr[u].l].s; _erase(u); return r; &#125; return tr[tr[u].l].s; &#125; // 选择 const T &amp;select(unsigned k) &#123; size_t u = root; while (k &lt; tr[tr[u].l].s || k &gt;= tr[tr[u].l].s + tr[u].c) &#123; if (k &lt; tr[tr[u].l].s) &#123; u = tr[u].l; &#125; else &#123; k -= tr[tr[u].l].s + tr[u].c; u = tr[u].r; &#125; &#125; splay(u); return tr[u].v; &#125; // 前驱 const T &amp;predecessor(const T &amp;v) &#123; size_t u = _find(v); if (!u) &#123; // 不存在则插入一个方便查找 u = _insert(v); const T &amp;r = tr[_predecessor(u)].v; _erase(u); // 删除 return r; &#125; return tr[_predecessor(u)].v; &#125; // 后继 const T &amp;successor(const T &amp;v) &#123; size_t u = _find(v); if (!u) &#123; // 不存在则插入一个方便查找 u = _insert(v); const T &amp;r = tr[_successor(u)].v; _erase(u); // 删除 return r; &#125; return tr[_successor(u)].v; &#125; &#125;; 参考资料 Splay 学习笔记（一），黄浩睿，2015 年 12 月 20 日。 Splay，OI Wiki，2022 年 3 月 20 日。 "},{"title":"「CERC2007」机械排序","date":"2022-07-14T08:04:43.000Z","url":"/cerc2007-sort/","tags":["数据结构","2014","CERC","2007","CQOI","平衡树","Treap"],"categories":["题解"],"content":" 题面 题目描述 SORT 公司是一个专门为人们提供排序服务的公司，该公司的宗旨是：“顺序是最美丽的”。他们的工作是通过一系列移动，将某些物品按顺序摆好。他们的工作规定只能使用如下方法排序： 先找到编号最小的物品的位置 P1​，将区间 [1,P1​] 反转，再找到编号第二小的物品的位置 P2​，将区间 [2,P2​] 反转…… 上图是有 6 个物品的例子，编号最小的一个是在第 4 个位置。因此，最开始把前面 4 个物品反转，第二小的物品在最后一个位置，所以下一个操作是把 2∼6 的物品反转，第三步操作是把 3∼4 的物品进行反转…… 在数据中可能存在有相同的编号，如果有多个相同的编号，则按输入的原始次序操作。 输入格式 输入共两行，第一行为一个整数 N，N 表示物品的个数（1≤N≤100000）。 第二行为 N 个用空格隔开的正整数，表示 N 个物品最初排列的编号。 输出格式 输出共一行，N 个用空格隔开的正整数 P1​,P2​,P3​,…,Pn​（1≤Pi​≤N），Pi​ 表示第 i 次操作前第 i 小的物品所在的位置。 注意：如果第 i 次操作前，第 i 小的物品己经在正确的位置 Pi​ 上，我们将区间 [Pi​,Pi​] 反转（单个物品）。 输入输出样例 样例输入 #1 6 3 4 5 1 6 2 样例输出 #1 4 6 4 5 6 6 思路 前置知识：文艺平衡树。 考虑按照排名处理，每次找到最小值的排名 k，然后翻转区间 [1,k]，再删去这个最小值。对于每次操作 k+i−1 即为答案。 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;limits&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5; struct node &#123; node *lchild, *rchild; size_t size; unsigned key; int value, min; bool reversed; node() : lchild(nullptr), rchild(nullptr), size(0), key(rand()), value(0), min(std::numeric_limits&lt;int&gt;::max()), reversed(false) &#123;&#125; node(int _value) : lchild(nullptr), rchild(nullptr), size(1), key(rand()), value(_value), min(_value), reversed(false) &#123;&#125; ~node() &#123; if (lchild != nullptr) delete lchild; if (rchild != nullptr) delete rchild; &#125; inline size_t lsize() &#123; return lchild == nullptr ? 0 : lchild-&gt;size; &#125; inline size_t rsize() &#123; return rchild == nullptr ? 0 : rchild-&gt;size; &#125; inline void pushup() &#123; size = lsize() + 1 + rsize(); min = value; if (lchild != nullptr) &#123; min = std::min(min, lchild-&gt;min); &#125; if (rchild != nullptr) &#123; min = std::min(min, rchild-&gt;min); &#125; &#125; inline void pushdown() &#123; if (reversed) &#123; std::swap(lchild, rchild); if (lchild != nullptr) lchild-&gt;reversed = !lchild-&gt;reversed; if (rchild != nullptr) rchild-&gt;reversed = !rchild-&gt;reversed; reversed = false; &#125; &#125; &#125;; int n, b[N]; std::pair&lt;int, int&gt; a[N]; node *root; std::pair&lt;node *, node *&gt; split(node *u, int k) &#123; if (u == nullptr) return std::make_pair(nullptr, nullptr); u-&gt;pushdown(); if (k &lt;= u-&gt;lsize()) &#123; auto o = split(u-&gt;lchild, k); u-&gt;lchild = o.second; u-&gt;pushup(); o.second = u; return o; &#125; auto o = split(u-&gt;rchild, k - u-&gt;lsize() - 1); u-&gt;rchild = o.first; u-&gt;pushup(); o.first = u; return o; &#125; node *merge(node *x, node *y) &#123; if (x == nullptr) return y; if (y == nullptr) return x; if (x-&gt;key &lt; y-&gt;key) &#123; x-&gt;pushdown(); x-&gt;rchild = merge(x-&gt;rchild, y); x-&gt;pushup(); return x; &#125; y-&gt;pushdown(); y-&gt;lchild = merge(x, y-&gt;lchild); y-&gt;pushup(); return y; &#125; void reverse(int k) &#123; auto x = split(root, k); auto y = split(x.first, k - 1); if (y.first != nullptr) y.first-&gt;reversed = !y.first-&gt;reversed; delete y.second; root = merge(y.first, x.second); &#125; int find(node *p) &#123; int k = 1; while (p != nullptr) &#123; p-&gt;pushdown(); if (p-&gt;lchild != nullptr &amp;&amp; p-&gt;min == p-&gt;lchild-&gt;min) &#123; p = p-&gt;lchild; &#125; else if (p-&gt;rchild != nullptr &amp;&amp; p-&gt;min == p-&gt;rchild-&gt;min) &#123; k += p-&gt;lsize() + 1; p = p-&gt;rchild; &#125; else &#123; return k + p-&gt;lsize(); &#125; &#125; return -1; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i].first; a[i].second = i; &#125; std::sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; i++) &#123; b[a[i].second] = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; root = merge(root, new node(b[i])); &#125; for (int i = 1; i &lt;= n; i++) &#123; int k = find(root); reverse(k); cout &lt;&lt; k + i - 1 &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; // Cleanup delete root; return 0; &#125; "},{"title":"「ZJOI2006」书架","date":"2022-07-13T03:49:15.000Z","url":"/zjoi2006-book/","tags":["数据结构","洛谷","2006","平衡树","Treap","ZJOI"],"categories":["题解"],"content":" 题面 题目描述 小 T 有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用 1 到 n 的正整数给每本书都编了号。 小 T 在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小 T 的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有 x 本书，那么放回去时这本书上面就只可能有 x−1、x 或 x+1 本书。 当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小 T 会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。 久而久之，小 T 的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问： 编号为 x 的书在书柜的什么位置。 从上到下第 i 本书的编号是多少。 输入格式 第一行有两个整数，分别表示书的个数 n 以及命令条数 m。 第二行有 n 个整数，第 i 个整数表示初始时从上向下书第 i 本书的编号 pi​。 接下来 m 行，每行表示一个操作。每行初始时有一个字符串 op。 若 op 为 Top，则后有一个整数 s，表示把编号为 s 的书放在最上面。 若 op 为 Bottom，则后有一个整数 s，表示把编号为 s 的书放在最下面。 若 op 为 Insert，则后有两个整数 s,t，表示若编号为 s 的书上面有 x 本书，则放回这本书时他的上面有 x+t 本书。 若 op 为 Ask，则后面有一个整数 s，表示询问编号为 s 的书上面有几本书。 若 op 为 Query，则后面有一个整数 s，询问从上面起第 s 本书的编号。 输出格式 对于每次查询，输出一行一个整数表示答案。 输入输出样例 样例输入 #1 10 10 1 3 2 7 5 8 10 4 9 6 Query 3 Top 5 Ask 6 Bottom 3 Ask 3 Top 6 Insert 4 -1 Query 5 Query 2 Ask 2 样例输出 #1 2 9 9 7 5 3 数据规模与约定 对于 100% 的数据，保证： 3≤n,m≤8×104； pi​ 是一个 1∼n 的排列； 1≤s≤n，−1≤t≤1，op 只可能是输入的五种字符串之一； 当编号为 s 的书上面没有书的时候，不会对它进行 Insert s -1 操作； 当编号为 s 的书下面没有书的时候，不会对它进行 Insert s 1 操作。 思路 本题可以使用 FHQ Treap 解决。 设 px​ 记录编号为 x 的书对应的节点，方便后续操作。 执行 Top 操作时将整棵树分裂成三份 —— s 之前的书，s 本身，s 之后的书。然后将其重拍顺序合并。Bottom 操作同理。 对于 Insert 操作，有三种情况： 当 t=0 时，无需进行任何操作； 当 t&lt;0 时，将 s 插入到 s 前的第 −t 个位置； 当 t&gt;0 时，将 s 插入到 s 后的第 t 个位置。 对于 Ask 操作直接输出 s 在树上的排名即可。 对于 Query 操作，在树上执行分裂，将第 s 本书取出来记录编号再合并即可。 代码 #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 8e4 + 5; struct node &#123; node *lchild, *rchild, *fa; std::size_t size; int value, key; node() : lchild(nullptr), rchild(nullptr), fa(nullptr), size(0), value(0), key(rand()) &#123;&#125; node(int _value) : lchild(nullptr), rchild(nullptr), fa(nullptr), size(1), value(_value), key(rand()) &#123;&#125; ~node() &#123; if (lchild != nullptr) delete lchild; if (rchild != nullptr) delete rchild; &#125; inline std::size_t lsize() &#123; return lchild == nullptr ? 0 : lchild-&gt;size; &#125; inline std::size_t rsize() &#123; return rchild == nullptr ? 0 : rchild-&gt;size; &#125; inline void pushup() &#123; size = 1; if (lchild != nullptr) &#123; size += lchild-&gt;size; lchild-&gt;fa = this; &#125; if (rchild != nullptr) &#123; size += rchild-&gt;size; rchild-&gt;fa = this; &#125; &#125; inline std::size_t pos() &#123; std::size_t ret = lsize() + 1; node *cur = this; while (cur-&gt;fa != nullptr) &#123; if (cur-&gt;fa-&gt;rchild == cur) &#123; ret += cur-&gt;fa-&gt;lsize() + 1; &#125; cur = cur-&gt;fa; &#125; return ret; &#125; &#125;; int n, m; node *root, *p[N]; std::pair&lt;node *, node *&gt; split(node *u, int k) &#123; if (u == nullptr) return std::make_pair(nullptr, nullptr); if (k &lt;= u-&gt;lsize()) &#123; auto o = split(u-&gt;lchild, k); u-&gt;lchild = o.second; u-&gt;pushup(); o.second = u; return o; &#125; auto o = split(u-&gt;rchild, k - u-&gt;lsize() - 1); u-&gt;rchild = o.first; u-&gt;pushup(); o.first = u; return o; &#125; template &lt;typename... Args&gt; node *merge(node *x, Args... args) &#123; return merge(x, merge(args...)); &#125; template &lt;&gt; node *merge(node *x, node *y) &#123; if (x == nullptr) return y; if (y == nullptr) return x; if (x-&gt;key &lt; y-&gt;key) &#123; x-&gt;rchild = merge(x-&gt;rchild, y); x-&gt;pushup(); return x; &#125; y-&gt;lchild = merge(x, y-&gt;lchild); y-&gt;pushup(); return y; &#125; inline void top(const int &amp;x) &#123; int k = p[x]-&gt;pos(); auto p = split(root, k - 1); auto q = split(p.second, 1); root = merge(q.first, p.first, q.second); &#125; inline void bottom(const int &amp;x) &#123; int k = p[x]-&gt;pos(); auto p = split(root, k - 1); auto q = split(p.second, 1); root = merge(p.first, q.second, q.first); &#125; inline void insert(const int &amp;x, const int &amp;y) &#123; if (!y) return; int k = p[x]-&gt;pos(); auto p = split(root, k - 1); auto q = split(p.second, 1); if (y &gt; 0) &#123; auto t = split(q.second, y); root = merge(p.first, t.first, q.first, t.second); &#125; else &#123; // y &lt; 0 auto t = split(p.first, k + y - 1); root = merge(t.first, q.first, t.second, q.second); &#125; &#125; inline int ask(const int &amp;x) &#123; return p[x]-&gt;pos() - 1; &#125; inline int query(const int &amp;x) &#123; auto p = split(root, x - 1); auto q = split(p.second, 1); int res = q.first-&gt;value; root = merge(p.first, q.first, q.second); return res; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1, x; i &lt;= n; i++) &#123; cin &gt;&gt; x; root = merge(root, p[x] = new node(x)); &#125; while (m--) &#123; std::string op; int s, t; cin &gt;&gt; op &gt;&gt; s; switch (op[0]) &#123; case &#x27;T&#x27;: &#123; // op == &quot;Top&quot; top(s); break; &#125; case &#x27;B&#x27;: &#123; // op == &quot;Bottom&quot; bottom(s); break; &#125; case &#x27;I&#x27;: &#123; // op == &quot;Insert&quot; cin &gt;&gt; t; insert(s, t); break; &#125; case &#x27;A&#x27;: &#123; // op == &quot;Ask&quot; cout &lt;&lt; ask(s) &lt;&lt; endl; break; &#125; case &#x27;Q&#x27;: &#123; // op == &quot;Query&quot; cout &lt;&lt; query(s) &lt;&lt; endl; break; &#125; &#125; &#125; // Cleanup delete root; return 0; &#125; "},{"title":"S2OJ - 1471. 进化序列","date":"2022-07-11T17:15:09.000Z","url":"/s2oj-1471/","tags":["S2OJ","线段树","二分","双指针"],"categories":["题解"],"content":" 题面 题目描述 Abathur 采集了一系列 Primal Zerg 的基因样本，这些基因构成了一个完整的进化链。为了方便，我们用 A0​,A1​,…,An−1​ 这 n 个正整数描述它们。 一个基因 Ax​ 可以进化为序列中在它之后的基因 Ay​。这个进化的复杂度，等于 Ax​ or Ax+1​… or Ay 的值，其中 or 是二进制或运算。 Abathur 认为复杂度小于 M 的进化的被认为是温和的。它希望计算出温和的进化的对数。 输入格式 第一行包含两个整数 n,m。 接下来一行包含 A0​,A1​,…,An−1​ 这 n 个正整数，描述这 n 个基因。 输出格式 第一行包含一个整数，表示温和的进化的对数。 样例输入输出 样例输入 #1 4 6 1 3 5 1 样例输出 #1 2 数据范围 对于 30% 的数据，1≤n≤1000； 对于 100% 的数据，1≤n≤100000，0≤m≤230，1≤Ai​≤230。 思路 有一个比较显然的性质：或起来的数一定越来越大。那么在确定一个右端点之后可以使用双指针枚举左端点，使用线段树维护区间按位或和即可。或者确定左端点使用二分枚举右端点也可以，在此不作过多叙述。 代码 #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 100005; int n, m, a[N]; long long ans; struct node &#123; int l, r, s; node() : l(0), r(0), s(0) &#123;&#125; node(int _l, int _r) : l(_l), r(_r), s(0) &#123;&#125; &#125; tr[N &lt;&lt; 2]; void pushup(int u) &#123; tr[u].s = tr[u &lt;&lt; 1].s | tr[u &lt;&lt; 1 | 1].s; &#125; void build(int u, int l, int r) &#123; tr[u] = node(l, r); if (l == r) &#123; tr[u].s = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125; int query(int u, int l, int r) &#123; if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].s; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int res = 0; if (l &lt;= mid) res |= query(u &lt;&lt; 1, l, r); if (r &gt; mid) res |= query(u &lt;&lt; 1 | 1, l, r); return res; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); for (int i = 1, j = 1; i &lt;= n; i++) &#123; while (j &lt; i &amp;&amp; query(1, j, i) &gt;= m) j++; ans += i - j; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"S2OJ - 1470. 饥饿的小鸟","date":"2022-07-11T15:31:57.000Z","url":"/s2oj-1470/","tags":["贪心","S2OJ"],"categories":["题解"],"content":" 题面 题目描述 一群饥饿的小鸟，要到河对岸吃东西。河的宽度为 N 米，小鸟每飞行 L 米就必须在一片荷叶上休息一下，才能够继续飞行。当然，小鸟们也可以选择没飞够 L 米就先休息一下，但不能一次飞超过 L 米。距离小鸟们出发的河岸一侧距离为 i 的荷叶共有 Ai​ 片，每片荷叶在有小鸟停于上方休息后，就会沉入水底，不能够再供其他小鸟休息。 现在想要知道，至多有多少只小鸟能够抵达对岸。 输入格式 第一行输入两个整数 N,L，含义见题面描述。 接下来一行 N−1 个整数 Ai​，表示距离河的出发一侧距离为 i 的荷叶的片数。 输出格式 输出一行一个整数，表示至多能够抵达前线的小鸟数量。 输入输出样例 样例输入 #1 10 5 0 0 1 0 2 0 0 1 0 样例输出 #1 3 样例解释 #1 三只小鸟可以分别走 0→5→10；0→5→10；0→3→8→10。 样例输入 #2 10 3 1 1 1 1 2 1 1 1 1 样例输出 #2 3 样例解释 #2 三只小鸟可以分别走 0→1→4→7→10；0→2→5→8→10；0→3→6→9→10。 数据范围与约定 对于 20% 的数据，L=N−1； 对于 50% 的数据，1≤L&lt;N≤5，0≤Ai​≤3； 对于 80% 的数据，1≤L&lt;N≤100，0≤Ai​≤10； 对于 100% 的数据，1≤L&lt;N≤105，0≤Ai​≤104。 思路 贪心。 尽可能使用当前点能达到的最远距离的承载容量，然后转移即可。 代码 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;limits&gt; #include &lt;queue&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5; int n, l, s, a[N], b[N]; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; l; for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; s += a[i]; &#125; a[n] = b[0] = s; for (int i = 0; i &lt; n; i++) &#123; for (int j = std::min(i + l, n); j &gt; i; j--) &#123; if (b[j] &lt; a[j]) &#123; if (b[j] + b[i] &lt;= a[j]) &#123; b[j] += b[i]; b[i] = 0; break; &#125; else &#123; b[i] -= a[j] - b[j]; b[j] = a[j]; &#125; &#125; &#125; &#125; cout &lt;&lt; b[n] &lt;&lt; endl; return 0; &#125; "},{"title":"S2OJ - 1461. 豌豆射手","date":"2022-07-06T16:55:19.000Z","url":"/s2oj-1461/","content":" 题面 题目背景 愚蠢的戴夫种了一些豌豆射手。 愚蠢的戴夫只会把豌豆射手种在一列草坪上，并且因为戴夫不懂得种植向日葵，所以他并没有足够的阳光使得这一列都放满豌豆射手。 但这些豌豆射手除了会向前喷射豌豆，还会向左右喷射豌豆，并且向左右喷射豌豆有一个飞行距离限制。 一大波僵尸即将来临，戴夫想要知道，有多少种安排豌豆射手的方案，使得没有两个豌豆射手会相互攻击。 题目描述 现在有 n 个豌豆射手，要把它们放在长度为 d 的一列草坪上。 每一个豌豆射手都有一个攻击半径 ri​，如果将这个豌豆射手放在 pos 位置，那么 [pos−ri​+1,pos+ri​−1] 将不能有其他的豌豆射手。 戴夫要把这 n 个豌豆射手放在长度为 d 的草坪上，使得它们不会相互攻击，求方案数。答案对 109+7 取模 输入格式 第一行两个整数 n,d，表示有 n 个豌豆射手，草坪的长度为 d。 第二行 n 个整数 ri​，表示每一个豌豆射手的攻击半径。 输出格式 一行一个整数，表示合法的方案数。 输入输出样例 样例输入 #1 4 4 1 1 1 1 样例输出 #1 24 样例输入 #2 3 47 4 8 9 样例输出 #2 28830 样例输入 #3 8 100000 21 37 23 13 32 22 9 39 样例输出 #3 923016564 数据范围与约定 对于 20% 的数据，n≤5，d≤14； 对于 60% 的数据，n≤18； 对于 100% 的数据，n≤40，d≤105，1≤ri​≤40，∑i=1n​ri​≤d。 思路 设豌豆射手的顺序为 p1​,p2​,…,pn​，设 x=i=1∑n​max(rpi​​,rpi+1​​)，则当前排列的方案数为 (d−x+nn​)。那么问题就转变为了对于每一个 x 有多少方案。 先将 ri​ 升序排序，设 fi,j,k​ 表示前 i 个点中有 j 个点的左右位置还可以放置豌豆射手（称为空闲点），放置后 x 的大小为 k 的方案。 初始值：f0,0,0​=1，表示一开始一个点都没有，空闲点的数量也是 0，合并的长度也是 0 的方案。 定义「合并」：表示将一个新的点和一个空闲点相连，那么新合成的这一段又可以看成一个空闲点。有以下几种情况： 将当前点合并到某个空闲点的左右两边。 此时空闲点的数量不变，长度加上新的点的半径。 fi+1,j+1,k+ri+1​​←fi,j,k​×j×2 由于已经对 r 进行过排序，所以 ri+1​ 一定是 ri​ 和 ri+1​ 中最大的那个，直接使用即可。 式子中的乘 j 是可以从 j 个空闲点中挑出一个和新的点合并，乘以 2 是可以放在左右两边。 将当前点插入到两个空闲点的中间，使左右两个空闲点合并。 此时空闲点的数量减 1，长度加上新半径乘以 2，因为往左右两边扩展，然后减去中间算重复的。 fi+1,j−1,k+ri+1​×2−1​←fi,j,k​×j(j−1) 因为这 j 个空闲点具体位置在哪都是不确定的，选取出两个点左右关系也是不确定的，所以乘 j(j−1) 而不是除 2。 单独成为一个空闲点。 此时空闲点的数量加 1，长度加 1。 fi+1,j+1,k+1​←fi,j,k​ 时间复杂度为 O(n3max{ri​})。 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 45, D = 1e5 + 5; const int mod = 1e9 + 7; int n, d, r[N], f[N][N][N * N], max, ans; int fac[D], inv[D]; int binpow(int a, int b) &#123; int res = 1; a %= mod; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; b &gt;&gt;= 1; &#125; return res; &#125; inline int C(int n, int m) &#123; return 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); // 阶乘 fac[0] = 1; for (int i = 1; i &lt;= 100000; i++) &#123; fac[i] = 1ll * fac[i - 1] * i % mod; &#125; // 逆元 inv[0] = inv[1] = 1; for (int i = 2; i &lt;= 100000; i++) &#123; inv[i] = static_cast&lt;long long&gt;(mod - (mod / i)) * inv[mod % i] % mod; &#125; // 阶乘的逆元 for (int i = 2; i &lt;= 100000; i++) &#123; inv[i] = static_cast&lt;long long&gt;(inv[i - 1]) * inv[i] % mod; &#125; cin &gt;&gt; n &gt;&gt; d; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; r[i]; max = std::max(max, r[i]); &#125; std::sort(r + 1, r + 1 + n); f[0][0][0] = 1; for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; for (int k = 0; k &lt;= max * (i - j + 2); k++) &#123; int t = r[i + 1]; if (j &gt;= 1) &#123; f[i + 1][j][k + t] = (f[i + 1][j][k + t] + 1ll * f[i][j][k] * 2 * j) % mod; &#125; if (j &gt;= 2 &amp;&amp; k) &#123; f[i + 1][j - 1][k + t * 2 - 1] = (f[i + 1][j - 1][k + t * 2 - 1] + 1ll * f[i][j][k] * j * (j - 1)) % mod; &#125; f[i + 1][j + 1][k + 1] = (f[i + 1][j + 1][k + 1] + f[i][j][k]) % mod; &#125; &#125; &#125; for (int i = 0; i &lt;= n * max; i++) &#123; ans = (ans + 1ll * C(d - i + n, n) * f[n][1][i] % mod) % mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"「JOI 2022 Final」Let's Win the Election","date":"2022-07-04T22:26:58.000Z","url":"/joi-2022-election/","tags":["动态规划","贪心","洛谷","LibreOJ","JOI","2022"],"categories":["题解"],"content":" 题面 题目描述 JOI 共和国由 N 个州组成，现在 JOI 共和国正在进行选举。 理恵想要赢得选举，她决定以发表演讲的方式来提高自己的支持率，具体的，她可以发表任意时间长度的演讲，这些演讲会造成一定的影响： 如果在这个州的演讲时间达到 Ai​，那么她将会赢得一张选票； 如果在这个州的演讲时间达到 Bi​，那么她将会赢得一名协作者，协作者可以与她同时在任何州发表演讲，如果多人同时在一个州发表演讲，计入多倍演讲时间。 有可能无法获得协作者，此时 Bi​=−1，此外我们保证 Bi​≥Ai​。 理恵想尽快得到 K 张选票，请计算最小的演讲时间。 输入格式 第一行一个整数 N。 第二行一个整数 K。 接下来 N 行，一行两个整数 Ai​,Bi​。 输出格式 输出一个实数，表示需要的最小演讲时间，你的答案与标准答案的绝对误差不应超过 0.01。 输入输出样例 样例输入 #1 3 3 1 5 2 3 4 5 样例输出 #1 5.500000000000000 样例解释 #1 方案如下： 在第 2 个州演讲 3 个小时，获得一张选票和一个协作者。 在第 3 个州与协作者一起演讲 2 个小时，获得一张选票。 在第 1 个州与协作者一起演讲 0.5 个小时，获得一张选票。 这个样例满足子任务 3,4,5,6,7​ 的性质。 样例输入 #2 7 4 4 -1 11 -1 6 -1 12 -1 36 -1 11 -1 20 -1 样例输出 #2 32.000000000000000 样例解释 #2 选择第 1,2,3,6 个州演讲是最优的。 这个样例满足子任务 1,2,3,4,5,7 的性质。 样例输入 #3 5 3 4 -1 5 -1 6 -1 7 7 8 8 样例输出 #3 11.500000000000000 样例解释 #3 方案如下： 在第 4 个州演讲 7 个小时，获得一张选票和一个协作者。 在第 1 个州演讲 4 个小时，获得一张选票，同时让协作者在第 2 个州演讲 4 个小时。 在第 2 个州与协作者一起演讲 0.5 个小时，获得一张选票。 这个样例满足子任务 2,3,4,5,7 的性质。 样例输入 #4 7 5 28 36 11 57 20 35 19 27 31 33 25 56 38 51 样例输出 #4 62.166666666666664 样例解释 #4 这个样例满足子任务 3,4,5,7 的性质。 样例输入 #5 20 14 106 277 175 217 170 227 164 245 118 254 139 261 142 270 185 200 162 241 153 239 128 264 103 299 147 248 158 236 160 232 183 205 194 197 135 260 153 234 128 260 样例输出 #5 644.203571428571422 样例解释 #5 这个样例满足子任务 4,5,7 的性质。 数据范围与约定 对于全部数据，1≤N≤500，1≤K≤N，1≤Ai​≤103，Ai​≤Bi​≤103 或者 Bi​=−1。 子任务 特殊限制 分值 1 Bi​=−1 5 2 Bi​=−1 或者 Bi​=Ai​ $5 $ 3 N≤7 11 4 N≤20 12 5 N≤100 33 6 K=N 11 7 无特殊限制 23 思路 原题面可以转化为： 给出一个长度为 n 的序列，从中选出 k 个元素，设 c=1，对于这 k 个元素，在排序后有以下操作： 耗费 cai​​ 的时间处理这个元素； 耗费 cbi​​ 的时间处理这个元素并使 c 增加 1。 求处理完全部 k 个元素的最小花费。 显然先进行操作 2 比先进行操作 1 要优，并且优先选择 bi​ 小的比其他方式优。 然后考虑 DP。设 fi,j​ 表示在前 i 个州中招收协作者的最小耗时，其中 i 表示当前所处的州的编号，j 表示到达当前状态获得了多少协作者。再预处理出 gi,j​ 表示在 ai∼n​ 中前 j 小的数的总和。最后将 f 和 g 中对应的值相加即可。 详细实现可以查看下方代码。 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;iomanip&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 505; int n, k; std::pair&lt;int, unsigned int&gt; p[N], q[N]; double f[N][N], g[N][N], ans = 1e9; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].first &gt;&gt; p[i].second; &#125; std::sort(p + 1, p + 1 + n, [&amp;](auto a, auto b) -&gt; bool &#123; return a.second &lt; b.second; &#125;); for (int i = 1; i &lt;= n; i++) &#123; q[i] = p[i]; &#125; // 预处理 i ~ n 中 a_i 的前 j 小之和 for (int i = n; i; i--) &#123; std::sort(q + i, q + 1 + n, [&amp;](auto a, auto b) -&gt; bool &#123; return a.first &lt; b.first; &#125;); for (int j = i; j &lt;= n; j++) &#123; g[i][j - i + 1] = g[i][j - i] + q[j].first; &#125; &#125; for (int t = 0; t &lt; k; t++) &#123; // 枚举招纳协作者的数量 for (int i = 0; i &lt;= k; i++) &#123; for (int j = 0; j &lt;= t; j++) &#123; f[i][j] = 1e9; &#125; &#125; f[0][0] = 0; // 演讲前耗时为 0 for (int i = 1; i &lt;= k; i++) &#123; // 还未招协作者的时候直接从上一次转移 f[i][0] = f[i - 1][0] + static_cast&lt;double&gt;(p[i].first) / (t + 1); // 还要加上 Rie 本人 for (int j = 1; j &lt;= t; j++) &#123; f[i][j] = std::min( f[i - 1][j - 1] + static_cast&lt;double&gt;(p[i].second) / j, // 需要招协作者的立即演讲 f[i - 1][j] + static_cast&lt;double&gt;(p[i].first) / (t + 1)); // 不招协作者的在招满后再演讲 &#125; &#125; for (int i = 0; i &lt;= k; i++) &#123; ans = std::min(ans, f[i][t] + g[i + 1][k - i] / (t + 1)); // 增加协作者耗时 + 纯演讲耗时 &#125; &#125; cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(15) &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P1441 砝码称重","date":"2022-07-03T16:53:10.000Z","url":"/luogu-p1441/","tags":["洛谷","bitset"],"categories":["题解"],"content":" 题面 题目描述 现有 n 个砝码，重量分别为 ai​，在去掉 m 个砝码后，问最多能称量出多少不同的重量（不包括 0）。 请注意，砝码只能放在其中一边。 输入格式 第 1 行为有两个整数 n 和 m，用空格分隔。 第 2 行有 n 个正整数 a1​,a2​,a3​,…,an​，表示每个砝码的重量。 输出格式 仅包括 1 个整数，为最多能称量出的重量数量。 输入输出样例 样例输入 #1 3 1 1 2 2 样例输出 #1 3 样例解释 #1 在去掉一个重量为 2 的砝码后，能称量出 1,2,3 共 3 种重量。 数据范围与约定 对于 20% 的数据，m=0； 对于 50% 的数据，m≤1； 对于 50% 的数据，n≤10； 对于 100% 的数据，n≤20，m≤4，m&lt;n，ai​≤100。 思路 观察数据范围，可以发现所有砝码组成的重量最大不超过 2000，考虑使用 bitset 维护。 在 [0∼2n) 范围内枚举状态，第 k 位表示第 k 个砝码是否存在。当 popcount(i)=n−m 时，状态 i 可以更新答案。 显然重量 0 不需要任何砝码即可称量出，因此直接设置第 0 位为 1。然后对于所有的砝码，计算其与前面的砝码搭配能称出的重量，最后二进制下为 1 的位的个数即为当前状态下的结果。据此更新答案即可。 由于最终结果不能包括 0，因此需要在最终答案中 −1。 代码 #include &lt;iostream&gt; #include &lt;bitset&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 20; int n, m, a[N], ans; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; 1 &lt;&lt; n; i++) &#123; if (__builtin_popcount(i) == n - m) &#123; std::bitset&lt;2005&gt; s; s[0] = 1; for (int j = 0; j &lt; n; j++) &#123; if (i &amp; (1 &lt;&lt; j)) &#123; s |= s &lt;&lt; a[j]; &#125; &#125; ans = std::max(ans, (int)s.count()); &#125; &#125; cout &lt;&lt; ans - 1 &lt;&lt; endl; return 0; &#125; "},{"title":"「CEOI2017」Mousetrap","date":"2022-07-03T14:54:22.000Z","url":"/ceoi2017-trap/","tags":["动态规划","洛谷","LibreOJ","CEOI","2017","树形 DP","二分"],"categories":["题解"],"content":" 题面 题目描述 有一个有 n 个房间和 n−1 条走廊的迷宫，保证任意两个房间可以通过走廊互相到达，换句话说，这个迷宫的结构是一棵树。 一个老鼠被放进了迷宫，迷宫的管理者决定和老鼠做个游戏。 一开始，有一个房间被放置了陷阱，老鼠出现在另一个房间。老鼠可以通过走廊到达别的房间，但是会弄脏它经过的走廊。老鼠不愿意通过脏的走廊。 每个时刻，管理者可以进行一次操作：堵住一条走廊使得老鼠不能通过，或者擦干净一条走廊使得老鼠可以通过。然后老鼠会通过一条干净的并且没被堵住的走廊到达另一个房间。只有在没有这样的走廊的情况下，老鼠才不会动。一开始所有走廊都是干净的。管理者不能疏通已经被堵住的走廊。 现在管理者希望通过尽量少的操作将老鼠赶到有陷阱的房间，而老鼠则希望管理者的操作数尽量多。请计算双方都采取最优策略的情况下管理者需要的操作数量。 注意：管理者可以选择在一些时刻不操作。 输入格式 第一行三个空格隔开的正整数数 n,t,m。分别代表房间的个数，陷阱房的编号和老鼠起始房间的编号。 接下来 n−1 行，每行两个空格隔开的整数 ai​,bi​，表示有一条走廊连接编号为 ai​ 和 bi​ 的房间。 输出格式 输出一行包含一个整数，表示双方都采取最优策略的情况下，管理者需要的操作数量。 输入输出样例 样例输入 #1 10 1 4 1 2 2 3 2 4 3 9 3 5 4 7 4 6 6 8 7 10 样例输出 #1 4 样例解释 #1 管理者先堵住房间 4 和 7 之间的走廊。 老鼠走到房间 6。房间 4 和 6 之间的走廊现在是脏的。 管理者堵住房间 6 和 8 之间的走廊。 老鼠不能动。 管理者清理房间 4 和 6 之间的走廊，房间 4 和 6 之间的走廊现在是干净的。 老鼠走到房间 4，房间 4 和 6 之间的走廊现在是脏的。 管理者堵住房间 2 和 3 之间的走廊。 老鼠走到房间 2，房间 2 和 4之间的走廊现在是脏的。 管理者不进行操作。 老鼠走到房间 1。 这个过程中管理者总共进行了 4 次操作。 数据范围与约定 子任务 1（20%）: 1≤n≤10； 子任务 2（25%）: 1≤n≤106，保证老鼠的起始位置和陷阱房相邻； 子任务 3（20%）: 1≤n≤1000； 子任务 4（35%）: 1≤n≤106。 思路 昨天上课讲的这道题。 从老鼠的位置开始考虑没有什么好的想法，于是从陷阱房的位置开始考虑。由题可知这个迷宫的形态是一棵树，那么设陷阱房为树根。 先来考虑一种特殊情况：老鼠的起始房间与陷阱房相邻。此时老鼠一定会向下面最深的子树走。那么先堵住通向最深的子树的走廊，那么老鼠就会走向次深的子树，显然这样可以减少操作数量。当老鼠被困在某个叶子节点后，将从该叶子节点通向根节点的路径上的通向其他子树的走廊都堵住，再擦干净这条路径即可使老鼠走入陷阱房。 考虑树形 DP，设 fx​ 为老鼠在点 x 进入 x 的子树后，将其又赶回点 x 的最小操作次数，得： fx​=y∈son(x)2nd-max​{fy​}+∣son(x)∣(1) 其中 2nd-max 表示次大值。∣son(u)∣ 表示 x 的子树个数。 下面再来考虑一般情况：老鼠的起始房间与陷阱房不相邻。此时，一开始老鼠不一定会直接向下走，它可以先向上跳，到达某个节点后再开始向下走，开始走后老鼠对走哪个儿子的选择取决于管理者堵边的情况。向下走的时候转移方程同 (1)。对于向上走的情况可以二分处理。 求出 gx​ 表示根节点到 x 的路径中所有分叉路数量： gx​=⎩⎨⎧​0gfa​+∣son(x)∣−1gfa​+∣son(x)∣−2​(x=t)(x=m)(otherwise)​ 设 t→m 的路径上结点集合为 S，对于路径上每一个点 x 的分叉子树结点考虑，如果其满足下列条件之一，则需要堵住通往这条分叉子树的边： v∈son(x),v∈S； gu​+fv​&gt;mid。 如果满足以下条件，则 mid 不合法： 经过 mid 次操作后无法堵住所有需要堵住的边； 当老鼠走到 u 处时，但 u 处需要被堵住的通往分叉子树的边没有被堵住。 二分完成后输出答案即可。 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e6 + 5; int n, t, m, fa[N], sum[N], f[N], ans; bool vis[N]; std::vector&lt;int&gt; g[N]; void dfs(int u, int _f) &#123; int max1 = 0, max2 = 0; fa[u] = _f; if (u != t) &#123; sum[u] = sum[_f] + g[u].size() - 1 - (u != m); &#125; for (const int &amp;v : g[u]) &#123; if (v == _f) continue; dfs(v, u); if (f[v] &gt; max1) &#123; max2 = max1; max1 = f[v]; &#125; else if (f[v] &gt; max2) &#123; max2 = f[v]; &#125; &#125; f[u] = max2 + g[u].size() - 1; &#125; bool check(int x) &#123; for (int i = m, cnt = 1; i != t; i = fa[i], cnt++) &#123; int t = 0; for (const int &amp;v : g[i]) &#123; if (vis[v] || sum[i] + f[v] &lt;= x) continue; if (!cnt) return false; t++, cnt--; &#125; x -= t; &#125; return x &gt;= 0; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; t &gt;&gt; m; for (int i = 1, u, v; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); &#125; dfs(t, 0); for (int i = m; i; i = fa[i]) &#123; vis[i] = true; &#125; int l = 0, r = n &lt;&lt; 1; while (l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) &#123; r = mid - 1; ans = mid; &#125; else &#123; l = mid + 1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P4555 最长双回文串","date":"2022-06-28T06:50:47.000Z","url":"/luogu-p4555/","tags":["洛谷","字符串","国家集训队","Manacher"],"categories":["题解"],"content":" 题面 题目描述 顺序和逆序读起来完全一样的串叫做回文串。比如 acbca 是回文串，而 abc 不是（abc 的顺序为 abc，逆序为 cba，不相同）。 输入长度为 n 的串 S，求 S 的最长双回文子串 T,即可将 T 分为两部分 X,Y（1≤∣X∣,∣Y∣）且 X 和 Y 都是回文串。 输入格式 一行由小写英文字母组成的字符串 S。 输出格式 一行一个整数，表示最长双回文子串的长度。 输入输出样例 样例输入 #1 baacaabbacabb 样例输出 #1 12 样例解释 #1 从第二个字符开始的字符串 aacaabbacabb 可分为 aacaa 与 bbacabb 两部分，且两者都是回文串。 数据范围与约定 对于 100% 的数据，2≤∣S∣≤105。 思路 刚拿到这道题的时候，一下子有了一个偏朴素的做法：先跑一遍 Manacher，然后对于每个点分别枚举以它为左右端点的回文串相加取最大值。又去看了眼数据范围，仔细一想发现这个做法实际复杂度是 O(n2) 的，无法通过本题。 可以设 li​ 表示以 i 为左端点的最长的回文串，ri​ 表示以 i 为右端点的最长的回文串。有转移方程如下： li+(pi​−1)​ri−(pi​−1)​​=max(li+(pi​−1)​,pi​−1)=max(ri−(pi​−1)​,pi​−1)​ 然后再递推将前/后方的最长回文串转移过来。因为两个回文串不能重叠，所以每次选择分隔符 # 进行枚举，就避免了重叠的问题，转移方程如下： li​=max(li​,li−2​−2)ri​=max(ri​,ri+2​−2)​ 之后再次枚举每个断点更新答案即可。 代码 #include &lt;iostream&gt; #include &lt;string&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5; int mid, r, p[N &lt;&lt; 1], a[N &lt;&lt; 1], b[N &lt;&lt; 1], ans; std::string s1, s2; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; s1; s2.push_back(&#x27;^&#x27;); for (const char &amp;c : s1) &#123; s2.push_back(&#x27;#&#x27;); s2.push_back(c); &#125; s2 += &quot;#$&quot;; for (int i = 1; i &lt; s2.size(); i++) &#123; p[i] = i &lt; r ? std::min(p[mid * 2 - i], r - i) : 1; while (s2[i - p[i]] == s2[i + p[i]]) p[i]++; if (i + p[i] &gt; r) &#123; r = i + p[i]; mid = i; &#125; a[i + p[i] - 1] = std::max(a[i + p[i] - 1], p[i] - 1); b[i - p[i] + 1] = std::max(b[i - p[i] + 1], p[i] - 1); &#125; for (int i = s2.size() - 4; i &gt;= 3; i -= 2) &#123; a[i] = std::max(a[i], a[i + 2] - 2); &#125; for (int i = 3; i &lt;= s2.size() - 4; i += 2) &#123; b[i] = std::max(b[i], b[i - 2] - 2); &#125; for (int i = 3; i &lt;= s2.size() - 4; i += 2) &#123; ans = std::max(ans, a[i] + b[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"Manacher 算法学习笔记","date":"2022-06-27T15:09:52.000Z","url":"/manacher/","tags":["字符串","Manacher"],"categories":["笔记"],"content":"Manacher 算法可以以 O(n) 的时间复杂度求出一个字符串以每个位置为中心的最长回文子串。 Manacher 算法 预处理 对于一个字符串，它的回文子串的长度有两种主要情况：长度为奇数、长度为偶数。在本文中只需要考虑长度为奇数的字符串即可，因为可以通过插入无关字符的方式将任意长度的字符串转化为长度为奇数的字符串。例如，对于字符串 abccba，可以将其转化为 ^#a#b#c#c#b#a#$，其中 ^ 和 $ 代表字符串的起始和结束。 这样处理之后，原串中长度为奇数和偶数的回文串的长度均变为奇数，且原串中回文串的长度为新串回文串半径减一。 流程 设 pi​ 表示以 si​ 为中心的最大回文串的半径。再设 mid 表示当前已找到的回文串中向右延伸最远的中心位置，r 表示其右端点的下一个位置（开区间方便计算）。 当枚举到第 i 个字符时，设 j 为 i 关于 mid 的对称点（即 j=2×mid−i），有两种情况： r&lt;i，即向右延伸最远的回文子串（黑色）没有覆盖 i，此时只有 pi​≥1。 r≥i 且 r−i≥pj​，即向右延伸最远的回文子串（黑色）覆盖了 i，此时讨论关于以 j 为中心的最长回文子串与以 i 为中心的最长回文子串的关系，又有两种情况： 以 j 为中心的最长回文子串完全与以 i 为中心的最长回文子串对称（蓝色），此时一定有 pi​=pj​，即 pi​≥pj​。 向右延伸的最远回文子串（黑色）没有覆盖以 j 为中心的最长回文子串的对称位置串，所以 pi​ 只能取被覆盖的一部分（黄色），即 pi​≥r−i。 不可以利用对称性时直接暴力扩张即可。 代码 #include &lt;iostream&gt; #include &lt;string&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e7 + 5; int p[N &lt;&lt; 1], mid, r, ans; std::string s1, s2; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; s1; // 使字符串的长度变为 (2n + 1)，方便处理 s2.push_back(&#x27;^&#x27;); for (const char &amp;c : s1) &#123; s2.push_back(&#x27;#&#x27;); s2.push_back(c); &#125; s2 += &quot;#$&quot;; for (int i = 1; i &lt; s2.size(); i++) &#123; // r 代表以 mid 为中心的最长回文子串的右边界 p[i] = i &lt; r // mid * 2 - i 为 i 关于 mid 的对称点 ? std::min(p[mid * 2 - i], r - i) // 超过边界就不是回文串了 : 1; // 暴力扩展回文串长度 while (s2[i - p[i]] == s2[i + p[i]]) p[i]++; // 扩展右边界 if (r &lt; i + p[i]) &#123; r = i + p[i]; mid = i; &#125; &#125; for (int i = 0; i &lt; s2.size(); i++) &#123; ans = std::max(ans, p[i] - 1); // p[i] - 1 即为以 i 为中心的最长的回文子串长度 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 参考资料 7.1 启发式合并、Manacher 算法，AcWing 算法提高课，闫学灿，2021 年 1 月 15 日。 Manacher 学习笔记，黄浩睿，2017 年 1 月 2 日。 Manacher，OI Wiki，2021 年 8 月 11 日。 "},{"title":"欧拉图学习笔记","date":"2022-06-24T08:59:14.000Z","url":"/euler-graph/","tags":["图论","离散数学","欧拉图","欧拉路径","欧拉回路"],"categories":["笔记"],"content":"本文中提到的所有图均为连通图。 定义 通过图中所有边恰好一次的通路称为欧拉路径。 通过图中所有边恰好一次的回路称为欧拉回路。 具有欧拉回路的无向图或有向图称为欧拉图。 具有欧拉通路但不具有欧拉回路的无向图或有向图称为半欧拉图。 判定 有向图 存在欧拉路径的充分必要条件： 所有点的出度均等于入度；或 存在一个点的出度比入度多一（此时该点为起点），存在另一个点的入度比出度多一（此时该点为终点），其余点的入度和出度均相等。 存在欧拉回路的充分必要条件：所有点的入度均等于出度。 无向图 存在欧拉路径的充分必要条件：度数为奇数的点只能有 0 个或 2 个。 存在欧拉回路的充分必要条件：不能有度数为奇数的点。 求欧拉回路 从一个非孤立点开始 DFS，点可以重复经过，每次任意走一条边并将这条边从邻接表中删除（如果是无向图，其反向边也要被标记为删除），最终所有边一定会都会被经过。 DFS 回溯时记录每一条边，最终将记录的逆序即为欧拉回路。 代码 对应题目 UOJ #117. 欧拉回路。 有向图无向图#include &lt;iostream&gt; #include &lt;cstring&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5, M = 2e5 + 5; int n, m, cnt, ans[M]; int idx, head[N], edge[M], next[M]; int din[N], dout[N]; bool vis[M]; void add(int u, int v) &#123; next[idx] = head[u]; edge[idx] = v; head[u] = idx++; &#125; void dfs(int u) &#123; for (int &amp;i = head[u]; ~i;) &#123; if (vis[i]) &#123; i = next[i]; continue; &#125; int v = edge[i], x = i + 1; vis[i] = true; i = next[i]; dfs(v); ans[++cnt] = x; &#125; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; memset(head, 0xff, sizeof(head)); for (int i = 1, u, v; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; add(u, v); dout[u]++, din[v]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (din[i] != dout[i]) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; exit(0); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (~head[i]) &#123; dfs(i); break; &#125; &#125; if (cnt &lt; m) &#123; // 没有经过所有边 cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; exit(0); &#125; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; for (int i = cnt; i; i--) &#123; cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; return 0; &#125;#include &lt;iostream&gt; #include &lt;cstring&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5, M = 2e5 + 5; int n, m, cnt, ans[M]; int idx, head[N], edge[M &lt;&lt; 1], next[M &lt;&lt; 1]; int deg[N]; bool vis[M &lt;&lt; 1]; void add(int u, int v) &#123; next[idx] = head[u]; edge[idx] = v; head[u] = idx++; &#125; void dfs(int u) &#123; for (int &amp;i = head[u]; ~i;) &#123; if (vis[i]) &#123; i = next[i]; continue; &#125; int v = edge[i], x = i &amp; 1 ? -(i &gt;&gt; 1) - 1 : (i &gt;&gt; 1) + 1; vis[i] = true; vis[i ^ 1] = true; i = next[i]; dfs(v); ans[++cnt] = x; &#125; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; memset(head, 0xff, sizeof(head)); for (int i = 1, u, v; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; add(u, v); add(v, u); deg[u]++, deg[v]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &amp; 1) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; exit(0); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (~head[i]) &#123; dfs(i); break; &#125; &#125; if (cnt &lt; m) &#123; // 没有经过所有边 cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; exit(0); &#125; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; for (int i = cnt; i; i--) &#123; cout &lt;&lt; ans[i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; return 0; &#125; 参考资料 3.10 欧拉回路和欧拉路径，AcWing 算法提高课，闫学灿，2019 年 12 月 7 日。 欧拉回路学习笔记，黄浩睿，2017 年 1 月 1 日。 "},{"title":"洛谷 - P3594 Wilcze doły","date":"2022-06-23T15:11:47.000Z","url":"/luogu-p3594/","tags":["贪心","洛谷","POI","单调队列","2015","双指针"],"categories":["题解"],"content":" 题面 题目描述 给定一个长度为 n 的序列，你有一次机会选中一段连续的长度不超过 d 的区间，将里面所有数字全部修改为 0。请找到最长的一段连续区间，使得该区间内所有数字之和不超过 p。 输入格式 输入的第一行包含三个整数，分别代表 n,p,d。 第二行包含 n 个整数，第 i 个整数代表序列中第 i 个数 wi​。 输出格式 包含一行一个整数，即修改后能找到的最长的符合条件的区间的长度。 输入输出样例 样例输入 #1 9 7 2 3 4 1 9 4 1 7 1 3 样例输出 #1 5 数据范围与约定 对于 100% 的数据，1≤d≤n≤2×106，0≤p≤1016，1≤wi​≤109。 思路 单调队列 + 双指针。 由题： 你有一次机会选中一段连续的长度不超过 d 的区间，将里面所有数字全部修改为 0。 可知答案的最小值为 d，因为其区间和为 0，一定不大于 p。 如果有一个确定的区间 [l,r]，显然删掉这个区间里长度不超过 d 且和最大的子区间之后，区间和会最小。那么就有了一个 O(n3) 的算法：枚举 l,r，选择其中和最大的长度为 d 的区间，然后判断剩余元素的和是否 ≤p。 考虑优化，发现可以使用双指针算法。先令 r=d+1，然后从 1 开始向后查找，直到删去区间内长度为 d 且和最大的子区间后剩余的区间和 ≤p 时停止查找，此时将答案与 r−l+1 取最大值即可。此时复杂度为 O(n2)。 考虑继续优化，发现可以使用前缀和优化求和的复杂度。设 si​ 表示 [1,i] 区间内所有元素的和，ti​ 表示 (i−d,i] 区间内所有元素的和。这样就可以省去了求和的时间，最终时间复杂度为 O(n)。 代码 #include &lt;iostream&gt; #include &lt;deque&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 2e6 + 5; int n, d, a[N], ans; long long p, sum, s[N], t[N]; std::deque&lt;int&gt; q; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; p &gt;&gt; d; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; t[i] = s[i] - s[i - d]; &#125; ans = d; sum = s[d + 1]; q.push_back(d); for (int l = 1, r = d + 1; r &lt;= n; sum += a[++r]) &#123; while (!q.empty() &amp;&amp; t[q.back()] &lt;= t[r]) q.pop_back(); q.push_back(r); while (sum - t[q.front()] &gt; p) &#123; if (q.front() &lt; l + d) q.pop_front(); sum -= a[l++]; &#125; ans = std::max(ans, r - l + 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"LibreOJ - 10183. 股票交易","date":"2022-06-22T09:45:01.000Z","url":"/libreoj-10183/","tags":["动态规划","洛谷","AcWing","单调队列","单调队列优化 DP","LibreOJ","2010","SCOI"],"categories":["题解"],"content":" 题面 题目描述 最近 lxhgww 又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。 通过一段时间的观察，lxhgww 预测到了未来 T 天内某只股票的走势，第 i 天的股票买入价为每股 APi​，第 i 天的股票卖出价为每股 BPi​（数据保证对于每个 i，都有 APi​≥BPi​），但是每天不能无限制地交易，于是股票交易所规定第 i 天的一次买入至多只能购买 ASi​ 股，一次卖出至多只能卖出 BSi​ 股。 另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 W 天，也就是说如果在第 i 天发生了交易，那么从第 i+1 天到第 i+W 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 MaxP。 在第 1 天之前，lxhgww 手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，T 天以后，lxhgww 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？ 输入格式 输入数据第一行包括 3 个整数，分别是 T，MaxP，W。 接下来 T 行，第 i 行代表第 i−1 天的股票走势，每行 4 个整数，分别表示 APi​,BPi​,ASi​,BSi​。 输出格式 输出数据为一行，包括 1 个数字，表示 lxhgww 能赚到的最多的钱数。 输入输出样例 样例输入 #1 5 2 0 2 1 1 1 2 1 1 1 3 2 1 1 4 3 1 1 5 4 1 1 样例输出 #1 3 提示 对于 30% 的数据，0≤W&lt;T≤50，1≤MaxP≤50； 对于 50% 的数据，0≤W&lt;T≤2000，1≤MaxP≤50； 对于 100% 的数据，0≤W&lt;T≤2000，1≤MaxP≤2000，1≤BPi​≤APi​≤1000，1≤ASi​,BSi​≤MaxP。 思路 先考虑朴素做法。 对于每一天，有 4 种情况： 不操作。 此时收益与上一天持平。 转移方程：fi,j​=fi−1,j​。 从头开始买入股票。此状态即为初始状态。 此时收益要扣除买股票的钱，当买 k 张股票时，收益为 −k×APi​。 转移方程：fi,j​=−j×APi​。 在前一天的基础上买入股票。 由于前 1∼i−W−2 天的最优收益已经转移到了 i−W−1 天上，所以只需要枚举第 i 天买多少张股票，并在第 i−W−1 天中对应股票数量的收益的基础上扣除相应金额即可。 转移方程：fi,j​=maxk=j−ASi​j−1​{fi−w−1,k​−(j−k)×APi​}。 在前一天的基础上卖出股票。 枚举第 i 天卖多少张股票，并在第 i−W−1 天中对应股票数量的收益的基础上增加相应金额即可。 转移方程：fi,j​=maxk=j+1j+BSi​​{fi−w−1,k​+(k−j)×BPi​}。 不难发现，3 和 4 两个操作是可以被优化的。 3 中的方程可以被转化为： fi,j​​=k=j−ASi​maxj−1​{fi−w−1,k​−(j−k)×APi​}=k=j−ASi​maxj−1​{fi−w−1,k​−j×APi​+k×APi​}=k=j−ASi​maxj−1​{fi−w−1,k​+k×APi​}−j×APi​​ 同理，4 中的方程可以被转化为： fi,j​​=k=j+1maxj+BSi​​{fi−w−1,k​+(k−j)×BPi​}=k=j+1maxj+BSi​​{fi−w−1,k​+k×BPi​−j×BPi​}=k=j+1maxj+BSi​​{fi−w−1,k​+k×BPi​}−j×BPi​​ 使用单调队列维护即可。 代码 70 分100 分#include &lt;iostream&gt; #include &lt;cstring&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 2005; int n, m, w, f[N][N]; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); memset(f, 0xcf, sizeof(f)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; w; for (int i = 1; i &lt;= n; i++) &#123; f[i][0] = 0; int ap, bp, as, bs; cin &gt;&gt; ap &gt;&gt; bp &gt;&gt; as &gt;&gt; bs; // [2]: 从 0 张开始买入 for (int j = 0; j &lt;= as; j++) &#123; f[i][j] = -j * ap; &#125; // [1]: 不操作 for (int j = 0; j &lt;= m; j++) &#123; f[i][j] = std::max(f[i][j], f[i - 1][j]); &#125; if (i - w - 1 &gt; 0) &#123; // [3]: 买入 for (int j = 0; j &lt;= m; j++) &#123; for (int k = std::max(j - as, 0); k &lt; j; k++) &#123; f[i][j] = std::max(f[i][j], f[i - w - 1][k] - (j - k) * ap); &#125; &#125; // [4]: 卖出 for (int j = 0; j &lt;= m; j++) &#123; for (int k = j + 1; k &lt;= std::min(j + bs, m); k++) &#123; f[i][j] = std::max(f[i][j], f[i - w - 1][k] + (k - j) * bp); &#125; &#125; &#125; &#125; cout &lt;&lt; f[n][0] &lt;&lt; endl; return 0; &#125;#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;deque&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 2005; int n, m, w, f[N][N]; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); memset(f, 0xcf, sizeof(f)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; w; for (int i = 1; i &lt;= n; i++) &#123; f[i][0] = 0; int ap, bp, as, bs; cin &gt;&gt; ap &gt;&gt; bp &gt;&gt; as &gt;&gt; bs; // [2]: 从 0 张开始买入 for (int j = 0; j &lt;= as; j++) &#123; f[i][j] = -j * ap; &#125; // [1]: 不操作 for (int j = 0; j &lt;= m; j++) &#123; f[i][j] = std::max(f[i][j], f[i - 1][j]); &#125; if (i - w - 1 &gt; 0) &#123; // [3]: 买入 std::deque&lt;int&gt; q1; for (int j = 0; j &lt;= m; j++) &#123; while (!q1.empty() &amp;&amp; q1.front() &lt; j - as) q1.pop_front(); while (!q1.empty() &amp;&amp; f[i - w - 1][q1.back()] + q1.back() * ap &lt;= f[i - w - 1][j] + j * ap) q1.pop_back(); q1.push_back(j); f[i][j] = std::max(f[i][j], f[i - w - 1][q1.front()] - (j - q1.front()) * ap); &#125; // [4]: 卖出 std::deque&lt;int&gt; q2; for (int j = m; ~j; j--) &#123; while (!q2.empty() &amp;&amp; q2.front() &gt; j + bs) q2.pop_front(); while (!q2.empty() &amp;&amp; f[i - w - 1][q2.back()] + q2.back() * bp &lt;= f[i - w - 1][j] + j * bp) q2.pop_back(); q2.push_back(j); f[i][j] = std::max(f[i][j], f[i - w - 1][q2.front()] + (q2.front() - j) * bp); &#125; &#125; &#125; cout &lt;&lt; f[n][0] &lt;&lt; endl; return 0; &#125; "},{"title":"BZOJ - 1718. Redundant Paths","date":"2022-06-20T17:23:46.000Z","url":"/bzoj-1718/","tags":["BZOJ","洛谷","AcWing","USACO","2006","图论","Tarjan","双连通分量"],"categories":["题解"],"content":" 题面 题目描述 为了从 F 个草场中的一个走到另一个，贝茜和她的同伴们有时不得不路过一些她们讨厌的可怕的树。 奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择。 每对草场之间已经有至少一条路径。 给出所有 R 条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量，路径由若干道路首尾相连而成。 两条路径相互分离，是指两条路径没有一条重合的道路。但是，两条分离的路径上可以有一些相同的草场。 对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路。 输入格式 第 1 行，两个用空格分隔的整数 F 和 R。 接下来 R 行，每行输入两个整数，表示两个草场，它们之间有一条道路。 输出格式 一行一个整数，表示最少的需要新建的道路数。 输入输出样例 样例输入 #1 7 7 1 2 2 3 3 4 2 5 4 5 5 6 5 7 样例输出 #1 2 数据范围与约定 对于 100% 的数据，1≤F≤5000，F&lt;R≤10000。 思路 由题： 两条路径相互分离，是指两条路径没有一条重合的道路。 可知： 对于图中的任意两点 A,B 之间的所有路径上，不能够存在一条边满足如果不经过它，就不能从点 A 到达点 B。 换言之，就是不能存在一条边使得删去它后整个图变得不连通。那么题目的要求就可以转化为：给定一个连通无向图，求出加边的最小数量使得整个图变为一个双连通分量。 先求出图中所有的双连通分量并缩点，缩点之后图就变成了一棵树的形状，那么只需要对这棵树加边，使其构成双连通分量即可。 对于树上的每一个叶子节点，如果将其与它父亲节点的连边删去，那么这个节点就会被孤立，无法构成双连通分量。所以将其与其他节点再连一条边即可避免发生这种情况，一个比较显然的结论就是将这条边连向另一个叶子节点是最优的。那么对于有偶数个叶子节点的树，需要连 2cnt​ 个点，对于有奇数个叶子节点的树，需要连 2cnt+1​ 个点。整理得 ⌊2cnt+1​⌋。 代码 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;stack&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 5005, M = 10005 &lt;&lt; 1; int f, r, ans; int idx, head[N], edge[N], next[N]; // 链式前向星 int cnt, dfn[N], low[N]; // Tarjan 辅助数组 int dcc_cnt, siz[N], id[N], in[N]; // 双连通分量 bool bridge[N]; // 桥边 std::stack&lt;int&gt; st; void add(int u, int v) &#123; next[idx] = head[u]; edge[idx] = v; head[u] = idx++; &#125; // Tarjan 求双连通分量 void tarjan(int u, int in_edge) &#123; dfn[u] = low[u] = ++cnt; st.push(u); for (int i = head[u]; ~i; i = next[i]) &#123; int v = edge[i]; if (!dfn[v]) &#123; tarjan(v, i); low[u] = std::min(low[u], low[v]); if (dfn[u] &lt; low[v]) &#123; bridge[i] = bridge[i ^ 1] = true; &#125; &#125; else if (i != (in_edge ^ 1)) &#123; low[u] = std::min(low[u], dfn[v]); &#125; &#125; if (dfn[u] == low[u]) &#123; dcc_cnt++; int v; do &#123; v = st.top(); st.pop(); id[v] = dcc_cnt; siz[dcc_cnt]++; &#125; while (v != u); &#125; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); memset(head, 0xff, sizeof(head)); cin &gt;&gt; f &gt;&gt; r; for (int i = 1, u, v; i &lt;= r; i++) &#123; cin &gt;&gt; u &gt;&gt; v; add(u, v); add(v, u); &#125; tarjan(1, -1); for (int i = 0; i &lt; idx; i++) &#123; if (bridge[i]) &#123; in[id[edge[i]]]++; &#125; &#125; for (int i = 1; i &lt;= dcc_cnt; i++) &#123; if (in[i] == 1) ans++; &#125; cout &lt;&lt; (ans + 1) / 2 &lt;&lt; endl; return 0; &#125; "},{"title":"BZOJ - 3831. Little Bird","date":"2022-06-19T21:44:01.000Z","url":"/bzoj-3831/","tags":["动态规划","BZOJ","洛谷","POI","2014","单调队列","单调队列优化 DP"],"categories":["题解"],"content":" 题面 题目描述 森林中有 n 棵树在一条直线上，每棵树有不同的高度。小鸟从第一课树开始跳跃到最后一棵树。如果跳到比当前树矮的，小鸟不会消耗任何体力，但如果跳到的树的高度大于等于当前树的高度，则需要消耗一个体力。 小鸟准备多次不同的尝试，规定了每次的最长跳跃幅度，请求出每次的最少耗费体力值。 输入格式 第一行一个整数 n，表示树的数量。 第二行 n 个整数，第 i 个数为 di​，表示第 i 棵树的高度。 第三行一个整数 q，表示本轮小鸟的步幅限制。 接下来 q 行，每行一个整数 ki​，表示小鸟的最少耗费的体力值。 输出格式 对于每次尝试，输出一行一个整数，表示小鸟的最少耗费体力值。 输入输出样例 样例输入 #1 9 4 6 3 6 3 7 2 6 5 2 2 5 样例输出 #1 2 1 数据范围与约定 对于 100% 的数据，2≤n≤106，1≤di​≤109，1≤q≤25，1≤ki​≤n−1。 思路 设 fi​ 表示从起点飞行到 i 的体力值，易得以下转移方程： fi​=j=i−kmini−1​(fj​+[dj​≤di​])(1) 时间复杂度为 O(qn2)，无法通过本题。 考虑优化。可以发现对于每个 i 都会去遍历一遍 fi−k∼i−1​，因此可以用单调队列来优化。使用单调队列维护到达前面 k 棵树的劳累值最小值（如劳累值相同则取高度最高的放在前面）。 容易证明这种做法是正确的。时间复杂度为 O(qn)，可以通过本题。 代码 #include &lt;iostream&gt; #include &lt;deque&gt; #include &lt;vector&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1000005; int n, q, k, d[N]; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; d[i]; &#125; cin &gt;&gt; q; while (q--) &#123; cin &gt;&gt; k; std::vector&lt;int&gt; f(n + 1); std::deque&lt;int&gt; q; q.push_back(1); for (int i = 2; i &lt;= n; i++) &#123; while (!q.empty() &amp;&amp; q.front() &lt; i - k) q.pop_front(); f[i] = f[q.front()] + (d[q.front()] &lt;= d[i]); while (!q.empty() &amp;&amp; (f[q.back()] &gt; f[i] || f[q.back()] == f[i] &amp;&amp; d[q.back()] &lt;= d[i])) q.pop_back(); q.push_back(i); &#125; cout &lt;&lt; f[n] &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"LibreOJ - 2363. 愤怒的小鸟","date":"2022-06-16T16:21:30.000Z","url":"/libreoj-2363/","tags":["动态规划","洛谷","AcWing","LibreOJ","NOIP","2016","状态压缩"],"categories":["题解"],"content":" 题面 题目描述 Kiana 最近沉迷于一款神奇的游戏无法自拔。 简单来说，这款游戏是在一个平面上进行的。 有一架弹弓位于 (0,0) 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 y=ax2+bx 的曲线，其中 a,b 是 Kiana 指定的参数，且必须满足 a&lt;0，a,b 都是实数。 当小鸟落回地面（即 x 轴）时，它就会瞬间消失。 在游戏的某个关卡里，平面的第一象限中有 n 只绿色的小猪，其中第 i 只小猪所在的坐标为 (xi​,yi​)。 如果某只小鸟的飞行轨迹经过了 (xi​,yi​)，那么第 i 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行； 如果一只小鸟的飞行轨迹没有经过 (xi​,yi​)，那么这只小鸟飞行的全过程就不会对第 i 只小猪产生任何影响。 例如，若两只小猪分别位于 (1,3) 和 (3,3)，Kiana 可以选择发射一只飞行轨迹为 y=−x2+4x 的小鸟，这样两只小猪就会被这只小鸟一起消灭。 而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。 这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入格式」中详述。 假设这款游戏一共有 T 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。 输入格式 第一行包含一个正整数 T，表示游戏的关卡总数。 下面依次输入这 T 个关卡的信息。每个关卡第一行包含两个非负整数 n,m，分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。接下来的 n 行中，第 i 行包含两个正实数 xi​,yi​，表示第 i 只小猪坐标为 (xi​,yi​)。数据保证同一个关卡中不存在两只坐标完全相同的小猪。 如果 m=0，表示 Kiana 输入了一个没有任何作用的指令。 如果 m=1，则这个关卡将会满足：至多用 ⌈n/3+1⌉ 只小鸟即可消灭所有小猪。 如果 m=2，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少 ⌊n/3⌋ 只小猪。 保证 1≤n≤18，0≤m≤2，0&lt;xi​,yi​&lt;10，输入中的实数均保留到小数点后两位。 上文中，符号 ⌈c⌉ 和 ⌊c⌋ 分别表示对 c 向上取整和向下取整，例如：⌈2.1⌉=⌈2.9⌉=⌈3.0⌉=⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3。 输出格式 对每个关卡依次输出一行答案。 输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。 输入输出样例 样例输入 #1 2 2 0 1.00 3.00 3.00 3.00 5 2 1.00 5.00 2.00 8.00 3.00 9.00 4.00 8.00 5.00 5.00 样例输出 #1 1 1 样例解释 #1 这组数据中一共有两个关卡。 第一个关卡与「问题描述」中的情形相同，2 只小猪分别位于 (1.00,3.00) 和 (3.00,3.00)，只需发射一只飞行轨迹为 y=−x2+4x 的小鸟即可消灭它们。 第二个关卡中有 5 只小猪，但经过观察我们可以发现它们的坐标都在抛物线 y=−x2+6x 上，故 Kiana 只需要发射一只小鸟即可消灭所有小猪。 样例输入 #2 3 2 0 1.41 2.00 1.73 3.00 3 0 1.11 1.41 2.34 1.79 2.98 1.49 5 0 2.72 2.72 2.72 3.14 3.14 2.72 3.14 3.14 5.00 5.00 样例输出 #2 2 2 3 样例输入 #3 1 10 0 7.16 6.28 2.02 0.38 8.33 7.78 7.68 2.09 7.46 7.86 5.77 7.44 8.24 6.72 4.42 5.11 5.42 7.79 8.15 4.99 样例输出 #3 6 数据范围与约定 测试点编号 n⩽ m= T⩽ 1 2 0 10 2 30 3 3 10 4 30 5 4 10 6 30 7 5 10 8 6 9 7 10 8 11 9 30 12 10 13 12 1 14 2 15 15 0 15 16 1 17 2 18 18 0 5 19 1 20 2 思路 查看数据范围，发现 n≤18，所以可以考虑状压 DP。 设 fs​ 表示状态为 s 时使用的小鸟数量，当 s 的第 k 位为 1 时表示第 k 只小猪被已经消灭掉了。 引理： 在同一平面内，过不共线且横坐标各不相同的三点有且仅有一条抛物线。 那么除去原点，再找出两个点即可确定一条唯一的抛物线。 枚举所有可能的抛物线，有以下几种情况： 按照该抛物线飞行的小鸟不能消灭任何小猪。 此时对答案没有贡献，故舍弃。 按照该抛物线飞行的小鸟只能消灭 1 只小猪。 按照该抛物线飞行的小鸟能消灭不少于 2 只小猪。 此时遍历所有的小猪的位置并判断能否消灭掉它，按照位置记录状态即可。 可以证明满足第二点情况的抛物线一定存在。那么我们只需要构造出符合第三点情况的抛物线即可。 {ax12​+bx1​=y1​ax22​+bx2​=y2​​(1)(2)​ (2)÷x2​，有： ax2​+b=x2​y2​​(3) (3)×x1​，有： ax2​x1​+bx1​=x2​y2​x1​​(4) (1)−(4) 并移项，有： a=x1​(x1​−x2​)y1​−x2​y2​x1​​​(5) 再推导 b 的求值式，(2)÷x22​： a+x22​b​=x22​y2​​(6) (6)×x12​，有： ax12​+x22​bx1​​=x22​y2​x1​​(7) (1)−(7) 并移项，有： b=x12​−x2​x12​​y1​−x22​y2​x12​​​(8) 详细实现可以查看下方的代码。 代码 #include &lt;iostream&gt; #include &lt;cstring&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 20; const double eps = 1e-6; int t, n, m, cnt, f[1 &lt;&lt; N], s[N &lt;&lt; 4]; std::pair&lt;double, double&gt; points[N]; inline std::pair&lt;double, double&gt; e(const std::pair&lt;double, double&gt; &amp;a, const std::pair&lt;double, double&gt; &amp;b) &#123; return std::make_pair( (a.second - b.second * a.first / b.first) / (a.first * (a.first - b.first)), (a.second - b.second * a.first * a.first / (b.first * b.first)) / (a.first - a.first * a.first / b.first)); &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; t; while (t--) &#123; cnt = 0; memset(f, 0x3f, sizeof(f)); memset(s, 0x00, sizeof(s)); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; points[i].first &gt;&gt; points[i].second; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (std::abs(points[i].first - points[j].first) &lt; eps) continue; auto r = e(points[i], points[j]); if (r.first &gt; -eps) continue; cnt++; for (int k = 0; k &lt; n; k++) &#123; if (std::abs(r.first * points[k].first * points[k].first + r.second * points[k].first - points[k].second) &lt; eps) &#123; s[cnt] |= 1 &lt;&lt; k; &#125; &#125; &#125; &#125; f[0] = 0; for (int i = 0; i &lt; 1 &lt;&lt; n; i++) &#123; // 两只及以上 for (int j = 1; j &lt;= cnt; j++) &#123; f[i | s[j]] = std::min(f[i | s[j]], f[i] + 1); &#125; // 一只 for (int j = 0; j &lt; n; j++) &#123; f[i | 1 &lt;&lt; j] = std::min(f[i | 1 &lt;&lt; j], f[i] + 1); &#125; &#125; cout &lt;&lt; f[(1 &lt;&lt; n) - 1] &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"UOJ - 118. 进京赶考","date":"2022-06-13T18:46:33.000Z","url":"/uoj-118/","tags":["前缀和","UOJ"],"categories":["题解"],"content":" 题面 题目背景 高中，高中，短暂的三年。NOI 是高中结业考试，而高考在每年暑假举行。 高二暑假，这是你最后一次参加高考的机会。你已经为了高考停课很久了，OI 的知识很久没管了。你并没有能力用一年时间补起别人三年的 OI 课程。这是你的最后一战，如果你失败了，可能就不能工地搬砖只能去清华了。 题目描述 这天你背上行囊赴京赶考。此时全国交通主要靠瞬间传送装置。全国交通网络可以抽象为一张 n 行 m 列的网格图。行依次编号为 1,…,n，列依次编号为 1,…,m。 有 n+m 个为 0 或 1 的整数 a1​,…,an​,b1​,…,bm​。对于 1≤i≤n，1≤j≤m，如果 ai​=bj​ 那么网格图上第 i 行第 j 列上标着 0 否则标着 1。 你的家在第 xs​ 行第 ys​ 列，高考考场在第 xe​ 行第 ye​ 列。现在你想从家出发到高考考场去。每次你可以： 向上移动一行。（如果你在第一行那么移动后会到最后一行去） 向下移动一行。（如果你在最后一行那么移动后会到第一行去） 向左移动一列。（如果你在第一列那么移动后会到最后一列去） 向右移动一列。（如果你在最后一列那么移动后会到第一列去） 对于每次移动，如果移动前的格子上标的数跟移动后的格子上标的数不同，那么就要耗费 1 分钟时间等待瞬移装置调整配置，否则不耗时间。 现在你想知道你从家出发到高考考场最少需要花多长时间。 输入格式 第一行两个正整数 n,m，表示网格图为 n 行 m 列。 第二行 n 个整数，分别表示 a1​,…,an​。保证 a1​,…,an​∈{0,1}。 第三行 m 个整数，分别表示 b1​,…,bm​。保证 b1​,…,bm​∈{0,1}。 接下来一个正整数 q。 接下来 q 行，每行四个整数 xs​,ys​,xe​,ye​。表示询问如果你的家在第 xs​ 行第 ys​ 列，高考考场在第 xe​ 行第 ye​ 列时的最少花费时间。 输出格式 共 q 行，每行一个整数表示最少花费多少分钟。 输入输出样例 样例输入 #1 1 2 1 0 1 2 1 2 1 2 1 1 1 2 样例输出 #1 0 1 样例输入 #2 10 10 1 1 0 1 1 1 0 1 0 1 0 0 1 0 1 1 0 0 1 0 4 7 6 4 8 8 2 1 4 8 5 7 4 3 1 9 5 样例输出 #2 2 4 2 5 数据范围与约定 测试点编号 n m q 1 ≤100 ≤10 2 3 4 ≤105 =10 ≤105 5 6 ≤105 7 8 9 10 思路 由题可知，每次移动只能向上下左右四个方向移动。因为 (i,j) 的权值由 ai​ 和 bj​ 决定，所以从 (i,j) 移动到 (i+1,j) 的耗时与 j 的取值无关，在 y 轴上同理。那么可以分开处理 x 轴和 y 轴，计算出移动距离的前缀和即可以常数级别的复杂度处理每次询问。需要注意的是，向反方向移动也可以到达终点，因此需要取正向移动和反向移动耗时的最小值作为答案。 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 100005; int n, m, q, d_a[N], d_b[N]; bool a[N], b[N]; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; b[i]; &#125; if (a[1] != a[n]) d_a[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; d_a[i] = d_a[i - 1] + (a[i] != a[i + 1]); &#125; if (b[1] != b[m]) d_b[0] = 1; for (int i = 1; i &lt;= m; i++) &#123; d_b[i] = d_b[i - 1] + (b[i] != b[i + 1]); &#125; cin &gt;&gt; q; while (q--) &#123; std::pair&lt;int, int&gt; s, e; cin &gt;&gt; s.first &gt;&gt; s.second &gt;&gt; e.first &gt;&gt; e.second; cout &lt;&lt; std::min(&#123; std::abs(d_a[s.first - 1] - d_a[e.first - 1]), d_a[n - 1] - d_a[std::max(s.first, e.first) - 1] + d_a[std::min(s.first, e.first) - 1], &#125;) + std::min(&#123; std::abs(d_b[s.second - 1] - d_b[e.second - 1]), d_b[m - 1] - d_b[std::max(s.second, e.second) - 1] + d_b[std::min(s.second, e.second) - 1], &#125;) &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"洛谷 - P2906  Cow Neighborhoods G","date":"2022-06-07T21:29:18.000Z","url":"/luogu-p2906/","tags":["2008","洛谷","USACO","STL","并查集"],"categories":["题解"],"content":" 测试数据可以在 Luogu/P2906/data 目录下获得，与洛谷上的测试点顺序有偏差。 题面 题目描述 了解奶牛的人都知道奶牛是如何组成「奶牛社区」的。他们观察了 Farmer John 的 N 头奶牛（编号为 1∼N），它们在 X 和 Y 坐标范围为 1 的牧场上放牧，每头奶牛都在自己唯一的整数直线坐标上。 如果满足以下两个标准中的至少一个，则两头奶牛是邻居： 两只奶牛的曼哈顿距离不超过 C，即 ∣Xi​−xi​∣+∣Yi​−yi​∣≤C； 两只奶牛有共同的邻居。即存在一只奶牛 k，使 i 与 k，j 与 k 均同属一个群。 给定奶牛的位置和距离 C，确定「奶牛社区」的数量和最大的「奶牛社区」中的奶牛数量。 例如，考虑下面的牧场。 当 C=4 时，这个牧场有四个社区：左边的一个大社区，两个大小为 1 的社区，右边有一个巨大的社区，里面有 60 头不同的奶牛。 .....................................*................. ....*...*..*.......................***................. ......*...........................****................. ..*....*..*.......................*...*.******.*.*..... ........................*.............***...***...*.... *..*..*...*..........................*..*...*..*...*... .....................................*..*...*..*....... .....................................*..*...*..*....... ...*................*.................................. .*..*............................*.*.*.*.*.*.*.*.*.*.*. .*.....*..........................*.*.*.*.*.*.*.*.*.*.* ....*.................................................. 输入格式 第 1 行包含两个用空格分隔的整数 N,C。 第 2 到第 N+1 行每行包含两个用空格分隔的整数 Xi​,Yi​，表示一头牛的坐标。 输出格式 共一行，为两个用空格分隔的整数，为「奶牛社区」的数量和最大的「奶牛社区」内牛的数量。 输入输出样例 样例输入 #1 4 2 1 1 3 3 2 2 10 10 样例输出 #1 2 3 样例说明 #1 样例中有 2 个社区，一个由前三头奶牛组成，另一个是最后一头奶牛。因此，最大的社区大小为 3。 数据范围与约定 对于 100% 的数据，1≤N≤105，1≤C≤109，1≤Xi​,Yi​≤109，Xi​,Yi​ 均为整数。 思路 机房巨佬于队曾经教过我们一个小 trick：曼哈顿距离和切比雪夫距离之间的转化。 曼哈顿坐标系是通过将切比雪夫坐标系旋转 4π​ 后再缩小到原来的一半得到的。那么可以通过将 (x,y) 变为 (x+y,x−y) 得到曼哈顿坐标系。 记题中第 i 个点 (Xi​,Yi​) 的切比雪夫坐标为 (xi​,yi​)，那么限制 1 可以改写成： 两只奶牛的切比雪夫距离不超过 C，即 max(∣x1​−x2​∣,∣y1​−y2​∣)≤C。 那么可以先以 x 轴坐标为第一关键字，y 轴坐标为第二关键字从小到大排序，并使用并查集合并同一群的奶牛。然后使用 set 维护 y 轴坐标的值，在插入每个点之前将 x 轴坐标不合法的删除，然后使用 lower_bound 找到 yi​ 的前驱和后继，如果满足限制则将其与 yi​ 合并。最后统计连通块个数和最大连通块大小即可。 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;set&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5; int n, c, fa[N], cnt[N], ans, max; std::pair&lt;int, int&gt; points[N]; std::set&lt;std::pair&lt;int, int&gt;&gt; set; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; inline void merge(int x, int y) &#123; fa[find(x)] = find(y); &#125; int main() &#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; c; for (int i = 1, x, y; i &lt;= n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; points[i] = std::make_pair(x + y, x - y); fa[i] = i; &#125; std::sort(points + 1, points + 1 + n); set.insert(std::make_pair(points[1].second, 1)); for (int i = 2, l = 1; i &lt;= n; i++) &#123; while (points[i].first - points[l].first &gt; c) &#123; set.erase(std::make_pair(points[l].second, l)); l++; &#125; auto it = set.lower_bound(std::make_pair(points[i].second, 0)); if (it != set.end() &amp;&amp; it-&gt;first - points[i].second &lt;= c) &#123; merge(i, it-&gt;second); &#125; if (it != set.begin() &amp;&amp; points[i].second - (--it)-&gt;first &lt;= c) &#123; merge(i, it-&gt;second); &#125; set.insert(std::make_pair(points[i].second, i)); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (find(i) == i) ans++; max = std::max(max, ++cnt[find(i)]); &#125; cout &lt;&lt; ans &lt;&lt; &#x27; &#x27; &lt;&lt; max &lt;&lt; endl; return 0; &#125; "},{"title":"线性基学习笔记","date":"2022-06-06T09:12:31.000Z","url":"/linear-basis/","tags":["数学","线性代数","线性空间","线性基"],"categories":["笔记"],"content":"线性基在竞赛中常用来解决子集异或类题目。 如无特殊说明，本文中所述的集合均为无符号整数集。 前置知识 异或和 集合 S 的异或和为 xori=1∣S∣​Si​（即 S1​ xor S2​ xor … xor S∣S∣​）。 张成 设 T⊆S，所有这样的子集 T 异或和组成的集合称为 S 的张成，记为 span(S)。即在 S 中选出任意多个数，其异或和的所有可能的结果组成的集合。 线性相关与线性无关 对于一个集合 S，如果存在一个元素 Si​ 使得 S 在去除这个元素后得到的集合 S′ 满足 Si​∈span(S′)，即存在一个元素 Si​ 可以通过集合中的若干个剩余元素异或得到，则称集合 S 线性相关。 相对地，如果不存在这样的元素 Si​，则称集合 S 线性无关。 线性基 定义 我们称集合 B 是集合 S 的线性基，当且仅当： S⊆span(B)； B 是线性无关的。 集合 B 中元素的个数称为线性基的 长度。 线性基有以下几个性质： S 中的任意元素都可以 唯一 表示为 B 中若干个元素的异或和（对应条件 1）； B 是极小的满足线性基性质的集合，它的任何真子集都不可能是线性基（对应条件 2）； B 中没有异或和为 0 的子集（对应条件 2）； B 中每个元素的二进制最高位互不相同； 在 B 中选取若干个元素异或起来得到一个元素，用这个元素去替换 B 中的任意一个元素，得到的新集合 B′ 张成的空间不变。 构造 方法 1方法 2对集合 S 的每个数 x 转为二进制，自高位向低位扫描，若 x 的第 k 位为 1，如果 ak​ 不存在，那么令 ak​=x 并结束扫描，如果存在则令 x=x xor ak​。 在 Menci 的《线性基学习笔记》中还给出了另一种线性基的构造方法，这种方法将原本的三角基消为了对角基： 设集合 S 中最大的数在二进制意义下有 L 位，我们使用一个 [0…L] 的数组 a 来储存线性基。 逆序枚举 t 所有为 1 的二进制位 j=L→0，对于每个 j 如果 aj​=0，则令 t=txoraj​； 如果 aj​=0，则： 枚举 k∈[0,j)，如果 t 的第 k 位为 1，则令 t=txorak​； 枚举 k∈(j,L]，如果 ak​ 的第 j 位为 1，则令 ak​=ak​xort； 令 aj​=t，结束插入过程。 这种线性基的构造方法保证了一个特殊性质，对于每一个 i，ai​ 有以下两种可能： ai​=0，并且： 只有 满足 j&gt;i 的 aj​（即，位于 ai​ 后面的所有 aj​）的第 i 个二进制位 可能 为 1。 ai​=0，并且： 整个 a 数组中 只有 ai​ 的第 i 个二进制位为 1； ai​ 更高的二进制位（&gt;i 的二进制位）一定为 0； ai​ 更低的二进制位（&lt;i 的二进制位）可能为 1。 代码 方法 1方法 2inline void insert(unsigned long long x) &#123; for (int i = 50; ~i; i--) &#123; if ((x &gt;&gt; i) &amp; 1) &#123; if (a[i]) &#123; x ^= a[i]; &#125; else &#123; a[i] = x; return; &#125; &#125; &#125; &#125;inline void insert(unsigned long long x) &#123; for (int i = 50; ~i; i--) &#123; if ((x &gt;&gt; i) &amp; 1) &#123; if (a[i]) &#123; x ^= a[i]; &#125; else &#123; for (int k = 0; k &lt; i; k++) &#123; if (x &amp; (1ull &lt;&lt; k)) x ^= a[k]; &#125; for (int k = i + 1; k &lt;= 50; k++) &#123; if (a[k] &amp; (1ull &lt;&lt; i)) a[k] ^= x; &#125; a[i] = x; return; &#125; &#125; &#125; &#125; 应用 检查某个数是否能被表示成集合中若干元素的异或和 首先构造出这个集合的线性基，然后检测这个数是否能被插入到线性基中即可。 inline bool check(unsigned long long x) &#123; for (int i = 50; ~i; i--) &#123; if ((x &gt;&gt; i) &amp; 1) &#123; if (a[i]) &#123; x ^= a[i]; &#125; else &#123; // 能被插入表示集合的张成中不包括 x return false; &#125; &#125; &#125; return true; &#125; 求最大子集异或和 从高位到低位考虑基，若异或后变大，则异或。 由于 a0∼i−1​ 都不含 i 及以上的位，其最大贡献仅为 2i−1。有两种情况： 若此时 ans 的第 i 位是 0，则异或上 ai​ 至少带来 2i 的收益，大于后面可能的所有收益。同时，(ans ^ a[i]) &gt; ans 也必然成立。 若此时 ans 的第 i 位是 1，至少在这一位有 2i 的亏损，大于后面的位可能的所有收益。同时，(ans ^ a[i]) &gt; ans 也必不成立。 方法 1方法 2for (int i = 50; ~i; i++) &#123; if ((ans ^ a[i]) &gt; ans) ans ^= a[i]; &#125;这种做法由于将三角基消为了对角基，所以第二种情况不会出现。 for (int i = 0; i &lt;= 50; i++) &#123; ans ^= a[i]; &#125; 合并线性基 暴力插入即可。 inline void insert(unsigned long long *a, unsigned long long x); void merge(unsigned long long *a, unsigned long long *b) &#123; for (int i = 0; i &lt;= 50; i++) &#123; insert(a, b[i]); &#125; &#125; 第 k 小子集异或和 先将按照上文中的「方法 2」建立对角线性基。 将 k 二进制拆分，每一位的 0 / 1 对应异或时选 / 不选线性基存在的这一位。 证明：线性基中存在的位的 0 / 1 唯一确定了一个异或出的数，由于每个位只在一个基中为 1，这些位组成的二进制数的大小就可以代表异或出的数的大小。 题目：LibreOJ #114. k 大异或和 预处理出线性基中所有存在的位： for (int i = 0; i &lt;= 50; i++) &#123; if (a[i]) p[cnt++] = a[i]; &#125; 对于每次询问 k： if (cnt != n) k--; // 确保选择的是非空子集 if (k &gt;= (1ull &lt;&lt; cnt)) &#123; // 不同的异或和数量不足 k cout &lt;&lt; -1 &lt;&lt; endl; &#125; else &#123; ans = 0; for (int i = 0; i &lt; cnt; i++) &#123; if (k &amp; (1ull &lt;&lt; i)) ans ^= p[i]; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; 参考资料 线性基学习笔记，游宇凡，2019 年 6 月 12 日。 线性基学习笔记，黄浩睿，2017 年 2 月 25 日。 线性基小记，command-block，2020 年 10 月 21 日。 线性基，OI Wiki，2021 年 3 月 13 日。 "},{"title":"C++ 输入输出的速度优化与实际测试","date":"2022-05-31T20:48:15.000Z","url":"/cpp-io-speed-optimization/","tags":["C++","STL","速度优化"],"categories":["杂项"],"content":" TL;DR 使用下面的这段代码可以为标准 C++ 流的输入输出提速。 const char endl = &#x27;\\n&#x27;; std::ios::sync_with_stdio(false); cin.tie(nullptr); 使用时有几个注意事项： 关闭了流同步后，切莫将 C++ 风格的输入输出与 C 风格的输入输出（如 scanf 和 printf）混用，否则会造成意料之外的错误。 如果需要清空缓冲区，请使用 std::flush 或者 std::endl。 cout.tie(nullptr) 在一般情况下是非必要的，因为其在初始化时并没有绑定其他流。 原理 关闭与标准 C 流之间的同步 根据 C++ Reference 上的描述： std::ios_base::sync_with_stdio static bool sync_with_stdio( bool sync = true ); 设置标准 C++ 流是否与标准 C 流在每次输入/输出操作后同步。 标准 C++ 流为下列者：std::cin、std::cout、std::cerr、std::clog、std::wcin、std::wcout、std::wcerr 和 std::wclog。 标准 C 流为下列者：stdin、stdout 和 stderr。 对于与 C 流 f 同步的标准流 str，下列函数对拥有等同的效果： std::fputc(f, c) 和 str.rdbuf()-&gt;sputc(c) std::fgetc(f) 和 str.rdbuf()-&gt;sbumpc() std::ungetc(c, f) 和 str.rdbuf()-&gt;sputbackc(c) 实践中，这表示同步的 C++ 流为无缓冲，而每次 C++ 流上的 I/O 都立即应用到对应 C 流的缓冲区。这使得能自由地混合 C++ 与 C I/O。 另外，同步的 C++ 流保证为线程安全（从多个线程输出的单独字符可能交错，但无数据竞争）。 若关闭同步，则允许 C++ 标准流独立地缓冲其 I/O ，可认为这在某些情况下更快。 所有八个标准 C++ 流默认与其相应的 C 流同步。 若在标准流上已出现 I/O 后调用此函数，则行为是实现定义的：有的实现无效果，有的实现销毁读取缓冲区。 可以得知以下信息： C++ 为了保证兼容性，默认将标准 C++ 流的数据与标准 C 流同步，并将缓冲数据放置到标准 C 流的缓冲区中，但这样会减慢速度。 当关闭同步时会导致程序的不同线程之间的 I/O 冲突，不过 OI 中并不涉及。 在程序运行到产生首次输入输出后关闭同步的行为是由实现定义的。 那么可以通过关闭流同步的方式来解决第一点问题： std::ios::sync_with_stdio(false); 将这行代码放到主函数的起始位置即可。 由第三点信息可知，不能在运行时反复开启/关闭流同步，防止出现错误。 使用 \\n 代替 std::endl 根据 C++ Reference 上的描述： std::endl template&lt; class CharT, class Traits &gt; std::basic_ostream&lt;CharT, Traits&gt;&amp; endl( std::basic_ostream&lt;CharT, Traits&gt;&amp; os ); 插入换行符到输出序列 os 并冲入它，如同调用 os.put(os.widen('\\n')) 后随 os.flush()。 这是仅输出的 I/O 操纵符，可对任何 std::basic_ostream 类型的 out 以表达式 out &lt;&lt; std::endl 调用它。 可以得知，在调用 std::endl 时不仅输出了换行符，而且还清空了缓冲区。众所周知，频繁清空缓冲区会导致程序运行速度的下降，所以应该尽量避免使用 std::endl 作为换行符。 那么可以通过使用 \\n 来替代 std::endl 的做法来提升速度： const char endl = &#x27;\\n&#x27;; // 或者（不推荐） #define endl &#x27;\\n&#x27; 不推荐使用 endl 的原因是，如果遇到特殊情况需要使用 std::endl 时，define 会将 std::endl 中的 endl 替换为 \\n 导致编译错误。 取消 cin 与 cout 之间的联系 根据 C++ Reference 上的描述： std::basic_ios::tie std::basic_ostream&lt;CharT,Traits&gt;* tie() const; // (1) std::basic_ostream&lt;CharT,Traits&gt;* tie( std::basic_ostream&lt;CharT,Traits&gt;* str ); // (2) 管理联系流。联系流是输出流，它与流缓冲（rdbuf()）所控制的输出序列同步，即在任何 *this 上的输入/输出操作前，在联系流上调用 flush()。 返回当前联系流。若无联系流，则返回空指针。 设置当前联系流为 str 。返回操作前的联系流。若无联系流，则返回空指针。 可以得知，如果一个流设置了联系流，在它进行输入/输出操作前会清除其联系流的缓冲区。众所周知，频繁清空缓冲区会导致程序运行速度的下降，所以如非必要，在竞赛中可以取消 std::cin 和 std::cout 间的联系以获得更快的输入输出速度： cin.tie(nullptr); 无需使用 cout.tie(nullptr) 查看 ISO C++ 14 标准（ISO/IEC 14882:2014(E)，原文见文末附件）： 此处（第 999 页）并没有对 std::cout 的 tie() 赋初值。 在第 1012 页中，指明了 tie() 的初值为 0，即未绑定任何流。 所以，std::cout 在初始时并未与任何流产生绑定，所以无需取消 std::cout 与其他流的绑定。cout.tie(nullptr) 是多余的，可以删去。 测试 输入数据为 LibreOJ 7. Input Test 的测试点 5，大小为 59.7 MB。测试选择在 LibreOJ 评测量较为平稳时进行。不用洛谷测试的原因是怕被管理封号，我自己的 LibreOJ 账号有管理权限不怕被封。 结果 用时 O2 优化 cin.tie(nullptr) 与标准 C 流同步 换行符 1820 ms 是 是 是 std::endl 1041 ms \\n 1107 ms 否 std::endl 335 ms \\n 1803 ms 是 std::endl 1053 ms \\n 1100 ms 否 std::endl 335 ms \\n 1877 ms 否 是 std::endl 1801 ms \\n 1117 ms 否 std::endl 1160 ms \\n 1810 ms 是 std::endl 1826 ms \\n 1093 ms 否 std::endl 1159 ms \\n 1810 ms 否 是 是 std::endl 1020 ms \\n 1095 ms 否 std::endl 347 ms \\n 1808 ms 是 std::endl 1045 ms \\n 1105 ms 否 std::endl 355 ms \\n 1837 ms 否 是 std::endl 1832 ms \\n 1095 ms 否 std::endl 1133 ms \\n 1872 ms 是 std::endl 1845 ms \\n 1098 ms 否 std::endl 1130 ms \\n 代码 #include &lt;iostream&gt; using std::cin; using std::cout; // [1]: 换行符不同 const char endl = &#x27;\\n&#x27;; // 或 // using std::endl; unsigned long long x, ans; int main() &#123; // [2]: 是否与标准 C 流同步 std::ios::sync_with_stdio(false); // [3]: 是否取消 cin 与其他流之间的关联 cin.tie(nullptr); // [4]: 是否取消 cout 与其他流之间的关联 cout.tie(nullptr); for (int i = 0; i &lt; 3000000; i++) &#123; cin &gt;&gt; x; cout &lt;&lt; (ans ^= x) &lt;&lt; endl; &#125; return 0; &#125; 实际测试 7. Input Test #1472987，O2 优化 + 读输优化，559 ms。 #1473174，O2 优化，2207 ms。 10145. 「一本通 4.6 练习 2」郁闷的出纳员 #1472998，O2 优化 + 读输优化，253 ms。 #1473175，O2 优化，399 ms。 结语 感谢你完整阅读了本文。 通过本文，相信读者对 C++ 的输入/输出流又有了更深的认识。按照本文所叙述的方法去操作，你就可以获得一个媲美 scanf 和 printf 的速度的 C++ 风格的输入了。 如果本文中有笔者遗漏、编写错误的地方，欢迎指正。 参考资料 std::basic_ios&lt;CharT,Traits&gt;::tie，C++ Reference，2021 年 1 月 1 日。 std::ios_base::sync_with_stdio，2017 年 11 月 23 日。 std::flush，2017 年 11 月 18 日。 27.4 Standard iostream objects，ISO/IEC 14882:2014(E)。 感谢 LibreOJ 提供的高效、稳定的测评服务。 "},{"title":"洛谷 - P2421 荒岛野人","date":"2022-05-29T21:13:10.000Z","url":"/luogu-p2421/","tags":["数学","洛谷","LibreOJ","扩展欧几里得算法","NOI","2002"],"categories":["题解"],"content":" 题面 题目描述 克里特岛以野人群居而著称。岛上有排列成环行的 m 个山洞。这些山洞顺时针编号为 1,2,…,m。岛上住着 n 个野人，一开始依次住在山洞 C1​,C2​,…,Cn​中，以后每年，第 i 个野人会沿顺时针向前走 Pi​ 个洞住下来。 每个野人 i 有一个寿命值 Li​，即生存的年数。 下面四幅图描述了一个有 6 个山洞，住有三个野人的岛上前四年的情况。三个野人初始的洞穴编号依次为 1,2,3；每年要走过的洞穴数依次为 3,7,2；寿命值依次为 4,3,1。 奇怪的是，虽然野人有很多，但没有任何两个野人在有生之年处在同一个山洞中，使得小岛一直保持和平与宁静，这让科学家们很是惊奇。他们想知道，至少有多少个山洞，才能维持岛上的和平呢？ 输入格式 第 1 行为一个整数 n，即野人的数目。 第 2 行到第 n+1 每行为三个整数 Ci​,Pi​,Li​，表示每个野人所住的初始洞穴编号，每年走过的洞穴数及寿命值。 输出格式 仅包含一个数 m，即最少可能的山洞数。输入数据保证有解，且 m 不大于 106。 输入输出样例 样例输入 #1 3 1 3 4 2 7 3 3 2 1 样例输出 #1 6 数据范围与约定 对于 100% 的数据，1≤n≤15，1≤Ci​,Pi​≤100，0≤Li​≤106，最终答案 m≤106。 思路 当 i=j 且 i,j∈[1,n] 时，第 i 个野人和第 j 个野人在同一个山洞中当且仅当情况如下： Ci​+xPi​≡Cj​+xPj​(modm)(1) 那么只需要使其在 [0,min(Li​,Lj​)] 范围内无解即可维持岛上的和平。 移项，有： x(Pi​−Pj​)≡Cj​−Ci​(modm)(2) 那么可以使用扩展欧几里得算法求出 (2) 式的解： (Pi​−Pj​)x+my=Cj​−Ci​(3) 再观察数据范围，发现答案 m≤106，那么可以考虑在 [max1≤i≤n​Ci​,106] 区间内枚举答案，复杂度为 O(mn2logCi​)，可以通过本题。 题外话：今天下午打模拟赛的时候这道题的 (3) 式推错了没切掉，真是可惜啊。 注：本题答案不具有单调性，不能二分。 代码 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;tuple&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 20; int n, max, ans; std::tuple&lt;int, int, int&gt; a[N]; int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int g = exgcd(b, a % b, y, x); y -= a / b * x; return g; &#125; bool check(int k) &#123; for (int i = 1; i &lt; n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; int c1, p1, l1, c2, p2, l2; std::tie(c1, p1, l1) = a[i]; std::tie(c2, p2, l2) = a[j]; int a = p1 - p2, b = k, c = c2 - c1; int x, y, g = exgcd(a, b, x, y); if (c % g) continue; // 此处 g 可能是负数，因此需要取绝对值 a /= g, b = std::abs(b / g), c /= g; x = (x * c % b + b) % b; if (x &lt;= std::min(l1, l2)) return false; &#125; &#125; return true; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1, c, p, l; i &lt;= n; i++) &#123; cin &gt;&gt; std::get&lt;0&gt;(a[i]) &gt;&gt; std::get&lt;1&gt;(a[i]) &gt;&gt; std::get&lt;2&gt;(a[i]); max = std::max(max, std::get&lt;0&gt;(a[i])); &#125; for (int i = max; i &lt;= 1000000; i++) &#123; if (check(i)) &#123; cout &lt;&lt; i &lt;&lt; endl; exit(0); &#125; &#125; return 0; &#125; 感谢 JohnSonloy 指出本文中的错误，已修正。 "},{"title":"洛谷 - P3586 LOG","date":"2022-05-26T15:53:15.000Z","url":"/luogu-p3586/","tags":["数据结构","洛谷","POI","2015","树状数组"],"categories":["题解"],"content":" 题面 题目描述 维护一个长度为 n 的序列，一开始都是 0，支持以下两种操作： U k a 将序列中第 k 个数修改为 a。 Z c s 在这个序列上，每次选出 c 个正数，并将它们都减去 1，询问能否进行 s 次操作。 每次询问独立，即每次询问不会对序列进行修改。 输入格式 第一行包含两个正整数 n,m，分别表示序列长度和操作次数。 接下来 m 行为 m 个操作。 输出格式 包含若干行，对于每个 Z 询问，若可行，输出 TAK，否则输出 NIE。 输入输出样例 样例输入 #1 3 8 U 1 5 U 2 7 Z 2 6 U 3 1 Z 2 6 U 2 2 Z 2 6 Z 2 1 样例输出 #1 NIE TAK NIE TAK 数据范围与约定 对于 100% 的数据，1≤n,m≤106，1≤k,c≤n，0≤a≤109，1≤s≤109。 原题名称为 Logistyka。 思路 本题的答案实际上和序列无关，因此可以将序列看作一个集合来处理。设 ≥s 的数有 x 个，&lt;s 的数和为 sum，有结论如下： 如果无法满足 sum≥(c−x)×s 则操作一定不能成功，满足后要证明每次取有至少 c 个数。那么考虑小于 s 的数最少的时候有 ⌈s−1sum​⌉ 个，如果满足 sum≥(c−x)×s，则 ⌈s−1sum​⌉&gt;c−x，此时一定有解。 代码 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 2e6 + 5; int n, m, x[N], y[N], a[N], p, nums[N]; char op[N]; long long c1[N], c2[N]; inline int lowbit(int x) &#123; return x &amp; -x; &#125; void add(long long *c, int x, int y) &#123; for (; x &lt;= n + m; x += lowbit(x)) c[x] += y; &#125; long long sum(long long *c, int x) &#123; long long ans = 0; for (; x; x -= lowbit(x)) ans += c[x]; return ans; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; op[i] &gt;&gt; x[i] &gt;&gt; y[i]; nums[++p] = y[i]; &#125; std::sort(nums + 1, nums + 1 + p); p = std::unique(nums + 1, nums + 1 + p) - nums - 1; for (int i = 1, k; i &lt;= m; i++) &#123; y[i] = std::lower_bound(nums + 1, nums + 1 + p, y[i]) - nums; if (op[i] == &#x27;U&#x27;) &#123; if (k = a[x[i]]) &#123; add(c1, k, -1); add(c2, k, -nums[k]); &#125; k = a[x[i]] = y[i]; add(c1, k, 1); add(c2, k, nums[k]); &#125; else &#123; // op[i] == &#x27;Z&#x27; int c = sum(c1, p) - sum(c1, y[i] - 1); long long s = sum(c2, y[i] - 1); cout &lt;&lt; (s &gt;= 1ll * (x[i] - c) * nums[y[i]] ? &quot;TAK&quot; : &quot;NIE&quot;) &lt;&lt; endl; &#125; &#125; return 0; &#125; "},{"title":"CDQ 分治学习笔记","date":"2022-05-25T21:25:49.000Z","url":"/cdq-divide/","tags":["数据结构","杂项","离线","CDQ 分治"],"categories":["笔记"],"content":"CDQ 分治是 OI 中的一个比较常用的分治算法。该算法最早由 IOI2008 金牌得主陈丹琦提出，并因此得名。 本文主要讲解使用 CDQ 分治解决点对三维偏序问题。 点对三维偏序问题的基本模型如下： 有 n 个元素，第 i 个元素有 ai​,bi​,ci​ 三个属性，设 f(i) 表示满足 aj​≤ai​ 且 bj​≤bi​ 且 cj​≤ci​ 且 j=i 的 j 的数量。给定一个或多个 x，求 f(x) 的值。 实现 CDQ 分治解决这类问题的算法流程如下： 找到这个序列的中点 mid； 将所有点对 (i,j) 划分为 3 类： 1≤i,j≤mid 的点对； 1≤i≤mid,mid+1≤j≤n 的点对； mid+1≤i,j≤n 的点对。 将 (1,n) 这个序列拆成两个序列 (1,mid) 和 (mid+1,n)。此时第一类点对和第三类点对都在这两个序列之中； 递归地处理这两类点对； 设法处理第二类点对。 可以看到 CDQ 分治的思想就是不断地把点对通过递归的方式分给左右两个区间。 在实际应用时，我们通常使用一个函数 solve(l, r) 处理 l≤i,j≤r 的点对。上述算法流程中的递归部分便是通过 solve(l, mid) 与 solve(mid, r) 来实现的。剩下的第二类点对则需要额外设计算法解决。 代码 对应题目：P3810 【模板】三维偏序（陌上花开） #include &lt;algorithm&gt; #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5, K = 2e5 + 5; int n, k, ans[K]; int c[K]; struct node &#123; int a, b, c, cnt, res; node() : a(0), b(0), c(0), cnt(0), res(0) &#123;&#125; node(int _a, int _b, int _c) : a(_a), b(_b), c(_c), cnt(1), res(0) &#123;&#125; bool operator&lt;(const node&amp; x) const &#123; return a == x.a ? b == x.b ? c &lt; x.c : b &lt; x.b : a &lt; x.a; &#125; bool operator==(const node&amp; x) const &#123; return a == x.a &amp;&amp; b == x.b &amp;&amp; c == x.c; &#125; &#125; q[N], w[N]; inline int lowbit(int x) &#123; return x &amp; -x; &#125; void add(int x, int y) &#123; for (; x &lt;= 2e5; x += lowbit(x)) c[x] += y; &#125; int sum(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += c[x]; return res; &#125; void solve(int l, int r) &#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; // 分治 solve(l, mid); solve(mid + 1, r); // 双指针处理第二维 int i = l, j = mid + 1, k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (q[i].b &lt;= q[j].b) &#123; // 树状数组处理第三维 add(q[i].c, q[i].cnt); w[++k] = q[i++]; &#125; else &#123; q[j].res += sum(q[j].c); w[++k] = q[j++]; &#125; &#125; // 补齐剩余部分 while (i &lt;= mid) &#123; add(q[i].c, q[i].cnt); w[++k] = q[i++]; &#125; while (j &lt;= r) &#123; q[j].res += sum(q[j].c); w[++k] = q[j++]; &#125; // 恢复原状 for (int i = l; i &lt;= mid; i++) add(q[i].c, -q[i].cnt); for (int i = l, j = 1; j &lt;= k; i++, j++) q[i] = w[j]; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1, a, b, c; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; q[i] = node(a, b, c); &#125; // 排序处理第一维 std::sort(q + 1, q + 1 + n); int k = 1; for (int i = 2; i &lt;= n; i++) &#123; if (q[i] == q[k]) &#123; q[k].cnt++; &#125; else &#123; q[++k] = q[i]; &#125; &#125; // 分治 solve(1, k); // 计算答案 for (int i = 1; i &lt;= k; i++) &#123; ans[q[i].res + q[i].cnt - 1] += q[i].cnt; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; endl; &#125; return 0; &#125; 参考资料 从《Cash》谈一类分治算法的应用（文件存档备份），陈丹琦，2008 年。 2.15 CDQ 分治，AcWing 算法进阶课，闫学灿，2020 年 11 月 20 日。 CDQ 分治，OI Wiki，2021 年 10 月 11 日。 "},{"title":"点分治学习笔记","date":"2022-05-24T21:38:57.000Z","url":"/tree-divide/","tags":["图论","树分治","点分治","分治"],"categories":["笔记"],"content":"点分治是用来解决树上路径问题的一种方法。 树的重心 定义 一棵树的重心是该树以该点为根时最大子树最小的点。 性质 以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。 树至多有两个重心。如果树有两个重心，那么它们相邻。此时树一定有偶数个节点，且可以被划分为两个大小相等的分支，每个分支各自包含一个重心。 树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。 往树上增加或减少一个叶子，如果原节点数是奇数，那么重心可能增加一个，原重心仍是重心；如果原节点数是偶数，重心可能减少一个，另一个重心仍是重心。 把两棵树通过一条边相连得到一棵新的树，则新的重心在较大的一棵树一侧的连接点与原重心之间的简单路径上。如果两棵树大小一样，则重心就是两个连接点。 求法 求重心可以用一次 DFS 完成。 在 DFS 中计算每个子树的大小，记录“向下”的子树的最大大小，利用总点数 - 当前子树（这里的子树指有根树的子树）的大小得到“向上”的子树的大小，然后就可以依据定义找到重心了。 代码 int root, siz[N], max[N]; void find(int u, int fa, int tot) &#123; siz[u] = 1; max[u] = 0; for (auto e : g[u]) &#123; int v = e.first, w = e.second; if (v == fa || vis[v]) continue; find(v, u, tot); siz[u] += siz[v]; max[u] = std::max(max[u], siz[v]); &#125; max[u] = std::max(max[u], tot - siz[u]); if (max[u] &lt; max[root]) root = u; &#125; 点分治 实现 先选择一个节点 p 作为根节点，则相对 p 而言，树上的路径可以分为两类： 经过根节点 p； 包含于 p 的某一棵子树中。 根据分治的思想，对于第 2 类路径，可以将 p 的每棵子树作为子问题递归求解。 对于第 1 类路径，可以从根节点 p 将路径分为 u→p 和 p→v 两端。然后从 p 出大对整棵树进行 DFS，求出 dist 数组表示从根节点 p 走到节点 x 的距离。 对于 P3806 【模板】点分治 1 这道题，在求出某棵子树的 dist 数组之后，若存在一条长为 queryj​−disti​ 的路径（这个路径是上一棵及以前的子树中到根节点的），则整棵树中一定存在长为 queryj​ 的路径，标记答案数组即可。本轮循环完成后再将本次的 dist 数组标记到 exists 数组中以供下次使用。 代码 #include &lt;iostream&gt; #include &lt;limits&gt; #include &lt;queue&gt; #include &lt;vector&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e4 + 5, K = 1e8 + 5; int n, m, query[N]; int root, siz[N], max[N]; int cnt, dist[N]; bool vis[N], exists[K], ans[N]; std::vector&lt;std::pair&lt;int, int&gt;&gt; g[N]; void find(int u, int fa, int tot) &#123; siz[u] = 1; max[u] = 0; for (auto e : g[u]) &#123; int v = e.first, w = e.second; if (v == fa || vis[v]) continue; find(v, u, tot); siz[u] += siz[v]; max[u] = std::max(max[u], siz[v]); &#125; max[u] = std::max(max[u], tot - siz[u]); if (max[u] &lt; max[root]) root = u; &#125; void dis(int u, int fa, int sum) &#123; dist[++cnt] = sum; for (auto e : g[u]) &#123; int v = e.first, w = e.second; if (v == fa || vis[v]) continue; dis(v, u, sum + w); &#125; &#125; void calc(int u) &#123; std::queue&lt;int&gt; q; for (auto e : g[u]) &#123; int v = e.first, w = e.second; if (vis[v]) continue; cnt = 0; dis(v, u, w); for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (query[j] &gt;= dist[i]) &#123; ans[j] |= exists[query[j] - dist[i]]; &#125; &#125; &#125; for (int i = 1; i &lt;= cnt; i++) &#123; q.push(dist[i]); exists[dist[i]] = true; &#125; &#125; while (!q.empty()) &#123; exists[q.front()] = false; q.pop(); &#125; &#125; void solve(int u) &#123; vis[u] = true; exists[0] = true; calc(u); for (auto e : g[u]) &#123; int v = e.first, w = e.second; if (vis[v]) continue; max[root = 0] = std::numeric_limits&lt;int&gt;::max(); find(v, 0, siz[v]); solve(root); &#125; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1, u, v, w; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(std::make_pair(v, w)); g[v].push_back(std::make_pair(u, w)); &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; query[i]; &#125; cnt = 0; max[root = 0] = n; find(1, 0, n); solve(root); for (int i = 1; i &lt;= m; i++) &#123; cout &lt;&lt; (ans[i] ? &quot;AYE&quot; : &quot;NAY&quot;) &lt;&lt; endl; &#125; return 0; &#125; 参考资料 0x45 点分治，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 一种基于错误的寻找重心方法的点分治的复杂度分析，刘承奥，2017 年 9 月 24 日。 树分治，OI Wiki，2022 年 2 月 13 日。 点分治学习笔记，黄浩睿，2016 年 6 月 17 日。 题解：P3806 【模板】点分治 1，niiick，2020 年 8 月 8 日。 2.14 点分治和点分树，AcWing 算法进阶课，闫学灿，2020 年 11 月 14 日。 "},{"title":"洛谷 - P5596 题","date":"2022-05-23T21:26:36.000Z","url":"/luogu-p5596/","tags":["数学","洛谷","推式子"],"categories":["题解"],"content":" 题面 题目描述 小 X 遇到了一道题： 给定自然数 a,b，求满足下列条件的自然数对 (x,y) 的个数： y2−x2=ax+b 他不会，只好求助于精通数学的你。 如果有无限多个自然数对满足条件，那么你只需要输出 inf 即可。 输入格式 一行两个整数 a,b。 输出格式 如果个数有限，一行一个整数，表示个数。 如果个数无限，一行一个字符串 inf。 输入输出样例 样例输入 #1 5 15 样例输出 #1 1 样例解释 #1 (x,y)=(6,9). 样例输入 #2 4 4 样例输出 #2 inf 样例输入 #3 12 6 样例输出 #3 0 样例输入 #4 96 96 样例输出 #4 7 样例输入 #5 10000 9999997 样例输出 #5 6 数据范围与约定 本题采用捆绑测试。 Subtask 1（3 points）：a=b=0。 Subtask 2（6 points）：0≤a,b≤2，不存在无限个数的情况。 Subtask 3（9 points）：0≤a,b≤100，不存在无限个数的情况。 Subtask 4（13 points）：0≤a,b≤103，不存在无限个数的情况。 Subtask 5（14 points）：0≤a≤104，0≤b≤107。 Subtask 6（14 points）：a=0。 Subtask 7（14 points）：b=0。 Subtask 8（27 points）：无特殊限制。 对于 100% 的数据，0≤a≤108，0≤b≤1015。 思路 先观察题目中给出的这个式子： y2−x2=ax+b(1) 对 (1) 式进行移项，得： y2−b=x2+2ax(2) 对 (2) 式右侧配方，得： y2−b=(x+2a​)2−4a2​(3) 将 (3) 式两侧同乘 4，得： 4y2−4b=(2x+a)2−a2(4) 对 (4) 式再次移项，得： a2−4b=(2x+a)2−4y2(5) 展开 (5) 式左侧，得： a2−4b=(2x+a+2y)(2x+a−2y)(6) 由题，显然 2x+a+2y&gt;0，接下来分类讨论： 当 a2−4b&lt;0 时，2x+a−2y&lt;0： 左右同乘 −1，得： 4b−a2=(2y+2x+a)(2y−2x−a)(7) 记 p=2y+2x+a，q=2y−2x−a（0&lt;q&lt;p），显然可以将 4b−a2 分解为两数之积可以得到一组 p,q。又有： p+qp−q​=4y=4x+2a⇒p−q−2a=4x​ 可以枚举 q 再据此计算出 p，进而再计算出 x,y 的取值。 当 a2−4b&gt;0 时，2x+a−2y&gt;0： 记 p=2x+a+2y，q=2x+a−2y（0&lt;q&lt;p），显然可以将 a2−4b 分解为两数之积可以得到一组 p,q。又有： p+qp−q​=4x+2a⇒p+q−2a=4x=4y​ 可以枚举 q 再据此计算出 p，进而再计算出 x,y 的取值。 当 a2−4b=0 时，2x+a−2y=0： 由 a2−4b=0 可知，a 为偶数。可得 x+2a​=y。 显然对于任意一个 x 都有一个与其对应的 y 满足条件。此时有无穷多组解。 代码 #include &lt;cmath&gt; #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; long long a, b, d, m, ans; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; a &gt;&gt; b; d = a * a - b * 4; if (d == 0) &#123; cout &lt;&lt; &quot;inf&quot; &lt;&lt; endl; exit(0); &#125; else if (d &lt; 0) &#123; d *= -1; m = std::sqrt(d); for (long long q = 1; q &lt;= m; q++) &#123; if (d % q == 0) &#123; long long p = d / q; long long x = p - q - 2 * a, y = p + q; if (x % 4 || y % 4) continue; x /= 4, y /= 4; if (x &gt;= 0 &amp;&amp; y &gt;= x) ans++; &#125; &#125; &#125; else &#123; // d &gt; 0 m = std::sqrt(d); for (long long q = 1; q &lt;= m; q++) &#123; if (d % q == 0) &#123; long long p = d / q; long long x = p + q - 2 * a, y = p - q; if (x % 4 || y % 4) continue; x /= 4, y /= 4; if (x &gt;= 0 &amp;&amp; y &gt;= x) ans++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"S2OJ - 1426. 空","date":"2022-05-22T20:33:21.000Z","url":"/s2oj-1426/","tags":["S2OJ","STL"],"categories":["题解"],"content":" 题面 题目描述 Utsuho 有 n 条线段，现在她希望在其中找到两条有公共点的线段，使得它们的异或值最大。 定义线段异或值为它们并的长度减它们交的长度。 输入格式 输入的第一行包括一个正整数 n，表示 Utsuho 的线段的个数。 接下来 n 行每行包括两个正整数 l,r，表示 Utsuho 拥有的线段的左右端点。 输出格式 输出一行一个整数，表示能得到的最大异或值。 输入输出样例 样例输入 #1 3 10 100 1 50 50 100 样例输出 #1 99 样例解释 #1 选择第一条和第二条：99−40=59； 选择第一条和第三条：90−50=40； 选择第二条和第三条：99−0=99。 样例输入 #2 3 1 100 180 200 190 210 样例输出 2 20 数据规模与约定 对于 20% 的数据，满足 l,r,n≤300; 对于 40% 的数据，满足 n≤2×103; 另有 10% 的数据，满足 l=1; 对于 100% 的数据，满足 1≤n≤2×105，1≤l≤r≤108。 思路 算是个优化版的暴力。考场上的思路不是特别清晰，所以前前后后一共搞了一个多小时。这个做法的不如正解的简单明了，但是跑的比正解快，内存占用还比正解小。 同一直线上的两条线段存在一下几种关系： 包含，两者的异或值为 (l2​−l1​)+(r1​−r2​)； 相交，两者的异或值为 (l2​−l1​)+(r2​−r1​)； 相离，此时对最大异或值没有贡献，忽略即可。 接下来可以分类讨论： 对于包含的情况，可以枚举线段 2，然后使用堆维护前面所有线段中长度最长的线段作为线段 1。 对于相交的情况，上方的计算异或值的式子可以改写为 (l2​+r2​)−(l1​+r1​)，那么可以枚举线段 2，并使用堆维护 (l+r) 值最大的线段 1。 可以使用优先队列模拟堆，省去了手写的麻烦。 代码 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;utility&gt; #include &lt;vector&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 2e5 + 5; int n, ans; std::pair&lt;int, int&gt; lines[N]; // 包含 std::priority_queue&lt; std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt;&gt;, auto(*)(std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;)-&gt;bool&gt; q1([](std::pair&lt;int, int&gt; a, std::pair&lt;int, int&gt; b) -&gt; bool &#123; return a.second - a.first &lt; b.second - b.first; &#125;); // 相交 std::priority_queue&lt; std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt;&gt;, auto(*)(std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt;)-&gt;bool&gt; q2([](std::pair&lt;int, int&gt; a, std::pair&lt;int, int&gt; b) -&gt; bool &#123; return a.first + a.second &gt; b.first + b.second; &#125;); int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; lines[i].first &gt;&gt; lines[i].second; &#125; std::sort(lines + 1, lines + 1 + n); q1.push(lines[1]); q2.push(lines[1]); for (int i = 2; i &lt;= n; i++) &#123; while (!q1.empty() &amp;&amp; lines[i].second &gt;= q1.top().second) q1.pop(); // 剔除已经相交的线段 while (!q2.empty() &amp;&amp; lines[i].first &gt;= q2.top().second) q2.pop(); // 剔除已经相离的线段 if (!q1.empty()) &#123; auto p = q1.top(), q = lines[i]; ans = std::max(ans, (p.second - p.first) - (q.second - q.first)); &#125; if (!q2.empty()) &#123; auto p = q2.top(), q = lines[i]; ans = std::max(ans, (q.second - p.second) + (q.first - p.first)); &#125; q1.push(lines[i]); q2.push(lines[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P2261 余数求和","date":"2022-05-21T21:44:26.000Z","url":"/luogu-p2261/","tags":["数学","洛谷","2007","CQOI","分块"],"categories":["题解"],"content":" 题面 题目描述 给出正整数 n 和 k，请计算： G(n,k)=i=1∑n​kmodi 其中 kmodi 表示 k 除以 i 的余数。 输入格式 输入只有一行两个整数，分别表示 n 和 k。 输出格式 输出一行一个整数表示答案。 输入输出样例 样例输入 #1 10 5 样例输出 #1 29 样例解释 #1 G(10,5)=0+1+2+1+0+5+5+5+5+5=29。 数据范围与约定 对于 30% 的数据，保证 n,k≤103； 对于 60% 的数据，保证 n,k≤106； 对于 100% 的数据，保证 1≤n,k≤109。 思路 ==​i=1∑n​kmodii=1∑n​k−i⌊ik​⌋nk−i=1∑n​i×⌊ik​⌋​ 然后使用整除分块计算。设 t=⌊lk​⌋，若 t=0，则 r=⌊tk​⌋，否则 r=n。将 ans 减去 (l+r)/2×t×(r−l+1)（区间内 i 的平均值 × ⌊lk​⌋ × 区间长度）。 当 t=0 时可知余下部分全为 0，退出循环即可。 代码 #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; long long n, k, ans; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; ans = n * k; for (long long l = 1, r; k / l &amp;&amp; l &lt;= n; l = r + 1) &#123; r = std::min(k / (k / l), n); ans -= (r + l) * (k / l) * (r - l + 1) / 2; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"AtCoder - AGC048B Bracket Score","date":"2022-05-11T21:52:43.000Z","url":"/atcoder-agc048b/","tags":["AtCoder","贪心"],"categories":["题解"],"content":" 题面 题目描述 给定一个偶数 N 和长度为 N 的整数序列 A 和 B。在这里，我们为一个长度为 N 的括号序列 s 定义一个分数： s 的总分是其中每个字符的分数的总和； 第 i 个字符若是 ( 或 )，则分数为 Ai​，否则分数为 Bi​。 请你构造出一个括号序列，使得这个括号序列的分数最大。 输入格式 第一行一个整数 N。 第二行 N 个整数表示 A 序列。 第三行 N 个整数表示 B 序列。 输出格式 一行一个整数，表示最大分数。 数据范围与约定 对于 100% 的数据，2≤N≤105，1≤Ai​,Bi​≤109。 思路 由括号序列的性质得出，一对匹配的括号的间距一定是偶数，即它们两个的位置的奇偶性不同。 还能发现，一旦每个位置上的括号类型（圆/方括号）确定且一对匹配的括号的间距是偶数，一定能找到一种确定括号朝向的方法使得序列合法。 可以使用贪心解决本题。 先钦定全部选择圆括号，然后对于每个位置，计算将它改为方括号对答案的影响。那么可以将改动奇数位置和改动偶数位置对答案的影响分别放入两个堆中，每次分别取出两个堆的堆顶，将对应的位置改为方括号，直到再取堆顶答案不会更优为止。 代码 #include &lt;iostream&gt; #include &lt;queue&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5; int n, a[N], b[N]; long long ans; std::priority_queue&lt;int&gt; q1, q2; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; ans += a[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b[i]; (!(i &amp; 1) ? q1 : q2).push(b[i] - a[i]); &#125; while (!q1.empty()) &#123; int t = q1.top() + q2.top(); q1.pop(), q2.pop(); if (t &lt;= 0) break; ans += t; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"Codeforces - 1675D. Vertical Paths","date":"2022-05-11T19:11:47.000Z","url":"/codeforces-1675d/","tags":["图论","Codeforces","树"],"categories":["题解"],"content":" 题面 本文中所给出的题面为原题面的中文翻译，并非原始题面。翻译如有错误之处，请联系指出。 题目描述 给定一棵由 n 个顶点组成的有根树。顶点由 1 到 n 编号。任何顶点都可以是树的根。 请在树上找出这样一组路径： 每个顶点恰好属于一条路径，每条路径可以包含一个或多个顶点； 在每条路径中，每个节点的下一个节点是当前节点的子节点（即路径总是向下 —— 从父节点到子节点）； 路径的数量最少。 输入格式 第一行输入一个整数 t 表示该测试点内测试数据的组数。 每组测试点的第 1 行包含一个整数 n 表示树的节点个数。第 2 行包含 n 个整数，第 i 个整数 pi​ 表示第 i 个节点的父节点为 pi​。根节点的父亲是它本身。 输出格式 对于每组测试数据： 第 1 行输出一个整数 m 表示组内路径的数量。 然后输出 m 条路径的信息： 第 1 行输出路径的长度； 第 2 行按照从上到下的顺序输出该路径内的的所有节点编号。 在每组测试数据的末尾输出一个空行。 如果有多种答案，输出其中的任何一种即可。 输入输出样例 输入样例 #1 6 5 3 1 3 3 1 4 1 1 4 1 7 1 1 2 3 4 5 6 1 1 6 4 4 4 4 1 2 4 2 2 2 2 输出样例 #1 3 3 3 1 5 1 2 1 4 2 2 1 2 2 4 3 1 7 1 2 3 4 5 6 7 1 1 1 3 3 4 1 5 2 2 6 1 3 3 2 2 1 1 3 1 4 样例解释 #1 以该测试点中的第一组数据为例，有三条路径： 3→1→5，长度为 3； 4，长度为 1； 2，长度为 1。 数据范围与约定 对于 100% 的数据，1≤t≤104，1≤n≤2×105，1≤pi​≤n。 数据保证每个测试点中的所有测试数据中 n 的总和不超过 2×105。 思路 看到这道题的样例说明之后第一眼想到的是树链剖分（图源 OI Wiki）： 按照这样剖出来的答案显然是对的。 再看看样例会发现一个很显然的结论：最小路径数一定是叶子节点数。 可以使用深度优先搜索，遇到分叉的时候就新开其他路径，同时挑选一个方向继续当前路径，这样出来的答案一定是最优的。 具体实现可以看代码。 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 2e5 + 5; int t, n, fa[N], root, ans_cnt; std::vector&lt;int&gt; g[N], ans[N]; void dfs(int u, int fa, int cnt) &#123; if (g[u].size() == 1) &#123; // 是否是叶子节点 ans[cnt].push_back(u); return; &#125; ans[cnt].push_back(u); bool f = false; for (int v : g[u]) &#123; if (v == fa) continue; if (!f) &#123; dfs(v, u, cnt); f = true; &#125; else &#123; dfs(v, u, ++ans_cnt); &#125; &#125; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; t; while (t--) &#123; root = 0; ans_cnt = 1; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; fa[i]; if (fa[i] == i) root = i; g[i].push_back(fa[i]); g[fa[i]].push_back(i); &#125; dfs(root, root, 1); for (int i = 1; i &lt;= n; i++) &#123; g[i].clear(); &#125; cout &lt;&lt; ans_cnt &lt;&lt; endl; for (int i = 1; i &lt;= ans_cnt; i++) &#123; cout &lt;&lt; ans[i].size() &lt;&lt; endl; for (int x : ans[i]) &#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; ans[i].clear(); &#125; cout &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"BZOJ - 1013. 球形空间产生器","date":"2022-05-09T16:39:41.000Z","url":"/bzoj-1013/","tags":["数学","BZOJ","JSOI","2008","线性代数","矩阵","高斯消元"],"categories":["题解"],"content":" 题面 题目描述 有一个球形空间产生器能够在 n 维空间中产生一个坚硬的球体。现在，你被困在了这个 n 维球体中，你只知道球面上 n+1 个点的坐标，你需要以最快的速度确定这个 n 维球体的球心坐标，以便于摧毁这个球形空间产生器。 输入格式 第一行是一个整数 n。接下来的 n+1 行，每行有 n 个实数，表示球面上一点的 n 维坐标。每一个实数精确到小数点后 6 位，且其绝对值都不超过 20000。 输出格式 有且只有一行，依次给出球心的 n 维坐标（ n 个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后 3 位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。 输入输出样例 样例输入 #1 2 0.0 0.0 -1.0 1.0 1.0 0.0 样例输出 #1 0.500 1.500 数据范围与约定 对于 100% 的数据，1≤n≤10。 提示 给出两个定义： 球心：到球面上任意一点距离都相等的点。 距离：设两个 n 维空间上的点 A,B 的坐标为 (a1​,a2​,⋯,an​),(b1​,b2​,⋯,bn​)，则 AB 之间的距离定义为：dist=∑i=1n​(ai​−bi​)2​。 思路 设球的半径为 R，球心坐标为 (x1​,x2,…,xn​)。那么根据球体的性质，显然有： j=0∑n​(ai,j​−xj​)2=R2 那么展开来写可以得到一个方程组的形式： ⎩⎨⎧​(a1,1​−x1​)2+(a1,2​−x2​)2+⋯+(a1,n​−xn​)2(a2,1​−x1​)2+(a2,2​−x2​)2+⋯+(a2,n​−xn​)2⋮(an+1,1​−x1​)2+(an+1,2​−x2​)2+⋯+(an+1,n​−xn​)2​=R2=R2=R2​​ 但这个方程组是由 n+1 个 n 元二次方程构成的，不是线性方程组。本着「出题人绝对不会多给 1 Byte 有用数据」的原则，我们可以察觉到 n+1 中的异样之处。通过将相邻两个方程作差, 得到的结果是： ⎩⎨⎧​2(a2,1​−a1,1​)x1​+2(a2,2​−a1,2​)x2​+⋯+2(a2,n​−a1,n​)xn​2(a3,1​−a2,1​)x1​+2(a3,2​−a2,2​)x2​+⋯+2(a3,n​−a2,n​)xn​⋮2(an+1,1​−an,1​)x1​+2(an+1,2​−an,2​)x2​+⋯+2(an+1,n​−an,n​)xn​​=a2,12​+a2,22​+⋯+a2,n2​−a1,12​−a1,22​−⋯−a1,n2​=a3,12​+a3,22​+⋯+a3,n2​−a2,12​−a2,22​−⋯−a2,n2​=an+1,12​+an+1,22​+⋯+an+1,n2​−an,12​−an,22​−⋯−an,n2​​​ 可以转化成增广矩阵的形式： ⎣⎡​2(a2,1​−a1,1​)2(a3,1​−a2,1​)⋮2(an+1,1​−an,1​)​2(a2,2​−a1,2​)2(a3,2​−a2,2​)⋮2(an+1,2​−an,2​)​⋯⋯⋱⋯​2(a2,n​−a1,n​)2(a3,n​−a2,n​)⋮2(an+1,n​−an,n​)​∑j=1n​(a2,j2​−a1,j2​)∑j=1n​(a3,j2​−a2,j2​)⋮∑j=1n​(an+1,j2​−an,j2​)​⎦⎤​ 对该矩阵进行高斯消元即可。 代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 15; const double eps = 1e-6; int n; double a[N][N], b[N][N]; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n + 1; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; b[i][j] = 2.0 * (a[i][j] - a[i + 1][j]); b[i][n + 1] += std::pow(a[i][j], 2) - std::pow(a[i + 1][j], 2); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; if (std::abs(b[j][i]) &gt; eps) &#123; std::swap(b[i], b[j]); &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (i == j) continue; double x = b[j][i] / b[i][i]; for (int k = i; k &lt;= n + 1; k++) &#123; b[j][k] -= b[i][k] * x; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; b[i][n + 1] / b[i][i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; return 0; &#125; "},{"title":"POJ - 3696. 最幸运的数字","date":"2022-05-08T21:59:17.000Z","url":"/poj-3696/","tags":["数学","数论","同余","POJ","欧拉定理"],"categories":["题解"],"content":" 题面 题目描述 8 是中国的幸运数字，如果一个数字的每一位都由 8 构成则该数字被称作是幸运数字。 现在给定一个正整数 L，请问至少多少个 8 连在一起组成的正整数（即最小幸运数字）是 L 的倍数。 输入格式 输入包含多组测试用例。 每组测试用例占一行，包含一个整数 L。 当输入用例 L=0 时，表示输入终止，该用例无需处理。 输出格式 每组测试用例输出结果占一行。 结果为 Case i: 和一个整数 N，N 代表满足条件的最小幸运数字的位数。 如果满足条件的幸运数字不存在，则 N=0。 输入输出样例 样例输入 #1 8 11 16 0 样例输出 #1 Case 1: 1 Case 2: 2 Case 3: 0 数据范围与约定 对于 100% 的数据，1≤L≤2×109。 思路 x 个 8 连在一起组成的正整数可以表示为 98(10x−1)​，那么题意就转化为了求最小的 x 满足 L ∣ 98(10x−1)​。 设 d=gcd(L,8)，有推论如下： L ∣ 98(10x−1)​⟺9L ∣ 8(10x−1)⟺d9L​ ∣ 10x−1⟺10x≡1(modd9L​) 引理： 若 a,n∈N∗ 互质，则满足 ax≡1(modn) 的最小正整数 x0​ 是 φ(n) 的约数。 由引理得，可以枚举 φ(d9L​) 的所有约数，然后求出 x0​ 的最小值即为答案。 代码 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;limits&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; int t; long long l; long long euler(long long x) &#123; long long r = x; for (long long i = 2; i * i &lt;= x; i++) &#123; if (x % i == 0) &#123; r = r / i * (i - 1); while (x % i == 0) x /= i; &#125; &#125; if (x &gt; 1) r = r / x * (x - 1); return r; &#125; long long binmul(long long a, long long b, long long m) &#123; unsigned long long c = (unsigned long long)a * b - (unsigned long long)((long double)a / m * b + 0.5L) * m; if (c &lt; m) return c; return c + m; &#125; long long binpow(long long a, long long b, long long m) &#123; a %= m; long long res = 1; while (b &gt; 0) &#123; if (b &amp; 1) res = binmul(res, a, m); a = binmul(a, a, m); b &gt;&gt;= 1; &#125; return res; &#125; int main() &#123; std::ios::sync_with_stdio(false); while (cin &gt;&gt; l, l) &#123; long long d = std::__gcd(l, 8ll); long long n = euler(9ll * l / d); long long ans = std::numeric_limits&lt;long long&gt;::max(); for (long long i = 1; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; if (binpow(10, i, 9ll * l / d) == 1) ans = std::min(ans, i); if (binpow(10, n / i, 9ll * l / d) == 1) ans = std::min(ans, n / i); &#125; &#125; cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++t &lt;&lt; &quot;: &quot; &lt;&lt; (ans == std::numeric_limits&lt;long long&gt;::max() ? 0 : ans) &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"高斯消元学习笔记","date":"2022-05-07T21:49:42.000Z","url":"/gauss/","tags":["数学","线性代数","矩阵","高斯消元"],"categories":["笔记"],"content":" 前置知识 矩阵 请参阅《矩阵学习笔记》。 线性方程组的矩阵表示法 线性方程组是由 n 个 m 元一次方程共同构成的。例如，有线性方程组如下： ⎩⎨⎧​x1​+2x2​−x3​2x1​+x2​−3x3​−x1​−x2​+2x3​​=−6=−9=7​​(1) 该方程组的所有系数可以写成一个 n×m 的「系数矩阵」： ⎣⎡​12−1​21−1​−1−32​⎦⎤​ 加上等号右侧的常数项可以写成一个 n×(m+1) 的「增广矩阵」： ⎣⎡​12−1​21−1​−1−32​−6−97​⎦⎤​ 初等行列变换 矩阵的初等行变换包括以下几种操作： 将某一行乘一个非零的数； 交换某两行； 将某行的若干倍加到另一行。 同理，我们也可以定义矩阵的初等列变换。这两种变换统称矩阵的初等行列变换。 高斯消元法 高斯消元是一种通过初等行列变换将增广矩阵变为简化阶梯矩阵的线性方程组求解方法。 引入 使用若干次初等行变换求解上文中提到的方程组 (1)，过程如下： ⇒⇒⇒⇒⇒​⎣⎡​12−1​21−1​−1−32​−6−97​⎦⎤​⎣⎡​10−1​2−3−1​−1−12​−637​⎦⎤​⎣⎡​100​2−31​−1−11​−631​⎦⎤​⎣⎡​100​21−1​−11−1​−613​⎦⎤​⎣⎡​100​210​−112​−616​⎦⎤​⎣⎡​100​210​−111​−613​⎦⎤​​ 最后得到的矩阵被称为「阶梯形矩阵」，它的系数矩阵部分被称为「上三角矩阵」，这个矩阵表达的信息为： ⎣⎡​100​210​−111​−613​⎦⎤​⇒⎩⎨⎧​x1​+2x2​−x3​x2​+x3​x3​​=−6=1=3​​ 再运用加减消元法即可得到每个未知量的解，也可以进一步化简该矩阵： ⇒⇒​⎣⎡​100​210​−111​−613​⎦⎤​⎣⎡​100​210​001​−3−23​⎦⎤​⎣⎡​100​010​001​1−23​⎦⎤​​ 最后得到的矩阵名为「简化阶梯形矩阵」，它的系数矩阵部分是一个 n 阶单位矩阵，也叫做「对角矩阵」。该矩阵直接给出了方程组的解。 基本思想 对于每个未知量 xi​，找到一个 xi​ 的系数非零、但 x1​∼xi−1​ 的系数都是零的方程，然后使用初等行列变换将其他方程组 xi​ 的系数全部消成零，之后再逐一回代求解出所有未知量。 方程组的解 消元后有以下几种情况： 完美阶梯形：存在唯一解； 含有系数全为零、常数不为零的行：无解； 含有系数和常数均为零的行：存在无穷多组解。 算法实现 枚举系数矩阵中的每一列 c： 找到绝对值最大的一行； 将该行移至顶部； 将该行第 1 个非零的数变成 1； 将下方所有行的第 c 列变成 0。 之后再将系数矩阵化为对角矩阵即可求出所有未知量的值。 代码 a 数组中存储了表示线性方程组的增广矩阵。 int gauss() &#123; int c, r; for (c = 1, r = 1; c &lt;= n; c++) &#123; // 找到绝对值最大的一行 int t = r; for (int i = r; i &lt;= n; i++) &#123; if (std::abs(a[i][c]) &gt; std::abs(a[t][c])) t = i; &#125; // 非零 if (std::abs(a[t][c]) &lt; eps) continue; // 将该行移至顶部 for (int i = c; i &lt;= n + 1; i++) &#123; std::swap(a[t][i], a[r][i]); &#125; // 将该行第一个非零的数变成 1 for (int i = n + 1; i &gt;= c; i--) &#123; a[r][i] /= a[r][c]; &#125; // 将下方所有行的第 c 列变成 0 for (int i = r + 1; i &lt;= n; i++) &#123; if (std::abs(a[i][c]) &gt; eps) &#123; // 非零 for (int j = n + 1; j &gt;= c; j--) &#123; a[i][j] -= a[r][j] * a[i][c]; &#125; &#125; &#125; r++; &#125; if (r &lt;= n) &#123; for (int i = r; i &lt;= n; i++) &#123; if (std::abs(a[i][n + 1]) &gt; eps) // 无解 return -1; &#125; // 无穷多组解 return 1; &#125; // 将系数矩阵化为对角矩阵 for (int i = n; i; i--) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; a[i][n + 1] -= a[i][j] * a[j][n + 1]; &#125; &#125; // 有解 return 0; &#125; 当函数返回 0 时方程组有解，返回 -1 时无解，返回 1 时有无穷多组解。 参考资料 6.3.1 高斯消元法，《信息学奥赛之数学一本通》（ISBN 978-7-5641-6576-5，东南大学出版社），林厚从，2019 年 11 月第 9 次修订版。 高斯消元，第四章 数学知识，AcWing 算法基础课，闫学灿，2019 年 7 月 5 日。 0x35 高斯消元和线性空间，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 "},{"title":"POJ - 3090. Visible Lattice Points","date":"2022-05-03T17:19:18.000Z","url":"/poj-3090/","tags":["数学","数论","约数"],"categories":["题解"],"content":" 本题有以下几种解法： 莫比乌斯反演 欧拉反演（本文） 题面 难度：提高+/省选- 题目描述 在一个平面直角坐标系的第一象限内，如果一个点 (x,y) 与原点 (0,0) 的连线中没有通过其他任何点，则称该点在原点处是可见的。 例如，点 (4,2) 就是不可见的，因为它与原点的连线会通过点 (2,1)。 部分可见点与原点的连线如下图所示： 编写一个程序，计算给定整数 N 的情况下，满足 0≤x,y≤N 的可见点 (x,y) 的数量（可见点不包括原点）。 输入格式 第一行包含整数 C，表示共有 C 组测试数据。 每组测试数据占一行，包含一个整数 N。 输出格式 每组测试数据的输出占据一行。 应包括：测试数据的编号（从 1 开始），该组测试数据对应的 N 以及可见点的数量。 同行数据之间用空格隔开。 输入输出样例 样例输入 #1 4 2 4 5 231 样例输出 #1 1 2 5 2 4 13 3 5 21 4 231 32549 数据范围与约定 对于 100% 的数据，1≤N,C≤1000。 思路 分析题目可得，除了 (1,0)、(0,1) 和 (1,1) 三个点，其他点都只能在满足 gcd(x,y)=1 时被看到。 然后还可以发现能看到的点是沿着 (0,0)−(n,n) 这条直线对称的，所以只计算其中一半然后再将答案乘 2 即可。 可以发现满足上述性质的点的数量恰好是 ∑i=2n​φ(i)。 所以最终答案为 3+2×∑i=2n​φ(i)。 代码 #include &lt;iostream&gt; using std::cin; using std::cout; using std::endl; const int N = 1005; int _t, n, phi[N], ans; int main() &#123; // Init for (int i = 2; i &lt;= 1000; i++) &#123; phi[i] = i; &#125; for (int i = 2; i &lt;= 1000; i++) &#123; if (phi[i] == i) &#123; for (int j = i; j &lt;= 1000; j += i) &#123; phi[j] = phi[j] / i * (i - 1); &#125; &#125; &#125; // End: Init cin &gt;&gt; _t; for (int t = 1; t &lt;= _t; t++) &#123; ans = 0; cin &gt;&gt; n; for (int i = 2; i &lt;= n; i++) &#123; ans += phi[i]; &#125; cout &lt;&lt; t &lt;&lt; &#x27; &#x27; &lt;&lt; n &lt;&lt; &#x27; &#x27; &lt;&lt; ans * 2 + 3 &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"矩阵学习笔记","date":"2022-05-02T21:46:16.000Z","url":"/matrix/","tags":["数学","线性代数","矩阵"],"categories":["笔记"],"content":"在数学中，矩阵（Matrix）是一个按照长方阵列排列的实数或复数集合，最早来自于方程组的系数及常数所构成的方阵，是高等代数学中的常见工具。 矩阵 由 n×m 个数 ai,j​ 排成的 n 行 m 列的数表叫做 n 行 m 列的矩阵，简称 n×m 矩阵。记作： A=⎣⎡​a1,1​a2,1​⋮an,1​​a1,2​a2,2​⋮an,2​​⋯⋯⋱⋯​a1,m​a2,m​⋮an,m​​⎦⎤​ 这 n×m 个数称为矩阵 A 的元素，简称为元。数 ai,j​ 位于矩阵 A 的第 i 行第 j 列，称为矩阵 A 的 (i,j) 元。以数 ai,j​ 为 (i,j) 元的矩阵也可记作 [ai,j​] 或 [ai,j​]n×m​。 如果矩阵 A 的元素可以写成只与其行数 i 与列数 j 有关的统一函数 f，那么也可以使用 A=[f(i,j)]n×m​ 作为 A 的简写。 n×m 矩阵 A 也可记作 Anm​。 矩阵的基本运算 矩阵的基本运算包括加法、减法、数乘、转置、共轭等。 加（减）法 对于两个同型（行数、列数均相同）的矩阵 A 和 B，加法就是将对应 (i,j) 元做加法运算。如： [15​11​44​]+[14​25​36​]=[1+15+4​1+21+5​4+34+6​]=[29​36​710​] 减法运算同理。 矩阵的加（减）法运算满足结合律和交换律： A+B(A+B)+C​=B+A=A+(B+C)​ 数乘 矩阵的数乘是指一个数乘以一个矩阵，只需要将这个数乘到矩阵的每个元素上即可。如： 2×[15​11​44​]=[2×12×5​2×12×1​2×42×4​]=[210​22​88​] 矩阵的数乘运算满足结合律和分配律： (λμ)A(λ+μ)Aλ(A+B)​=λ(μA)=λA+μA=λA+λB​ 矩阵的加法、减法和数乘运算合称为矩阵的线性运算。 转置 将矩阵 A 的行换成同序数的列所得到的新矩阵称为 A 的转置矩阵，这一过程称为矩阵的转置，记为 AT。如： [15​11​44​]T=⎣⎡​114​514​⎦⎤​ 矩阵的转置运算满足以下运算律： (AT)T(λA)T(AB)T​=A=λAT=BTAT​ 共轭 对于一个复矩阵，其共轭矩阵定义为 Ai,j​=Ai,j​​。如： A=[3+i2−2i​5i​]​A=[3−i2+2i​5−i​]​ 矩阵的共轭转置定义为 A∗i,j​=Aj,i​​（也可记作 A∗=(A)T=AT）。如： A=[3+i2−2i​5i​]​A∗=[3−i5​2+2i−i​]​ 矩阵乘法 两个矩阵的乘法运算仅当第一个矩阵 A 的列数和第二个矩阵 B 的行数相等时才能定义。如 An×m​,Bm×p​ 的乘积 C 是一个 n×p 矩阵 C=[ci,j​]，它的任意一个元素值为： ci,j​=ai,1​×b1,j​+ai,2​×b2,j​+⋯+ai,m​×bm,j​=k=1∑m​(ai,k​×bk,j​) 将此乘积记为 C=AB。如： ==​[1−1​03​21​]×⎣⎡​321​110​⎦⎤​[(1×3+0×2+2×1)(−1×3+3×2+1×1)​(1×1+0×1+2×0)(−1×1+3×1+1×0)​][54​12​]​ 矩阵乘法满足结合律、左分配律、右分配律，但不满足交换律： (AB)C(A+B)CC(A+B)​=A(BC)=AC+BC=CA+CB​ 单位矩阵 n 阶单位矩阵 In​ 是一个 n×n 的方形矩阵，其主对角线上的所有数为 1，其余数为 0。 I1​=[1​],​I2​=[10​01​],​I3​=⎣⎡​100​010​001​⎦⎤​,​⋯,​In​=⎣⎡​10⋮0​01⋮0​⋯⋯⋱⋯​00⋮1​⎦⎤​​ 单位矩阵有一个特殊性质：任何矩阵乘上这个矩阵都得它本身，即 AI=A。这个性质在进行矩阵快速幂的时候会用到。 矩阵快速幂 矩阵快速幂和一般的快速幂类似，都是通过运用结合律来减少乘法运算的次数来达到提速的目的的。 Ak=⎩⎨⎧​IA×Ak−1A2k÷2​if k=0if kmod2=1if kmod2=0​​ 矩阵加速递推 斐波那契数列 斐波那契数列的递推公式如下： fn​={1fn−1​+fn−2​​if n∈{1,2}if n≥3​ 可以看出 fn​ 和 fn−1​ 是存在一定关系的，可以构造一个多项式来找出关系： fn​fn−1​​=fn−1​+fn−2​=fn−1​​(1) 设 x1​=fn−1​,x2​=fn−2​,y1​=fn​,y2​=fn−1​，则 1 式可化为以下形式： y1​y2​​=x1​+x2​=x1​​(2) 这种齐次线性方程组可以使用 系数矩阵×N 维向量 的形式来表示，即： AX=B 则有： [y1y2​]=[11​10​][x1x2​](3) 设 F(n)=[fn​fn−1​​]，由 3 式得： F(n)=[11​10​]n−1[f1​f0​​](4) 这样就将本节刚开始的递推式转换成了一个求解矩阵幂运算的通项公式，使用上一节中提到的矩阵快速幂的知识即可将复杂度优化到 log 级别。 推广 例题：P1939 【模板】矩阵加速（数列） 由题可得该数列的递推公式： fn​={1fn−1​+fn−3​​if n∈{1,2,3}if n≥4​ 与上题相同，可以构造一组多项式来找出关系： fn​fn−1​fn−2​fn−3​​=fn−1​+fn−3​=fn−1​=fn−2​=fn−3​​(1) 设 x1​=fn−1​,x2​=fn−2​,x3​=fn−3​,x4​=fn−4​,y1​=fn​,y2​=fn−1​,y3=fn−2​,y4=fn−3​，则 1 式可化为以下形式： y1​y2​y3​y4​​=x1​+x3​=x1​=x2​=x3​​(2) 用 系数矩阵×N 维向量 的形式来表示，有： ⎣⎡​y1​y2​y3​y4​​⎦⎤​=⎣⎡​1100​0010​1001​0000​⎦⎤​⎣⎡​x1​x2​x3​x4​​⎦⎤​(3) 从 3 式可以看出，x4​ 的系数恒为 0，可以化简为： ⎣⎡​y1​y2​y3​​⎦⎤​=⎣⎡​110​001​100​⎦⎤​⎣⎡​x1​x2​x3​​⎦⎤​(4) 设 F(n)=⎣⎡​fn​fn−1​fn−2​​⎦⎤​，由 4 式得： F(n)=⎣⎡​110​001​100​⎦⎤​n−1⎣⎡​f3​f2​f1​​⎦⎤​ 参照此种方法，就可以使用矩阵加速递推了。 参考资料 6.1 矩阵及其运算，《信息学奥赛之数学一本通》（ISBN 978-7-5641-6576-5，东南大学出版社），林厚从，2019 年 11 月第 9 次修订版。 矩阵，OI Wiki，2022 年 2 月 13 日。 矩阵快速幂，一瓜算法小册，2020 年 2 月 18 日。 "},{"title":"POJ - 1006. 生理周期","date":"2022-05-02T10:16:09.000Z","url":"/poj-1006/","tags":["数学","数论","同余","中国剩余定理","POJ"],"categories":["题解"],"content":" 题面 题目描述 人生来就有三个生理周期，分别为体力、感情和智力周期，它们的周期长度为 23 天、28 天和 33 天。每一个周期中有一天是高峰。在高峰这天，人会在相应的方面表现出色。例如，智力周期的高峰，人会思维敏捷，精力容易高度集中。因为三个周期的周长不同，所以通常三个周期的高峰不会落在同一天。对于每个人，我们想知道何时三个高峰落在同一天。对于每个周期，我们会给出从当前年份的第一天开始，到出现高峰的天数（不一定是第一次高峰出现的时间）。你的任务是给定一个从当年第一天开始数的天数，输出从给定时间开始（不包括给定时间）下一次三个高峰落在同一天的时间（距给定时间的天数）。例如：给定时间为 10，下次出现三个高峰同天的时间是 12，则输出 2（注意这里不是 3）。 输入格式 输入四个整数：p,e,i,d。 p,e,i 分别表示体力、情感和智力高峰出现的时间（时间从当年的第一天开始计算）。d 是给定的时间，可能小于 p,e,i。 所有给定时间是非负的并且小于 365，所求的时间小于 21252。 当 p=e=i=d=−1 时，输入数据结束。 输出格式 从给定时间起，下一次三个高峰同天的时间（距离给定时间的天数）。 采用以下格式： Case &#123;&#125;: the next triple peak occurs in &#123;&#125; days. 注意：即使结果是 1 天，也使用复数形式 days。 输入输出样例 样例输入 #1 0 0 0 0 0 0 0 100 5 20 34 325 4 5 6 7 283 102 23 320 203 301 203 40 -1 -1 -1 -1 样例输出 #1 Case 1: the next triple peak occurs in 21252 days. Case 2: the next triple peak occurs in 21152 days. Case 3: the next triple peak occurs in 19575 days. Case 4: the next triple peak occurs in 16994 days. Case 5: the next triple peak occurs in 8910 days. Case 6: the next triple peak occurs in 10789 days. 思路 设 s 表示三个峰值同时出现的那一天，T 为周期，有： s=p+Tp​kp​=e+Te​ke​=i+Ti​ki​(1) 显然需要求出 kp​,ke​,ki​ 使 (1) 式成立，但题目只需要求出 S 的值，所以可以换一个角度入手。可以将 (1) 式转化为： ⎩⎨⎧​s≡ps≡es≡i​(mod 23)(mod 28)(mod 33)​ 这样就可以使用中国剩余定理来解决问题了： 令 (28×33×a)≡1 (mod 23)，解得 a=6，则 28×33×a=5544。 令 (23×33×b)≡1 (mod 28)，解得 b=19，则 23×33×b=14421。 令 (23×28×c)≡1 (mod 33)，解得 c=2，则 23×28×c=1288。 故 s=5544×p+14421×e+1288×i，则最终结果为 s−d。 代码 #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; int t, p, e, i, d; int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a; &#125; int lcm(int a, int b) &#123; return a / gcd(a, b) * b; &#125; int main() &#123; std::ios::sync_with_stdio(false); while (cin &gt;&gt; p &gt;&gt; e &gt;&gt; i &gt;&gt; d, ~p &amp;&amp; ~e &amp;&amp; ~i &amp;&amp; ~d) &#123; int l = 21252, ans = (5544 * p + 14421 * e + 1288 * i - d + l) % l; cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++t &lt;&lt; &quot;: the next triple peak occurs in &quot; &lt;&lt; (ans ? ans : l) &lt;&lt; &quot; days.&quot; &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"中国剩余定理学习笔记","date":"2022-04-24T21:34:49.000Z","url":"/crt/","tags":["数学","数论","同余","中国剩余定理"],"categories":["笔记"],"content":" 前置知识 扩展欧几里得算法 线性同余方程 中国剩余定理 中国剩余定理（Chinese Remainder Theorem，CRT）可求解如下形式的一元线性同余方程组（其中 n1​,n2​,⋯,nk​ 两两互质）： ⎩⎨⎧​x≡a1​x≡a2​…x≡ak​​(modn1​)(modn2​)(modnk​)​​ 算法流程 计算所有模数的积 n； 对于第 i 个方程： 计算 mi​=ni​n​； 计算 mi​ 在模 ni​ 意义下的 逆元 mi−1​； 第 i 个方程的解 ci​=mi​×mi−1​（不要对 ni​ 取模）。 求出方程组的唯一解 x=∑i=1k​ai​mi​ci​(modn)。 代码实现 long long CRT() &#123; long long mod = 1, ans = 0; for (int i = 1; i &lt;= n; i++) &#123; mod *= n[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; long long m = mod / n[i], x, y; exgcd(m, n[i], x, y); ans = (ans + a[i] * m * x % mod) % mod; &#125; return (ans % mod + mod) % mod; &#125; 证明 因为 mi​=ni​n​ 是除 mi​ 之外所有模数的倍数，所以 ∀k=i,ai​mi​ci​≡0(modmk​)。又因为 ai​mi​ci​≡ai​(modmi​)，所以代入 x=∑i=1n​ai​mi​ci​，原方程组成立。 证毕。 参考资料 第 154 ~ 155 页，0x33 同余，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 1.5 中国剩余定理，《信息学奥赛之数学一本通》（ISBN 978-7-5641-6576-5，东南大学出版社），林厚从，2019 年 11 月第 9 次修订版。 中国剩余定理，OI Wiki，2022 年 3 月 27 日。 "},{"title":"扩展欧几里得算法学习笔记","date":"2022-04-23T20:25:05.000Z","url":"/exgcd/","tags":["数学","数论","扩展欧几里得算法","逆元"],"categories":["笔记"],"content":" 相关定理 欧几里得算法 ∀a,b∈N,b=0,gcd(a,b)=gcd(b,amodb)​ Bézout 定理 对于任意整数 a,b，存在一对整数 x,y 满足 ax+by=gcd(a,b)。 扩展欧几里得算法 扩展欧几里得算法是用来求二元一次不定方程（如 (1) 式）的一组特解的算法。 ax+by=c(1) (1) 式有解当且仅当 gcd(a,b) ∣ c。 实现 对于每次递归， 当 b=0 时， ax+by=a，故 x=1,y=0。 当 b=0 时， x=x,y=y−⌊ba​⌋x。 证明： 设 d=gcd(a,b)，由欧几里得算法得： d​=ax+by=by+(amodb)x=by+(a−⌊ba​⌋b)x=ax+b(y−⌊ba​⌋x)​ 则上述 b=0 情况中的式子成立。 证毕。 代码 int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int g = exgcd(b, a % b, y, x); y -= a / b * x; return g; &#125; 通解 求出特解 x0​,y0​ 后补齐次项即可： x=x0​+bky=y0​−ak​ 方程的最小整数解的 k=b/gcd(a,b)，x=(xmodk+k)modk。 逆元 若 ax≡1 (mod b)，且 a,b 互质，则称 x 为 a 的逆元，记为 a−1。 可将上式转化为： ax+by=1(2) 这样可以就使用扩展欧几里得算法求出 (2) 式的解，x 的最小解即为 a 的逆元。 参考资料 第 150 ~ 151 页，0x33 同余，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 1.3.4 扩展欧几里得算法，《信息学奥赛之数学一本通》（ISBN 978-7-5641-6576-5，东南大学出版社），林厚从，2019 年 11 月第 9 次修订版。 1.4 逆元，《信息学奥赛之数学一本通》（ISBN 978-7-5641-6576-5，东南大学出版社），林厚从，2019 年 11 月第 9 次修订版。 2022-05-06: 感谢 iBug 指出本文中的错误。 "},{"title":"洛谷 - P1516 青蛙的约会","date":"2022-04-22T11:27:01.000Z","url":"/luogu-p1516/","tags":["数学","洛谷","同余","扩展欧几里得算法","线性同余方程"],"categories":["题解"],"content":" 题面 题目描述 两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。 我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 0 度处为原点，由东往西为正方向，单位长度 1 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 x，青蛙 B 的出发点坐标是 y。青蛙 A 一次能跳 m 米，青蛙 B 一次能跳 n 米，两只青蛙跳一次所花费的时间相同。纬度线总长 L 米。现在要你求出它们跳了几次以后才会碰面。 输入格式 输入只包括一行五个整数 x,y,m,n,L。 输出格式 输出碰面所需要的天数，如果永远不可能碰面则输出一行一个字符串 Impossible。 输入输出样例 样例输入 #1 1 2 3 4 5 样例输出 #1 4 数据范围与约定 对于 100% 的数据，1≤x=y≤2×109，1≤m,n≤2×109，1≤L≤2.1×109。 思路 设 k∈N 表示走了多少天，有方程如下： x+km≡y+kn (modL)(1) 设 p∈N∗ 表示青蛙 A 跳的圈数和青蛙 B 的圈数之差。由 (1) 式可得： (x+km)−(y+kn)=pL(2) 可以转化为： x−y+k(m−n)=pL(3) 移项，得： k(m−n)−pL=−(x−y)(4) 设 c=x−y，b=n−m（此处有变号），可得： kb+pL=c(5) 使 (5) 成立的最小的 c 为 gcd(b,l)，所以当 gcd(b,l) ∣ c 时本题有解，求出 (5) 中 k 的最小值即可。 代码 #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; long long x, y, n, m, l; long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; long long g = exgcd(b, a % b, x, y); long long t = x; x = y; y = t - a / b * y; return g; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; x &gt;&gt; y &gt;&gt; m &gt;&gt; n &gt;&gt; l; long long b = n - m, c = x - y, xx, yy; if (b &lt; 0) &#123; b = -b; c = -c; &#125; long long g = exgcd(b, l, xx, yy); if (c % g) &#123; cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; (c / g * xx % (l / g) + (l / g)) % (l / g) &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"「省选联考 2022 Day1」预处理器","date":"2022-04-17T21:44:39.000Z","url":"/luogu-p8289/","tags":["洛谷","LibreOJ","模拟","2022","省选"],"categories":["题解"],"content":" 题面 题目描述 宏是 C/C++ 语言的一项特性，它根据预先定义的规则进行文本替换（也被称为 “宏展开”），能够实现定义常量、简化代码重复输入等功能。例如： #define PI 3.14159 double area = PI * r * r; 以上代码经过宏展开后变为： double area = 3.14159 * r * r; 其中，宏定义命令变成了空行，而其他行中的宏被展开成了规则定义的文本。 C/C++ 语言代码在编译时对宏的处理由预处理器完成。你的任务是实现一个简化版的预处理器，要求如下： 代码由行组成，每行除行末的换行符外，均由可打印 ASCII 字符（ASCII 码范围 32∼126）组成。每行要么是 预处理命令（以 # 开头），要么是 普通文本（其他情况）。 预处理器逐行处理代码， 如果是预处理命令，执行该命令，并输出一个空行。 如果是普通文本，对其进行宏展开并输出结果。 预处理命令有两种，分别是宏定义命令 #define 和取消宏定义命令 #undef。 宏定义命令的格式为 #define &lt;name&gt; &lt;content&gt;，其中第一部分 #define 是命令名，第二部分 &lt;name&gt; 是要定义的宏的名字，第三部分 &lt;content&gt; 是要定义的宏的展开内容。 取消宏定义命令的格式为 #undef &lt;name&gt;，其中第一部分 #undef 是命令名，第二部分 &lt;name&gt; 是要取消的宏的名字。 以上两种预处理命令中，相邻两部分之间都严格用一个空格分隔。&lt;name&gt; 是由大小写字母和数字以及下划线组成的标识符（一个或多个字符），&lt;content&gt; 可以包含任意可打印 ASCII 字符（零个或多个字符）。一个宏定义的有效范围是从它定义所在行开始到后续最近的宏名匹配的取消定义所在行为止（如果没有对应的取消定义，则有效范围一直覆盖到文件结束）。 对普通文本进行宏展开时，将一行文本中每段连续极长的大小写字母和数字以及下划线视为标识符（而不是其中一部分），其余为其他字符。从左到右依次对文本中的标识符进行宏展开： 如果该标识符是有效的宏名，则用对应的展开内容替换它，此时该宏名进入正在展开的状态，直到本流程结束；否则原样保留宏名。例如，若宏 A 定义为 b，则文本 A 展开结果为 b（发生替换），文本 B 展开结果仍然为 B（未定义，不替换），文本 AA 展开结果仍然为 AA（AA 是不同于 A 的另一个标识符，未定义），而文本 A*B 展开结果为 b*B。 替换发生后，如果展开内容中包含标识符，重复应用以上的展开操作，称为 “多次展开”。例如，若宏 A 定义为 B，宏 B 定义为 c，则文本 A 的展开结果为 c。 如果待展开的宏名与正在进行展开的某个宏名相同，称为 “递归展开”，此时该宏名不再展开。本规则用来防止无限递归展开。例如，若宏 A 定义为 B+a，宏 B 定义为 A+b，则文本 A 展开结果为 A+b+a，由于最初的 A 处于正在展开状态，因此 A+b+a 里的 A 不再展开。 其他字符原样保留。 注意：出于简化的目的，本题的要求与 C/C++ 语言标准里的描述不完全一致，请以上面的要求为准。最明显的区别是本题只有标识符和其他字符两类词法单元，没有数值、字符串、注释等。 输入格式 输入的第一行包含一个正整数 n，表示要处理的代码行数。 接下来的 n 行是要处理的代码。 输出格式 输出 n 行，为输入逐行预处理后的结果。 输入输出样例 输入样例 #1 5 #define BEGIN &#123; #define END &#125; #define INTEGER int class C BEGIN INTEGER x; END; INTEGER main() BEGIN C c; END 样例输出 #1 class C &#123; int x; &#125;; int main() &#123; C c; &#125; 样例输入 #2 见附件中的 preprocessor/preprocessor2.in。 样例输入 #2 见附件中的 preprocessor/preprocessor2.ans。 样例输入 #3 见附件中的 preprocessor/preprocessor3.in。 样例输入 #3 见附件中的 preprocessor/preprocessor3.ans。 数据范围与约定 【数据范围】 对 20% 的数据，不会出现宏定义命令 #define 和宏取消定义命令 #undef。 对另外 20% 的数据，不会出现多次展开的情况，且不会出现宏取消定义命令 #undef。 对另外 20% 的数据，不会出现多次展开的情况。 对另外 20% 的数据，不会出现递归展开的情况。 对其余数据，无特殊限制。 对 100% 的数据，n≤100，输入的每行字符数都不超过 100，且保证输出的每行字符数都不超过 1000（字符数均不计行末换行符）。保证输入数据中的预处理命令都是合法的，包含但不限于： # 字符只会出现在预处理命令所在行的第一个字符的位置，其他任何位置（包括预处理命令和普通文本）都不会出现 # 字符。 宏定义和取消定义命令的格式是正确的，严格遵循题面所描述的格式。 同一个宏在取消定义之前不会被再次定义。 要取消定义的宏在之前被定义过且还没有被取消过。 也就是说，你不需要做任何语法和语义的错误检查。 【提示】 本题进行输入时建议使用 C++ 语言的按行读入字符串功能，示例如下： #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; string line; // 从 cin 读入一行，放入 line 中（换行符被舍弃） getline(cin, line); 也可以使用 C 语言提供的 fgets 函数，示例如下： #include &lt;stdio.h&gt; #define MAX_LEN 200 char line[MAX_LEN]; // 从 stdin 读入一行，放入 line 中（包含换行符） fgets(line, MAX_LEN, stdin); 注意：在读取行数 n 之后可能需要额外读取一行以忽略其后的换行符。 思路 这是一道不大不小的模拟题，有一些注意事项： 判断有效的宏名（正则：[A-Za-z0-9_]+）比判断分隔符要容易实现。 题目有要求不能展开无限递归的宏，需要打标记记录一下。 STL 是个好东西。 题外话：我在省选前不久碰见了一个短小精悍的 C 语言编译器，而里面正好有预处理相关的代码：preprocess.c at rui314/chibicc@90d1f7f。可惜的是，这么长的代码我记不住，而且过于工程化，没有必要在考场上写这种东西。不过这个编译器和我曾经用到的 PurgeCSS 库为我提供了一些思路和实现上的点拨，使得我能在考场上切掉这道题，写出来的代码也不至于特别冗长。 STL 相关 一个非常好用的 C++ 参考手册（中文）：zh.cppreference.com。 在考场上如果不知道怎么用 STL 可以去翻头文件中的注释（英文），里面有简单的说明。 std::string 入门 声明一个 std::string 类型的变量 s： std::string s = &quot;abcdef&quot;; 获取字符串长度： s.size(); // 6 判空： s.empty(); // false 截取子串： s.substr(1, 3); // s 中从 1 开始长度为 3 的子串 // &quot;bcd&quot; 查找字串： s.find(&quot;cde&quot;, 1); // s 中从下标为 1 的位置开始查找字串 &quot;cde&quot; // 2 同样地，也可以查找某个字符出现的位置： s.find(&#x27;c&#x27;); // s 中第一次出现的 &#x27;c&#x27; // 2 STL 也提供了其他查找函数： find_first_of：查找字符串中第一个包含指定字符的位置。 find_last_of：查找字符串中最后一个包含指定字符的位置。 find_first_not_of：查找字符串中第一个不包含指定字符的位置。 find_last_not_of：查找字符串中最后一个不包含指定字符的位置。 使用方法与上面的 find 函数类似，不再过多赘述。 清空字符串： s.clear(); std::unordered_map 入门 std::unordered_map 在 C++11 中被引入，由于其基于哈希的实现导致了在大多数情况下 std::unordered_map 比 std::map 要快。 声明一个 std::unordered_map&lt;std::string, int&gt; 类型的变量 map： std::unordered_map&lt;std::string, int&gt; map; 插入元素： map[&quot;a&quot;] = 1; map.insert(std::make_pair(&quot;b&quot;, 2)); // pair 的 first 键值为 key，second 键值为 value map[&quot;c&quot;] = -1; 查找元素： map.find(&quot;c&quot;); // 返回迭代器 map.count(&quot;c&quot;); // 返回元素个数（1 或 0） 删除迭代器 it 指向的元素： auto it = map.find(&quot;c&quot;); map.erase(it); 删除键为 c 的元素： map.erase(&quot;c&quot;); 获取元素个数： map.size(); // 2 判空： map.empty(); // false 访问元素： map[&quot;a&quot;]; // 1 使用下标访问时如果元素不存在会自动新建，所以建议访问前先使用 map.count() 判断是否存在该元素。 清空整个容器： map.clear(); 代码 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; // 题目限制 const int N = 105; // 代码行数 int n; // 原始字符串 std::string s[N]; // 宏列表： &lt;宏名, &lt;内容, 正在展开&gt;&gt; std::unordered_map&lt;std::string, std::pair&lt;std::string, bool&gt;&gt; def; /** * 递归展开 * @param s 原始字符串 * @return 展开后的字符串 */ std::string dfs(std::string s) &#123; std::string r; for (int i = 0, j; i &lt; s.size(); i += j) &#123; for (j = 0; i + j &lt; s.size() &amp;&amp; // 防止越界 (&#x27;0&#x27; &lt;= s[i + j] &amp;&amp; s[i + j] &lt;= &#x27;9&#x27; || // 数字 &#x27;a&#x27; &lt;= s[i + j] &amp;&amp; s[i + j] &lt;= &#x27;z&#x27; || // 小写字母 &#x27;A&#x27; &lt;= s[i + j] &amp;&amp; s[i + j] &lt;= &#x27;Z&#x27; || // 大写字母 s[i + j] == &#x27;_&#x27;); // 下划线 j++) ; // 匹配合法宏名 if (j) &#123; std::string tmp = s.substr(i, j); // 截取从 i 开始的 j 个字符 if (def.count(tmp) &amp;&amp; !def[tmp].second) &#123; // 该宏存在且未处在展开状态 def[tmp].second = true; // 将该宏标记为正在展开 r += dfs(def[tmp].first); // 递归展开 def[tmp].second = false; // 取消标记 &#125; else &#123; r += tmp; // 不存在直接按原样加入到结果中 &#125; &#125; else &#123; r += s[i++]; // 不合法，直接略过，加入到结果中 &#125; &#125; return r; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n; // 第 0 行读入 n 后尾随的换行符 for (int i = 0; i &lt;= n; i++) &#123; std::getline(cin, s[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (s[i][0] == &#x27;#&#x27;) &#123; // 预处理命令 if (s[i].substr(1, 6) == &quot;define&quot;) &#123; int p = s[i].find_first_of(&#x27; &#x27;, 8); // 宏名后的空格位置 std::string name = s[i].substr(8, p - 8), content = s[i].substr(p + 1); // 插入内容 def[name] = std::make_pair(content, false); &#125; else &#123; // s[i].substr(1, 6) == &quot;undef&quot; std::string name = s[i].substr(7); def.erase(name); &#125; cout &lt;&lt; endl; &#125; else &#123; // 普通文本 cout &lt;&lt; dfs(s[i]) &lt;&lt; endl; &#125; &#125; return 0; &#125; "},{"title":"洛谷 - P1541 乌龟棋","date":"2022-03-29T21:16:32.000Z","url":"/luogu-p1541/","tags":["动态规划","洛谷","NOIP","2010","线性 DP","多维 DP"],"categories":["题解"],"content":" 题面 题目背景 小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。 题目描述 乌龟棋的棋盘是一行 N 个格子，每个格子上一个分数（非负整数）。棋盘第 1 格是唯一的起点，第 N 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。 乌龟棋中 M 张爬行卡片，分成 4 种不同的类型（M 张卡片中不一定包含所有 4 种类型的卡片，见样例），每种类型的卡片上分别标有 1,2,3,4 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。 游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。 很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。 现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？ 输入格式 每行中两个数之间用一个空格隔开。 第 1 行 2 个正整数 N,M，分别表示棋盘格子数和爬行卡片数。 第 2 行 N 个非负整数，a1​,a2​,…,aN​，其中 ai​ 表示棋盘第 i 个格子上的分数。 第 3 行 M 个整数，b1​,b2​,…,bM​，表示 M 张爬行卡片上的数字。 输入数据保证到达终点时刚好用光 M 张爬行卡片。 输出格式 1 个整数，表示小明最多能得到的分数。 输入输出样例 输入样例 #1 9 5 6 10 14 2 8 8 18 5 17 1 3 1 2 1 输出样例 #1 73 样例解释 #1 思路 多维 DP 经典题。 可以考虑设置 4 个维度，每个维度分别记录 1,2,3,4 号卡片的状态，而当前所在的格就是 ai+2j+3k+4l​。 得转移方程如下： ​fi,j,k,l​=max(fi,j,k,l​,fi−1,j,k,l​)+ai+2j+3k+4l​fi,j,k,l​=max(fi,j,k,l​,fi,j−1,k,l​)+ai+2j+3k+4l​fi,j,k,l​=max(fi,j,k,l​,fi,j,k−1,l​)+ai+2j+3k+4l​fi,j,k,l​=max(fi,j,k,l​,fi,j,k,l−1​)+ai+2j+3k+4l​​(i&gt;0)(j&gt;0)(k&gt;0)(l&gt;0)​ 其中 i∈[0,b1​],j∈[0,b2​],k∈[0,b3​],l∈[0,b4​]。 代码 #include &lt;algorithm&gt; #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 355, M = 125; int n, m, a[N], b[5], f[M][M][M][M]; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1, x; i &lt;= m; i++) &#123; cin &gt;&gt; x; b[x]++; &#125; f[0][0][0][0] = a[1]; for (int i = 0; i &lt;= b[1]; i++) &#123; for (int j = 0; j &lt;= b[2]; j++) &#123; for (int k = 0; k &lt;= b[3]; k++) &#123; for (int l = 0; l &lt;= b[4]; l++) &#123; f[i][j][k][l] = std::max(&#123;i ? f[i - 1][j][k][l] : 0, j ? f[i][j - 1][k][l] : 0, k ? f[i][j][k - 1][l] : 0, l ? f[i][j][k][l - 1] : 0&#125;) + a[1 + i + j * 2 + k * 3 + l * 4]; &#125; &#125; &#125; &#125; cout &lt;&lt; f[b[1]][b[2]][b[3]][b[4]] &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P2389 电脑班的裁员","date":"2022-03-23T17:06:06.000Z","url":"/luogu-p2389/","tags":["动态规划","洛谷"],"categories":["题解"],"content":" 题面 题目背景 隔壁的新初一电脑班刚考过一场试，又到了 BlingBling 的裁员时间，老师把这项工作交给了 ZZY 来进行。而 ZZY 最近忙着刷题，就把这重要的任务交（tui）给了你。 题目描述 ZZY 有独特的裁员技巧：每个同学都有一个考试得分 ai​，在 n 个同学中选出不大于 k 段相邻的同学留下，裁掉未被选中的同学，使剩下同学的得分和最大。要特别注意的是，这次考试答错要扣分，所以得分有可能为负。 输入格式 第一行为 n,k，第二行为第 1∼n 位同学的得分。 输出格式 一个数 s，为最大得分和。 输入输出样例 输入样例 #1 5 3 1 -1 1 -1 1 输出样例 #1 3 数据范围与约定 对于 100% 的数据，k≤n≤500，∣ai​∣≤103。 思路 动态规划，时间复杂度 O(n3)。 设 fi,j​ 表示前 i 个数取 j 段的最大价值。 若不选 ai​ 则 fi,j​=fi−1,j​； 若选择 ai​ 则需要枚举最后一段的起始位置 l：fi,j​=fl,j−1​+∑p=li​ap​(l∈[j−1,i])。 整理得转移方程： fi,j​=max{fi,j​,fi−1,j​,fl,j−1​+p=l+1∑i​ap​} 代码 #include &lt;algorithm&gt; #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 505; int n, k, sum[N], f[N][N]; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; sum[i] = sum[i - 1] + x; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; for (int l = j - 1; l &lt;= i; l++) &#123; f[i][j] = std::max(&#123;f[i][j], f[i - 1][j], f[l][j - 1] + (sum[i] - sum[l])&#125;); &#125; &#125; &#125; cout &lt;&lt; f[n][k] &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P2045 方格取数加强版","date":"2022-03-22T13:27:06.000Z","url":"/luogu-p2045/","tags":["洛谷","网络流","费用流"],"categories":["题解"],"content":" 题面 题目描述 给出一个 n×n 的矩阵，每一格有一个非负整数 Ai,j​ 现在从 (1,1) 出发，可以往右或者往下走，最后到达 (n,n)。每到达一格，把该格的数取出并将原位置归 0，这样一共走 k 次，请你求出走 k 次所达到的方格的数的和的最大值。 输入格式 第一行两个数 n,k。 接下来 n 行，每行 n 个数，分别表示矩阵上的每个格子中的数。 输出格式 走 k 次所达到的方格的数的和的最大值。 输入输出样例 输入样例 #1 3 1 1 2 3 0 2 1 1 4 2 输出样例 #1 11 数据范围与约定 对于 100% 的数据，1≤n≤50，0≤k≤10，0≤Ai,j​≤1000。 思路 按照网格建立网络，将每个点拆成入点和出点两个点，入点向出点连两条边：一条 flow=1,cost=−val 表示第一次经过（负数是为了把最大费用最大流转化为最小费用最大流），另一条 flow=inf,cost=0 供后几次经过使用。每个点的出点向右方和下方连 flow=inf,cost=0 的边。之后将从超级源点向 (1,1)、从 (n,n) 向超级汇点分别连两条 flow=k,cost=0 的边，再求出最小费用最大流即可。 最后输出答案时别忘了将负数再转回正数。 代码 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;queue&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 5005, M = 100005, INF = 0x3f3f3f3f; int n, k, s, t, ans; // Graph int idx, head[N], ver[M &lt;&lt; 1], next[M &lt;&lt; 1]; std::pair&lt;int, int&gt; edge[M &lt;&lt; 1]; // &lt;flow, cost&gt; void add(int u, int v, int flow, int cost) &#123; next[idx] = head[u]; ver[idx] = v; edge[idx] = std::make_pair(flow, cost); head[u] = idx++; &#125; inline int id(int i, int j, int k = 0) &#123; return (i - 1) * n + j + k * n * n; &#125; // Dinic int dist[N]; bool vis[N]; bool spfa() &#123; memset(vis, 0x00, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); std::queue&lt;int&gt; q; q.push(s); dist[s] = 0; vis[s] = true; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; ~i; i = next[i]) &#123; int v = ver[i], c = edge[i].first, w = edge[i].second; if (c &gt; 0 &amp;&amp; dist[v] &gt; dist[u] + w) &#123; dist[v] = dist[u] + w; if (!vis[v]) &#123; q.push(v); vis[v] = true; &#125; &#125; &#125; &#125; return dist[t] != INF; &#125; int dinic(int u, int limit) &#123; if (u == t) return limit; int flow = 0; vis[u] = true; for (int i = head[u]; ~i &amp;&amp; flow &lt; limit; i = next[i]) &#123; int v = ver[i], c = edge[i].first, w = edge[i].second; if (dist[v] == dist[u] + w &amp;&amp; c &amp;&amp; !vis[v]) &#123; int k = dinic(v, std::min(c, limit - flow)); if (!k) dist[v] = INF; edge[i].first -= k; edge[i ^ 1].first += k; flow += k; ans += k * w; &#125; &#125; vis[u] = false; return flow; &#125; int main() &#123; std::ios::sync_with_stdio(false); memset(head, 0xff, sizeof(head)); cin &gt;&gt; n &gt;&gt; k; s = 0; add(s, id(1, 1), k, 0); add(id(1, 1), s, 0, 0); t = id(n, n, 1) + 1; add(id(n, n, 1), t, k, 0); add(t, id(n, n, 1), 0, 0); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int w; cin &gt;&gt; w; add(id(i, j), id(i, j, 1), 1, -w); add(id(i, j, 1), id(i, j), 0, w); add(id(i, j), id(i, j, 1), INF, 0); add(id(i, j, 1), id(i, j), 0, 0); if (i &lt; n) &#123; add(id(i, j, 1), id(i + 1, j), INF, 0); add(id(i + 1, j), id(i, j, 1), 0, 0); &#125; if (j &lt; n) &#123; add(id(i, j, 1), id(i, j + 1), INF, 0); add(id(i, j + 1), id(i, j, 1), 0, 0); &#125; &#125; &#125; while (spfa()) dinic(s, INF); cout &lt;&lt; -ans &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P2774 方格取数问题","date":"2022-03-21T21:31:01.000Z","url":"/luogu-p2774/","tags":["BZOJ","洛谷","LibreOJ","网络流","Hydro","最大流","网络流 24 题"],"categories":["题解"],"content":" 题面 题目描述 有一个 m 行 n 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。 输入格式 第一行是两个用空格隔开的整数，分别代表方格图的行数 m 和列数 n。 第 2 到第 (m+1) 行，每行 n 个整数，第 (i+1) 行的第 j 个整数代表方格图第 i 行第 j 列的的方格中的数字 ai,j​。 输出格式 输出一行一个整数，代表和最大是多少。 样例输入输出 样例输入 #1 3 3 1 2 3 3 2 3 2 3 1 样例输出 #1 11 数据规模与约定 对于 100% 的数据，保证 1≤n,m≤100，1≤ai,j​≤105。 思路 可以对整个方格图进行黑白染色，将 (x+y)mod2=1 的点设为黑点，如下图所示： 可以发现，若取一个黑格的点，受到影响的就是周围的白点。然后可以建一个二分图，这道题就可以用最小割求解了。 新建一个超级源点，将所有黑点连到这个超级源点上，容量为点权； 再新建一个超级汇点，将所有白点连接到这个超级汇点上，容量为点权； 最后将每一个黑点连接到会被这个点影响到的白点上，容量为 +∞。 答案为方格图中所有点的点权和再减去最小割。 代码 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;limits&gt; #include &lt;queue&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1005, M = 100005; const int to[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; int m, n, u, s, t, flow, ans, sum; // Graph int idx, head[N], edge[M &lt;&lt; 1], ver[M &lt;&lt; 1], next[M &lt;&lt; 1]; void add(int u, int v, int w) &#123; next[idx] = head[u]; ver[idx] = v; edge[idx] = w; head[u] = idx++; &#125; // Dinic int d[N], cur[N]; bool bfs() &#123; memset(d, 0x00, sizeof(d)); std::queue&lt;int&gt; q; d[s] = 1; q.push(s); cur[s] = head[s]; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = next[i]) &#123; int v = ver[i], w = edge[i]; if (w &amp;&amp; !d[v]) &#123; d[v] = d[u] + 1; cur[v] = head[v]; if (v == t) return true; q.push(v); &#125; &#125; &#125; return false; &#125; int dinic(int u, int limit) &#123; if (u == t) return limit; int flow = 0; for (int &amp;i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = next[i]) &#123; int v = ver[i], w = edge[i]; if (w &amp;&amp; d[v] == d[u] + 1) &#123; int k = dinic(v, std::min(limit - flow, w)); if (!k) d[v] = 0; edge[i] -= k; edge[i ^ 1] += k; flow += k; &#125; &#125; return flow; &#125; int main() &#123; std::ios::sync_with_stdio(false); memset(head, 0xff, sizeof(head)); cin &gt;&gt; n &gt;&gt; m; s = 0, t = n * m + 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; int w, u = (i - 1) * m + j; cin &gt;&gt; w; sum += w; if ((i + j) &amp; 1) &#123; add(s, u, w); add(u, s, 0); for (int k = 0; k &lt; 4; k++) &#123; int xx = i + to[k][0], yy = j + to[k][1]; if (1 &lt;= xx &amp;&amp; xx &lt;= n &amp;&amp; 1 &lt;= yy &amp;&amp; yy &lt;= m) &#123; int v = (xx - 1) * m + yy; add(u, v, std::numeric_limits&lt;int&gt;::max()); add(v, u, 0); &#125; &#125; &#125; else &#123; add(u, t, w); add(t, u, 0); &#125; &#125; &#125; while (bfs()) &#123; while (flow = dinic(s, std::numeric_limits&lt;int&gt;::max())) ans += flow; &#125; cout &lt;&lt; sum - ans &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P2891 Dining G","date":"2022-03-19T21:45:11.000Z","url":"/luogu-p2891/","tags":["洛谷","USACO","图论","2007","网络流","最大流"],"categories":["题解"],"content":" 题面 本文中所给出的题面为原题面的中文翻译，并非原始题面。翻译如有错误之处，请联系指出。 题目描述 奶牛就是这么挑食。每头奶牛都有自己喜欢的食物和饮料，她不会吃她不喜欢的食物和或者喝她不喜欢的饮料。 农夫约翰为他的奶牛做了美味的饭菜，但他忘记根据她们的喜好检查他的菜单。虽然他可能无法让每头奶牛都吃饱，但他想让尽可能多的奶牛吃一顿符合她们喜好的饭。 农夫约翰烹制了 F 种食物并准备了 D 种饮料。他的 N 头奶牛中的每一头都给出了她喜欢吃的食物种类和饮料种类。农夫约翰必须为每头奶牛分配一种食物类型和一种饮料类型，以最大限度地增加同时获得这两种食物的奶牛数量。 每道菜或饮料只能由一头牛食用（即一旦将种类编号为 2 的食物分配给一头牛，就不能再将这种食物分配给其他牛）。 输入格式 第一行包含三个以空格分隔的整数 N,F,D。 接下来有 N 行数据。第 i 行以两个整数 Fi​,Di​ 开头，即奶牛喜欢吃的食物种类的数量和喜欢喝的饮料种类的数量。之后有 Fi​ 个整数给出了第 i 头奶牛喜欢吃的菜的编号，有 Di​ 个整数给出了第 i 头奶牛喜欢喝的饮料种类的编号。 输出格式 一行一个整数，表示可以享受到自己喜欢的食物和饮料的奶牛的最大数量。 输入输出样例 输入样例 #1 4 3 3 2 2 1 2 3 1 2 2 2 3 1 2 2 2 1 3 1 2 2 1 1 3 3 输出样例 #1 3 数据范围与提示 对于 100% 的数据，1≤N,F,D≤100。 思路 本题的难点主要在于建图。 一种很容易想到的做法是建立一个超级源点连接食物，食物连牛，牛连饮料，饮料连接超级汇点，然后再跑一遍最大流。但这个算法是错误的，它可能会重复选择同一只奶牛。 Hack 数据 输入数据 1 2 2 2 2 1 2 1 2 错误答案 2 正确答案 1 那么可以运用拆点的思想，将一只奶牛拆成两个点，食物连入点，出点连饮料，就避免了重复选择的问题。 之后再跑网络流求出答案即可。 代码 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;queue&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1005, M = 10005; int n, f, d, flow, ans; // Graph int idx, head[N], edge[M &lt;&lt; 1], ver[M &lt;&lt; 1], next[M &lt;&lt; 1]; void add(int u, int v, int w) &#123; next[idx] = head[u]; ver[idx] = v; edge[idx] = w; head[u] = idx++; &#125; // Dinic int dist[N], cur[N]; bool bfs() &#123; memset(dist, 0x00, sizeof(dist)); std::queue&lt;int&gt; q; q.push(0); dist[0] = 1; cur[0] = head[0]; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = next[i]) &#123; int v = ver[i], w = edge[i]; if (w &amp;&amp; !dist[v]) &#123; dist[v] = dist[u] + 1; cur[v] = head[v]; if (v == n) return true; q.push(v); &#125; &#125; &#125; return false; &#125; int dinic(int u, int limit) &#123; if (u == n) return limit; int flow = 0; for (int &amp;i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = next[i]) &#123; int v = ver[i], w = edge[i]; if (dist[v] == dist[u] + 1 &amp;&amp; w) &#123; int k = dinic(v, std::min(w, limit - flow)); if (!k) dist[v] = 0; edge[i] -= k; edge[i ^ 1] += k; flow += k; &#125; &#125; return flow; &#125; int main() &#123; std::ios::sync_with_stdio(false); memset(head, 0xff, sizeof(head)); cin &gt;&gt; n &gt;&gt; f &gt;&gt; d; for (int i = 1; i &lt;= f; i++) &#123; add(0, i, 1); add(i, 0, 0); &#125; for (int i = 1; i &lt;= n; i++) &#123; int ff, dd; cin &gt;&gt; ff &gt;&gt; dd; for (int j = 1; j &lt;= ff; j++) &#123; int x; cin &gt;&gt; x; add(x, f + d + i, 1); add(f + d + i, x, 0); &#125; add(f + d + i, f + d + n + i, 1); add(f + d + n + i, f + d + i, 0); for (int j = 1; j &lt;= dd; j++) &#123; int x; cin &gt;&gt; x; add(f + d + n + i, f + x, 1); add(f + x, f + d + n + i, 0); &#125; &#125; n = f + d + n * 2 + 1; for (int i = 1; i &lt;= d; i++) &#123; add(f + i, n, 1); &#125; while (bfs()) &#123; while (flow = dinic(0, 0x3f3f3f3f)) ans += flow; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"最大流学习笔记","date":"2022-03-13T21:11:26.000Z","url":"/max-flow/","tags":["图论","网络流","最大流"],"categories":["笔记"],"content":"最大流问题是求解图上从源点流向汇点的最大流量的问题。 求解最大流问题主要有两种算法：Edmonds-Karp 动能算法（EK 算法）和 Dinic 算法，其中后者在算法竞赛中更为常用。 基本概念 流网络 流网络 G=(V,E)（Flow Network） 是一个有向图，图中每条边 (u,v)∈E 有一个非负的 容量值 c(u,v)≥0。而且，如果边集合 E 包含一条边 (u,v)，则图中不存在反方向的边 (v,u)。为了方便起见，如果 (u,v)∈/E，则定义 c(u,v)=0。 在流网络的所有节点中，有两个特殊的点：源点 s 和汇点 t (s=t)。 流 设 f(u,v) 定义在二元组 (u∈V,v∈V) 上的实数函数且满足 容量限制（Capacity Constraints）：对于每条边，流经该边的流量不得超过该边的容量，即 ∀u,v∈V,f(u,v)≤c(u,v)； 流量守恒（Flow Conservation）：从源点流出的流量等于汇点流入的流量，即 ∀x∈V−{s,t},∑(u,x)∈E​f(u,x)=∑(x,v)∈E​f(x,v)； 那么 f 称为网络 G 的流函数。 对于 (u,v)∈E，f(u,v) 称为边的 流量，c(u,v)−f(u,v) 称为边的 剩余容量（Residual Capacity），可以记作 cf​(u,v)。整个网络的流量为 ∑(s,v)∈E​f(s,v)，即从源点发出的所有流量之和。为了方便起见，如果 (u,v)∈/E，则定义 f(u,v)=0。 一般而言也可以把网络流理解为整个图的流量。而这个流量必满足上述两个性质。 流函数的完整定义如下： f(u,v)=⎩⎨⎧​​f(u,v),−f(v,u),0,​(u,v)∈E(v,u)∈E(u,v)∈/E,(v,u)∈/E​ 残量网络 对于流函数 f，残量网络 Gf​（Residual Network）是网络 G 中所有节点和剩余容量大于 0 的边构成的子图，即 Gf​=(Vf​=V,Ef​={(u,v)∈E,cf​(u,v)&gt;0}) 注意，剩余容量大于 0 的边可能不在原图 G 中（根据容量、剩余容量的定义以及流函数的斜对称性得到）。可以理解为，残量网络中包括了那些还剩了流量空间的边构成的图，也包括虚边（即反向边）。 增广路 在原图 G 中若存在一条从源点到汇点的路径上所有边的剩余容量都大于 0，则这条路径被称为增广路（Augmenting Path）。 Edmonds-Karp 算法 Edmonds-Karp 算法的基本思路很简单：不断地使用 BFS 去寻找增广路，直到网络上不存在增广路为止。 在每轮寻找增广路的过程中，Edmonds-Karp 算法只考虑所有 cf​(u,v)≥0 的边，用 BFS 找到任意一条从 s 到 t 的路径，同时计算出路径上各边的剩余容量的最小值 minf，则网络的流量就可以增加 minf。 需要注意的是，当一条边的流量 f(u,v)&gt;0 时，根据斜对称性质，它的反向边流量 f(v,u)&lt;0，此时必定有 f(v,u)&lt;c(v,u)。故 Edmonds-Karp 算法在 BFS 时除了原图的边集 E 外，还应该考虑遍历 E 中每条边的反向边。 在实现时，只需要维护残量网络即可。当一条边 (u,v) 流过大小为 e 的流时，令 (u,v) 的剩余容量减小 (e)，(v,u) 的剩余流量增大 e 即可。 Edmonds-Karp 算法的时间复杂度为 O(VE2)。然而在实际运用中远远达不到这个上界，效率较高，可以处理 103∼104 规模的网络。 来自 GitHub Copilot 的补全（未验证）：然而在实际应用中，这个算法的时间复杂度可以降低到 O(VE)，因为在每轮 BFS 时，只需要更新 E 中的边的剩余容量，而不需要更新 V 中的节点。 代码 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;limits&gt; #include &lt;queue&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1005, M = 10005; int n, m, s, t, ans; // Graph int idx, head[N], ver[M &lt;&lt; 1], edge[M &lt;&lt; 1], next[M &lt;&lt; 1]; void add(int u, int v, int w) &#123; next[idx] = head[u]; ver[idx] = v; edge[idx] = w; head[u] = idx++; &#125; // Edmonds-Karp int d[N], pre[N]; bool vis[N]; bool bfs() &#123; memset(vis, 0x00, sizeof(vis)); std::queue&lt;int&gt; q; q.push(s); vis[s] = true; d[s] = std::numeric_limits&lt;int&gt;::max(); while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = head[x]; ~i; i = next[i]) &#123; if (edge[i]) &#123; int y = ver[i]; if (vis[y]) continue; d[y] = std::min(d[x], edge[i]); pre[y] = i; // 记录前驱 q.push(y); vis[y] = true; if (y == t) return true; &#125; &#125; &#125; return false; &#125; void update() &#123; // 更新增广路及其反向边的剩余容量 int x = t; while (x != s) &#123; int i = pre[x]; edge[i] -= d[t]; edge[i ^ 1] += d[t]; x = ver[i ^ 1]; &#125; ans += d[t]; &#125; int main() &#123; std::ios::sync_with_stdio(false); memset(head, 0xff, sizeof(head)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); add(v, u, 0); &#125; while (bfs()) update(); cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; Dinic 算法 Edmonds-Karp 算法每轮可能会遍历整个残量网络，但只找出一条增广路，还有进一步优化的空间。 Dinic 算法不断重复以下步骤，直到在残量网络中 s 不能到达 t： 在残量网络上 BFS 求出节点的层次，构造分层图。 在分层图上 DFS 求出增广路，在回溯时实时更新剩余容量。另外，每个点可以流向多条出边，同时还加入了若干剪枝（参考程序注释）。 Dinic 算法的时间复杂度为 O(V2E)。但在实际中远远达不到这个上界，一般能够处理 104∼105 规模的网络，特别地，在求解稠密图上的最大流问题是效率要比前文提到的 Edmonds-Karp 算法更高。 Dinic 算法中的两个优化： 多路增广：每找到一条增广路时，若还有残余流量存在，那么可以再找出其他的增广路来利用这些残余流量。这样就可以在一次 DFS 中找出多条增广路，大大提高了算法的效率。 当前弧优化：如果一条边已经被增广过，那么该边就没有可能被增广第二次。那么，当下一次进行增广的时候，就可以不必再走那些已经被增广过的边。 代码 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;queue&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 205, M = 5005; int n, m, s, t, flow; long long ans; // Graph int idx, head[N], edge[M &lt;&lt; 1], ver[M &lt;&lt; 1], next[M &lt;&lt; 1]; void add(int u, int v, int w) &#123; next[idx] = head[u]; edge[idx] = w; ver[idx] = v; head[u] = idx++; &#125; // Dinic int d[N], cur[N]; bool bfs() &#123; memset(d, 0x00, sizeof(d)); std::queue&lt;int&gt; q; d[s] = 1; q.push(s); cur[s] = head[s]; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = next[i]) &#123; int v = ver[i], w = edge[i]; if (w &amp;&amp; !d[v]) &#123; d[v] = d[u] + 1; cur[v] = head[v]; if (v == t) return true; q.push(v); &#125; &#125; &#125; return false; &#125; int dinic(int u, int limit) &#123; if (u == t) return limit; int flow = 0; for (int i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = next[i]) &#123; cur[u] = i; // 当前弧优化 int v = ver[i], w = edge[i]; if (w &amp;&amp; d[v] == d[u] + 1) &#123; int k = dinic(v, std::min(edge[i], limit - flow)); if (!k) d[v] = 0; // 剪枝：去掉增广完毕的点 edge[i] -= k; edge[i ^ 1] += k; flow += k; &#125; &#125; return flow; &#125; int main() &#123; std::ios::sync_with_stdio(false); memset(head, 0xff, sizeof(head)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i = 1; i &lt;= m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); add(v, u, 0); &#125; while (bfs()) &#123; while (flow = dinic(s, 0x3f3f3f3f)) ans += flow; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 参考资料 0x6A 网络流初步，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 第 26 章 最大流，《算法导论》中译本（ISBN 978-7-111-40701-0，机械工业出版社），2013 年 1 月第三版。 1.1.1 网络流的基本概念，AcWing 算法进阶课，闫学灿，2020 年 7 月 25 日。 1.1.2 最大流，AcWing 算法进阶课，闫学灿，2020 年 7 月 31 日 ~ 2020 年 8 月 8 日。 网络流简介，图论，OI Wiki，2021 年 7 月 11 日。 "},{"title":"学考自救指北 —— SQL 篇","date":"2022-03-11T20:35:28.000Z","url":"/xuekao-sql/","tags":["学考","SQL"],"categories":["杂项"],"content":"SQL（Structured Query Language，结构化查询语言）是一种具有数据操纵和数据定义等多种功能的数据库语言。 基本概念 这些可以不用会，但最好了解一下。 数据库（database）：保存有组织的数据的容器（通常是一个文件或一组文件）。 数据表（table）：某种特定类型数据的结构化清单。 模式（schema）：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。 列（column）：表中的一个字段。所有表都是由一个或多个列组成的。 行（row）：表中的一个记录。 主键（primary key）：一列（或一组列），其值能够唯一标识表中每一行。 SQL 语法 SQL 语句不区分大小写（数据库表名、列名和值是否区分大小写，依赖于具体的 DBMS 以及配置）。 例如：SELECT 与 select、Select 是相同的。 多条 SQL 语句必须以半角分号（;）分隔，部分数据库系统要求在每条 SQL 语句后都添加分号。 处理 SQL 语句时，所有空格都被忽略。SQL 语句可以写成一行，也可以分写为多行。 SQL 中的注释有两种形式： 单行注释：-- 后面跟着任意字符串，包括空格。 多行注释：以 /* 开始，*/ 结束。 部分引擎还支持以 # 号开头的注释，在此不做过多叙述。 基本操作 创建表 下方的 SQL 语句创建了一个名为 students 的数据表，表中包含了学生的编号、姓名、出生日期、班级，其中编号每次插入新行都会自动加一、班级（class）默认为「高一年级 A16 班」，并将学生编号设置为了数据表的主键（PRIMARY KEY (`id`) 子句），还设置了这些字段不能为空值（NOT NULL）。 CREATE TABLE `students` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` char(20) NOT NULL, `birthdate` date NOT NULL, `class` char(20) NOT NULL DEFAULT &#x27;高一年级A16班&#x27;, PRIMARY KEY (`id`) ); 常用数据类型 数据类型 说明 INTEGER (简写 int) 整数型 NUMERIC(全长, 小数位数) 数值型 CHAR 定长字符串 VARCHAR 可变长字符串 DATE 日期型 示例：NUMERIC(7, 2) 表示数值型，有 5 位整数，2 位小数，全长 7 位。 关于主键 主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。 删除表 下方的 SQL 语句删除了一个名为 students 的数据表。 DROP TABLE `students`; 更新表定义 更新表定义可以使用 ALTER 子句。 增加列 下方的语句可以为 students 数据表在 class 列后再增加一个新的列，新列的名称为 address，数据类型为 varchar(100)。 ALTER TABLE `students` ADD COLUMN `address` varchar(100) NOT NULL AFTER `class`; 如果不写 AFTER 子句，则新列会被添加到数据表的最后面。也可以使用 FIRST 替代这个子句，这样新列会被添加到数据表的开头。 删除列 下方的语句可以删除 students 表中名为 address 的列。 ALTER TABLE `students` DROP COLUMN `address`; 更改表名 下方的语句可以将名为 students 的表更名为 student。 ALTER TABLE `students` RENAME TO `student`; 数据增加 基本格式： INSERT INTO `students` (`name`, `birthdate`, `class`) VALUES (&#x27;张三&#x27;, &#x27;1926-08-17&#x27;, &#x27;高一年级A16班&#x27;); 这个语句的意思是向名为 students 的表中插入一行，其中 name 列的值为 张三，birthdate 列的值为 1926-08-17，class 列的值为 高一年级A16班，其他列均为默认值。 数据检索 基本格式： SELECT `name` FROM `students`; 这个语句的意思是从名为 students 的表中查询 name 列（字段）的值，即获取所有学生的名字。 字段名可以使用通配符代替，这样可以获取所有字段的值，例如： SELECT * FROM `students`; 数据删除 可以使用 DELETE 语句来删除数据。 DELETE FROM `students` WHERE `id` = 1; 这个语句可以删除编号为 1 的学生。 数据更新 可以使用 UPDATE 语句来更新数据。 UPDATE `students` SET `name` = &#x27;李四&#x27; WHERE `id` = 1; 这个语句可以将编号为 1 的学生的姓名改为 李四。 当然，将名字为「张三」的学生改名为「李四」也不是不可以： UPDATE `students` SET `name` = &#x27;李四&#x27; WHERE `name` = &#x27;张三&#x27;; 数据过滤 SQL 中的数据过滤可以使用 WHERE 子句和一些辅助函数来完成。 单条件筛选 下方的语句可以从 students 表中选择出所有名为「张三」的学生（即 name 的值为 张三 的所有行）并输出该行的所有信息。 SELECT * FROM `students` WHERE `name` = &#x27;张三&#x27;; 多条件筛选 下方的语句可以从 students 表中选择出「高一年级 A16 班」中所有名为「张三」的学生（即 name 字段的值为 张三 且 class 字段的值为 高一年级A16班），并输出这些学生的生日。 SELECT birthdate FROM `students` WHERE `name` = &#x27;张三&#x27; AND `class` = &#x27;高一年级A16班&#x27;; 如果只需要满足这两个条件之中的某一个可以使用 OR 代替 AND。 下方的语句可以从 exams 表中选择出「2021 - 2022 学年第一学期期中考试」中总成绩大于 300 分的所有学生。 SELECT * FROM `exams` WHERE `name` = &#x27;2021-2022学年第一学期期中考试&#x27; AND `score` &gt; 300; IN 操作符 下方的语句可以从 students 表中选择出所有在「高一年级 A15 班」和「高一年级 A16 班」的学生。 SELECT * FROM `students` WHERE `class` IN (&#x27;高一年级A15班&#x27;, &#x27;高一年级A16班&#x27;); 也可以这样写，不过不太简洁： SELECT * FROM `students` WHERE `class` = &#x27;高一年级A15班&#x27; OR `class` = &#x27;高一年级A16班&#x27;; NOT 操作符 下方的语句可以从 students 表中选择出所有 不在「高一年级 A15 班」和「高一年级 A16 班」的学生。 SELECT * FROM `students` WHERE `class` NOT IN (&#x27;高一年级A15班&#x27;, &#x27;高一年级A16班&#x27;); 通配符匹配 使用 LIKE 子句可以实现通配符匹配，例如： SELECT * FROM `students` WHERE `name` LIKE &#x27;张%&#x27;; 这个语句可以选择出所有名字以 张 开头的学生。 而使用 _ 可以匹配任意一个字符，例如： SELECT * FROM `students` WHERE `name` LIKE &#x27;马_国&#x27;; 这个语句可以选择出所有名字有三个字的，且名字以 马 开头、以 国 结尾的学生。 数据处理 排序 排序可以使用 ORDER BY 子句来完成，例如： SELECT * FROM `exams` WHERE `name` = &#x27;2021-2022学年第一学期期中考试&#x27; ORDER BY `score`; 这个语句可以选择出所有名为 2021-2022学年第一学期期中考试 的考试，并按照 score 字段进行排序。 如果需要降序排序，那么为 ORDER BY 子句添加 DESC 即可： SELECT * FROM `exams` WHERE `name` = &#x27;2021-2022学年第一学期期中考试&#x27; ORDER BY `score` DESC; LIMIT 子句 可以使用这个子句来限制输出数量，比如下面这个语句就可以输出考试中成绩前十名的学生： SELECT * FROM `exams` WHERE `name` = &#x27;2021-2022学年第一学期期中考试&#x27; ORDER BY `score` DESC LIMIT 10; 内建函数 SQL 中常用的内建函数有 5 个，分别是 count sum avg max min。 COUNT 函数 下面的语句返回指定列的值的数目（未去重）： SELECT COUNT(`name`) FROM `exams`; 如果需要对数据进行去重，可以使用 DISTINCT 子句： SELECT COUNT(DISTINCT `name`) FROM `exams`; 也可以统计表中数据的行数，使用 COUNT(*) 子句： SELECT COUNT(*) FROM `exams`; SUM 函数 下面的语句可以返回指定列中的所有值的总和： SELECT SUM(`score`) FROM `exams` WHERE `name` = &#x27;2021-2022学年第一学期期中考试&#x27;; 这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试中所有同学们获得的总分之和。 AVG 函数 下面的语句可以返回指定列中的所有值的平均值： SELECT AVG(`score`) FROM `exams` WHERE `name` = &#x27;2021-2022学年第一学期期中考试&#x27;; 这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试的平均分。 MIN 函数 下面的语句可以返回指定列中的所有值的最小值： SELECT MIN(`score`) FROM `exams` WHERE `name` = &#x27;2021-2022学年第一学期期中考试&#x27;; 这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试中的最低分。 MAX 函数 SELECT MAX(`score`) FROM `exams` WHERE `name` = &#x27;2021-2022学年第一学期期中考试&#x27;; 这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试中的最高分。 参考资料 SQL 教程，菜鸟教程。 Transact-SQL 参考，Microsoft SQL Server 中文文档。 MySQL 8.0 Reference Manual，Oracle Docs。 本文是在 GitHub Copilot 的辅助之下编写的，版权共有。如有错误请及时指正。 "},{"title":"洛谷 - P1486 郁闷的出纳员","date":"2022-03-07T20:16:40.000Z","url":"/luogu-p1486/","tags":["数据结构","洛谷","Treap","STL","NOI","2004"],"categories":["题解"],"content":" 题面 题目描述 OIER 公司是一家大型专业化软件公司，有着数以万计的员工。作为一名出纳员，我的任务之一便是统计每位员工的工资。这本来是一份不错的工作，但是令人郁闷的是，我们的老板反复无常，经常调整员工的工资。如果他心情好，就可能把每位员工的工资加上一个相同的量。反之，如果心情不好，就可能把当前在公司的所有员工的工资扣除一个相同的量。我真不知道除了调工资他还做什么其它事情。 工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。 老板经常到我这边来询问工资情况，他并不问具体某位员工的工资情况，而是问现在工资第 k 多的员工拿多少工资。每当这时，我就不得不对数万个员工进行一次漫长的排序，然后告诉他答案。 好了，现在你已经对我的工作了解不少了。正如你猜的那样，我想请你编一个工资统计程序。怎么样，不是很困难吧？ 如果某个员工的初始工资低于最低工资标准，那么将不计入最后的答案内。 输入格式 第一行有两个整数 n 和 min。n 表示下面有多少条命令，min 表示工资下界。 接下来的 n 行，每行一个字符 x 和一个整数 k，表示一条命令。命令可以是以下四种之一： I k 新建一个工资档案，初始工资为 k。如果某员工的初始工资低于工资下界，他将立刻离开公司。 A k 把每位员工的工资加上 k。 S k 把每位员工的工资扣除 k。 F k 查询第 k 多的工资。 在初始时，可以认为公司里一个员工也没有。 输出格式 对于每条 F 命令，你的程序要输出一行，仅包含一个整数，为当前工资第 k 多的员工所拿的工资数，如果 k 大于目前员工的数目，则输出 −1。 输出的最后一行包含一个整数，为离开公司的员工的总数。 请注意，初始工资低于工资下界的员工不算做离开公司的员工。 数据规模与约定 对于 100% 的数据，保证： I 命令的条数不超过 105； A 和 S 命令的总条数不超过 100； F 命令的条数不超过 105； 每次工资调整的调整量不超过 103； 新员工的工资不超过 105。 0≤n≤3×105，0≤min≤109，输入的所有数字均在 32 位带符号整形范围内。 思路 可以使用一个全局变量 Δ 来记录工资的变化。 每次添加员工的时候，若 k&lt;min 则不添加，否则添加 k−Δ 即可。 每次调整的时候只需要在调整后删除掉工资小于 min−Δ 的员工即可。 STLFHQ Treap可以使用 std::vector 来存储员工工资数据。 在插入的时候使用 std::lower_bound 来查找插入位置，确保容器内部元素有序。 在降工资时删除所有小于等于 min−Δ 的员工的数据，并记录删除人数。FHQ Treap 板子活用一下就行了。 在降工资时将整颗 Treap 分裂为两个子树，左子树是工资小于 min−Δ 的员工，记录元素数量并删除该子树即可。 此处求第 k 大可以直接转化成求第 n−k+1 小的元素。 代码 STLFHQ Treap#include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; int n, min, k, c, cnt; char op; std::vector&lt;int&gt; a; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; min; while (n--) &#123; cin &gt;&gt; op &gt;&gt; k; if (op == &#x27;I&#x27;) &#123; if (k &gt;= min) &#123; a.insert(std::lower_bound(a.begin(), a.end(), k - c), k - c); &#125; &#125; else if (op == &#x27;A&#x27;) &#123; c += k; &#125; else if (op == &#x27;S&#x27;) &#123; c -= k; auto it = std::lower_bound(a.begin(), a.end(), min - c); cnt += it - a.begin(); a.erase(a.begin(), std::lower_bound(a.begin(), a.end(), min - c)); &#125; else &#123; // op == &#x27;F&#x27; cout &lt;&lt; (a.size() &lt; k ? -1 : *(a.end() - k) + c) &lt;&lt; endl; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; return 0; &#125;#include &lt;cstdlib&gt; #include &lt;iostream&gt; using std::cin; using std::cout; const char endl = &#x27;\\n&#x27;; const int N = 1e5 + 5; int n, min, k, c, ans; char op; // Treap int root, cnt; struct node &#123; int l, r, s, v, k; node() : l(0), r(0), s(0), v(0), k(rand()) &#123;&#125; node(int _v) : l(0), r(0), s(1), v(_v), k(rand()) &#123;&#125; &#125; tr[N]; void pushup(int u) &#123; tr[u].s = tr[tr[u].l].s + 1 + tr[tr[u].r].s; &#125; std::pair&lt;int, int&gt; split(int p, int k) &#123; if (!p) return std::make_pair(0, 0); if (k &lt;= tr[tr[p].l].s) &#123; auto o = split(tr[p].l, k); tr[p].l = o.second; pushup(p); o.second = p; return o; &#125; auto o = split(tr[p].r, k - tr[tr[p].l].s - 1); tr[p].r = o.first; pushup(p); o.first = p; return o; &#125; std::pair&lt;int, int&gt; splitByValue(int p, int v) &#123; if (!p) return std::make_pair(0, 0); if (v &lt;= tr[p].v) &#123; auto o = splitByValue(tr[p].l, v); tr[p].l = o.second; pushup(p); o.second = p; return o; &#125; auto o = splitByValue(tr[p].r, v); tr[p].r = o.first; pushup(p); o.first = p; return o; &#125; int merge(int x, int y) &#123; if (!x || !y) return x | y; if (tr[x].k &gt; tr[y].k) &#123; tr[x].r = merge(tr[x].r, y); pushup(x); return x; &#125; tr[y].l = merge(x, tr[y].l); pushup(y); return y; &#125; void insert(int v) &#123; auto o = splitByValue(root, v); int p = ++cnt; tr[p] = node(v); root = merge(o.first, merge(p, o.second)); &#125; int getKth(int k) &#123; auto x = split(root, k - 1); auto y = split(x.second, 1); int r = y.first; root = merge(x.first, merge(y.first, y.second)); return tr[r].v; &#125; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; min; while (n--) &#123; cin &gt;&gt; op &gt;&gt; k; if (op == &#x27;I&#x27;) &#123; if (k &gt;= min) &#123; insert(k - c); &#125; &#125; else if (op == &#x27;A&#x27;) &#123; c += k; &#125; else if (op == &#x27;S&#x27;) &#123; c -= k; auto o = splitByValue(root, min - c); root = o.second; ans += tr[o.first].s; &#125; else &#123; // op == &#x27;F&#x27; cout &lt;&lt; (tr[root].s &lt; k ? -1 : getKth(tr[root].s - k + 1) + c) &lt;&lt; endl; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P3391 【模板】文艺平衡树","date":"2022-03-02T20:55:32.000Z","url":"/luogu-p3391/","tags":["洛谷","AcWing","S2OJ","LibreOJ","平衡树","Treap","模板"],"categories":["题解"],"content":" 题面 题目描述 您需要写一种数据结构（可参考题目标题），来维护一个有序数列。 其中需要提供以下操作：翻转一个区间，例如原有序序列是 5 4 3 2 1，翻转区间是 [2,4] 的话，结果是 5 2 3 4 1。 输入格式 第一行两个正整数 n,m，表示序列长度与操作个数。序列中第 i 项初始为 i。 接下来 m 行，每行两个正整数 l,r，表示翻转的区间。 输出格式 输出一行 n 个正整数，表示原始序列经过 m 次变换后的结果。 输入输出样例 样例输入 #1 5 3 1 3 1 3 1 4 样例输出 #1 4 3 2 1 5 数据范围与约定 对于 100% 的数据，1≤n,m≤100000，1≤l≤r≤n。 思路 前置知识：无旋 Treap 学习笔记。 当翻转 [l,r] 区间时，先分裂出 [1,r] 和 [r+1,size] 两个区间，再从 [1,r] 中分裂出 [1,l−1] 和 [l,r] 两个区间。将 [l,r] 区间打标记后再合并即可。 最后按照中序遍历输出即为答案。 代码 #include &lt;cstdlib&gt; #include &lt;iostream&gt; using std::cin; using std::cout; #define endl &#x27;\\n&#x27; const int N = 1e5 + 5; int n, m, l, r, root, cnt; struct node &#123; int l, r, s, v, k; bool d; node() : l(0), r(0), s(0), v(0), d(false), k(rand()) &#123;&#125; node(int _v) : l(0), r(0), s(1), v(_v), d(false), k(rand()) &#123;&#125; &#125; tr[N]; void pushup(int u) &#123; tr[u].s = tr[tr[u].l].s + tr[tr[u].r].s + 1; &#125; void pushdown(int u) &#123; if (tr[u].d) &#123; tr[u].d = false; tr[tr[u].l].d ^= 1; tr[tr[u].r].d ^= 1; std::swap(tr[u].l, tr[u].r); &#125; &#125; int build(int l, int r) &#123; if (l &gt; r) return 0; int mid = l + r &gt;&gt; 1; int p = ++cnt; tr[p] = node(mid - 1); tr[p].l = build(l, mid - 1); tr[p].r = build(mid + 1, r); pushup(p); return p; &#125; std::pair&lt;int, int&gt; split(int p, int k) &#123; if (!p) return std::make_pair(0, 0); pushdown(p); if (k &lt;= tr[tr[p].l].s) &#123; auto o = split(tr[p].l, k); tr[p].l = o.second; pushup(p); o.second = p; return o; &#125; auto o = split(tr[p].r, k - tr[tr[p].l].s - 1); tr[p].r = o.first; pushup(p); o.first = p; return o; &#125; int merge(int x, int y) &#123; if (!x || !y) return x | y; pushdown(x); pushdown(y); if (tr[x].k &gt; tr[y].k) &#123; tr[x].r = merge(tr[x].r, y); pushup(x); return x; &#125; tr[y].l = merge(x, tr[y].l); pushup(y); return y; &#125; void reserve(int l, int r) &#123; auto x = split(root, r + 1); auto y = split(x.first, l); tr[y.second].d ^= 1; root = merge(merge(y.first, y.second), x.second); &#125; void print(int p) &#123; if (!p) return; pushdown(p); print(tr[p].l); if (1 &lt;= tr[p].v &amp;&amp; tr[p].v &lt;= n) &#123; cout &lt;&lt; tr[p].v &lt;&lt; &#x27; &#x27;; &#125; print(tr[p].r); &#125; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; root = build(1, n + 2); while (m--) &#123; cin &gt;&gt; l &gt;&gt; r; reserve(l, r); &#125; print(root); cout &lt;&lt; endl; return 0; &#125; "},{"title":"无旋 Treap 学习笔记","date":"2022-02-18T15:27:40.000Z","url":"/fhq-treap/","tags":["数据结构","平衡树","Treap"],"categories":["笔记"],"content":"无旋 Treap，又名 FHQ-Treap。无旋 Treap 仅有两种核心操作 —— 分裂与合并，它依靠这两种操作来维护树的平衡，从而省去了旋转操作。这种操作方式使得它天生支持维护序列、可持久化等特性。 本文提供使用原生指针和数组模拟指针两种方法实现的代码，可以点击代码块上方的切换按钮查看两种不同版本的代码。 前言 Treap 是一种弱平衡的二叉搜索树。它的数据结构由二叉树和二叉堆组合形成，名字也因此为 tree 和 heap 的组合。 Treap 的每个结点上除了按照二叉搜索树排序的 key 值外要额外储存一个叫 priority 的值。它由每个结点建立时随机生成，并按照最大堆性质排序。因此 Treap 除了要满足二叉搜索树的性质之外，还需满足父节点的 priority 大于等于两个子节点的值。所以它是期望平衡的。搜索，插入和删除操作的期望时间复杂度为 O(logn)。 主要操作 分裂 本节所介绍的分裂操作会按照排名将一棵树分裂为两棵子树，左子树包含 k 个元素，右子树包含剩余元素。 分割时，如果左子树中元素个数不足 k 个，就从右子树中分割 k−size(left)−1 个元素放置到左子树中，反之则从左子树中划分出 size(left)−k 个元素放置到右子树中。 不要忘记 pushup。 指针数组std::pair&lt;Treap::node *, Treap::node *&gt; Treap::split(Treap::node *p, int k) &#123; if (p == nullptr) return std::make_pair(nullptr, nullptr); std::pair&lt;Treap::node *, Treap::node *&gt; o; if (k &lt;= getNodeSize(p-&gt;left)) &#123; o = split(p-&gt;left, k); p-&gt;left = o.second; p-&gt;pushup(); o.second = p; &#125; else &#123; o = split(p-&gt;right, k - getNodeSize(p-&gt;left) - 1); p-&gt;right = o.first; p-&gt;pushup(); o.first = p; &#125; return o; &#125;std::pair&lt;int, int&gt; Treap::split(int p, int k) &#123; if (!p) return std::make_pair(0, 0); if (k &lt;= tr[tr[p].l].s) &#123; auto o = split(tr[p].l, k); tr[p].l = o.second; pushup(p); o.second = p; return o; &#125; auto o = split(tr[p].r, k - tr[tr[p].l].s - 1); tr[p].r = o.first; pushup(p); o.first = p; return o; &#125; 按值分裂 本节介绍的分裂操作将会按照元素值的大小将一棵树分裂为两棵子树，左子树中的元素均不大于 val，右子树中的元素均大于 val。 指针数组std::pair&lt;Treap::node *, Treap::node *&gt; Treap::splitByValue(Treap::node *p, int val) &#123; if (p == nullptr) return std::make_pair(nullptr, nullptr); std::pair&lt;Treap::node *, Treap::node *&gt; o; if (p-&gt;val &lt; val) &#123; o = splitByValue(p-&gt;right, val); p-&gt;right = o.first; p-&gt;pushup(); o.first = p; &#125; else &#123; o = splitByValue(p-&gt;left, val); p-&gt;left = o.second; p-&gt;pushup(); o.second = p; &#125; return o; &#125;std::pair&lt;int, int&gt; Treap::splitByValue(int p, int v) &#123; if (!p) return std::make_pair(0, 0); if (tr[p].v &lt; v) &#123; auto o = splitByValue(tr[p].r, v); tr[p].r = o.first; pushup(p); o.first = p; return o; &#125; auto o = splitByValue(tr[p].l, v); tr[p].l = o.second; pushup(p); o.second = p; return o; &#125; 合并 合并操作也就是将两棵 Treap 合并成一棵 Treap，其中一颗 Treap 的所有点的权值均小于或大于另一颗 Treap 任意点的权值。 指针数组Treap::node *Treap::merge(Treap::node *x, Treap::node *y) &#123; if (x == nullptr) return y; if (y == nullptr) return x; if (x-&gt;key &gt; y-&gt;key) &#123; x-&gt;right = merge(x-&gt;right, y); x-&gt;pushup(); return x; &#125; y-&gt;left = merge(x, y-&gt;left); y-&gt;pushup(); return y; &#125;int Treap::merge(int x, int y) &#123; if (!x) return y; if (!y) return x; if (tr[x].k &gt; tr[y].k) &#123; tr[x].r = merge(tr[x].r, y); pushup(x); return x; &#125; tr[y].l = merge(x, tr[y].l); pushup(y); return y; &#125; 内部工具库 获取子树大小 判断子树是否为空，若空返回 0，非空返回子树大小。 inline int Treap::getNodeSize(Treap::node *node) &#123; return node == nullptr ? 0 : node-&gt;size; &#125; 查找元素 (find) 递归查找值为 val 的元素，根据 BST 的性质即可进行。 递归到某个节点时，先判断当前节点的元素值大小，若查询值小于当前节点的元素值时则向左子树递归，反之则向右子树递归。时间复杂度为 O(logn)。 指针数组Treap::node *Treap::find(Treap::node *p, int val) &#123; if (p == nullptr) return nullptr; if (p-&gt;val == val) return p; if (p-&gt;val &gt; val) return find(p-&gt;left, val); return find(p-&gt;right, val); &#125;int Treap::find(int p, int v) &#123; if (!p) return 0; if (tr[p].v == v) return p; if (tr[p].v &gt; v) return find(tr[p].l, v); return find(tr[p].r, v); &#125; 封装函数 插入 先将整个 Treap 按照给定的值分割成两个子树，再在这两个子树的中间插入新值即可。 指针数组void Treap::insert(int val) &#123; auto o = splitByValue(root, val); o.first = merge(o.first, new Treap::node(val)); root = merge(o.first, o.second); &#125;void insert(int v) &#123; auto o = splitByValue(root, v); int p = ++cnt; tr[p] = node(v); o.first = merge(o.first, p); root = merge(o.first, o.second); &#125; 删除 本删除操作在遇到多个相同的数时只会删除一个。具体操作与插入类似，不再过多叙述。 指针数组void Treap::erase(int val) &#123; auto o = splitByValue(root, val); auto t = o; if (find(o.second, val) != nullptr) &#123; t = split(o.second, 1); delete t.first; &#125; root = merge(o.first, t.second); &#125;void Treap::erase(int v) &#123; auto o = splitByValue(root, v); auto t = o; if (find(o.second, v)) &#123; t = split(o.second, 1); &#125; root = merge(o.first, t.second); &#125; 排名 将整棵树按值分裂，左子树的大小再加 1 即为该数的排名。 指针数组int Treap::getRank(int val) &#123; auto x = splitByValue(root, val); int r = getNodeSize(x.first) + 1; root = merge(x.first, x.second); return r; &#125;int Treap::getRank(int v) &#123; auto x = splitByValue(root, v); int r = tr[x.first].s; root = merge(x.first, x.second); return ++r; &#125; 第 k 大元素 将整棵树分裂为由前 k−1 个元素和其余节点组成的两棵子树，则右子树的第一个元素即为所求。 指针数组int Treap::getKth(int k) &#123; auto x = split(root, k - 1); auto y = split(x.second, 1); Treap::node *o = y.first; root = merge(x.first, merge(y.first, y.second)); return o == nullptr ? 0 : o-&gt;val; &#125;int Treap::getKth(int k) &#123; auto x = split(root, k - 1); auto y = split(x.second, 1); int o = y.first; root = merge(x.first, merge(y.first, y.second)); return tr[o].v; &#125; 代码 需要的外部函数：rand（定义于头文件 &lt;cstdlib&gt;）。 指针版和数组版的 Treap 类暴露出的接口是一样的。 指针数组// Definition class Treap &#123; private: struct node &#123; node *left, *right; int size, val, key; node(); node(int); ~node(); void pushup(); &#125; * root; int getNodeSize(node *); node *find(node *, int); std::pair&lt;node *, node *&gt; split(node *, int); std::pair&lt;node *, node *&gt; splitByValue(node *, int); node *merge(node *, node *); public: Treap(); ~Treap(); void insert(int); void erase(int); int getRank(int); int getKth(int); &#125; tree; // === Treap === // struct Treap::node Treap::node::node() : left(nullptr), right(nullptr), size(0), val(0), key(rand()) &#123;&#125; Treap::node::node(int _val) : left(nullptr), right(nullptr), size(1), val(_val), key(rand()) &#123;&#125; Treap::node::~node() &#123; delete left, right; &#125; inline void Treap::node::pushup() &#123; size = 1; if (left != nullptr) size += left-&gt;size; if (right != nullptr) size += right-&gt;size; &#125; // class Treap Treap::Treap() : root(nullptr) &#123;&#125; Treap::~Treap() &#123; delete root; &#125; inline int Treap::getNodeSize(Treap::node *node) &#123; return node == nullptr ? 0 : node-&gt;size; &#125; std::pair&lt;Treap::node *, Treap::node *&gt; Treap::split(Treap::node *p, int k) &#123; if (p == nullptr) return std::make_pair(nullptr, nullptr); std::pair&lt;Treap::node *, Treap::node *&gt; o; if (k &lt;= getNodeSize(p-&gt;left)) &#123; o = split(p-&gt;left, k); p-&gt;left = o.second; p-&gt;pushup(); o.second = p; &#125; else &#123; o = split(p-&gt;right, k - getNodeSize(p-&gt;left) - 1); p-&gt;right = o.first; p-&gt;pushup(); o.first = p; &#125; return o; &#125; std::pair&lt;Treap::node *, Treap::node *&gt; Treap::splitByValue(Treap::node *p, int val) &#123; if (p == nullptr) return std::make_pair(nullptr, nullptr); std::pair&lt;Treap::node *, Treap::node *&gt; o; if (p-&gt;val &lt; val) &#123; o = splitByValue(p-&gt;right, val); p-&gt;right = o.first; p-&gt;pushup(); o.first = p; &#125; else &#123; o = splitByValue(p-&gt;left, val); p-&gt;left = o.second; p-&gt;pushup(); o.second = p; &#125; return o; &#125; Treap::node *Treap::merge(Treap::node *x, Treap::node *y) &#123; if (x == nullptr) return y; if (y == nullptr) return x; if (x-&gt;key &gt; y-&gt;key) &#123; x-&gt;right = merge(x-&gt;right, y); x-&gt;pushup(); return x; &#125; y-&gt;left = merge(x, y-&gt;left); y-&gt;pushup(); return y; &#125; Treap::node *Treap::find(Treap::node *p, int val) &#123; if (p == nullptr) return nullptr; if (p-&gt;val == val) return p; if (p-&gt;val &gt; val) return find(p-&gt;left, val); return find(p-&gt;right, val); &#125; void Treap::insert(int val) &#123; auto o = splitByValue(root, val); o.first = merge(o.first, new Treap::node(val)); root = merge(o.first, o.second); &#125; void Treap::erase(int val) &#123; auto o = splitByValue(root, val); auto t = o; if (find(o.second, val) != nullptr) &#123; t = split(o.second, 1); delete t.first; &#125; root = merge(o.first, t.second); &#125; int Treap::getRank(int val) &#123; auto x = splitByValue(root, val); int r = getNodeSize(x.first) + 1; root = merge(x.first, x.second); return r; &#125; int Treap::getKth(int k) &#123; auto x = split(root, k - 1); auto y = split(x.second, 1); Treap::node *o = y.first; root = merge(x.first, merge(y.first, y.second)); return o == nullptr ? 0 : o-&gt;val; &#125;// Definition const int N = 100005; class Treap &#123; private: int root, cnt; struct node &#123; int l, r, s, v, k; node(); node(int); &#125; tr[N]; void pushup(int); std::pair&lt;int, int&gt; split(int, int); std::pair&lt;int, int&gt; splitByValue(int, int); int merge(int, int); int find(int, int); public: void insert(int); void erase(int); int getRank(int); int getKth(int); &#125; tree; // === Treap === // struct Treap::node Treap::node::node() : l(0), r(0), s(0), v(0), k(rand()) &#123;&#125; Treap::node::node(int _v) : l(0), r(0), s(1), v(_v), k(rand()) &#123;&#125; // class Treap inline void Treap::pushup(int u) &#123; tr[u].s = tr[tr[u].l].s + tr[tr[u].r].s + 1; &#125; std::pair&lt;int, int&gt; Treap::split(int p, int k) &#123; if (!p) return std::make_pair(0, 0); if (k &lt;= tr[tr[p].l].s) &#123; auto o = split(tr[p].l, k); tr[p].l = o.second; pushup(p); o.second = p; return o; &#125; auto o = split(tr[p].r, k - tr[tr[p].l].s - 1); tr[p].r = o.first; pushup(p); o.first = p; return o; &#125; std::pair&lt;int, int&gt; Treap::splitByValue(int p, int v) &#123; if (!p) return std::make_pair(0, 0); if (tr[p].v &lt; v) &#123; auto o = splitByValue(tr[p].r, v); tr[p].r = o.first; pushup(p); o.first = p; return o; &#125; auto o = splitByValue(tr[p].l, v); tr[p].l = o.second; pushup(p); o.second = p; return o; &#125; int Treap::merge(int x, int y) &#123; if (!x) return y; if (!y) return x; if (tr[x].k &gt; tr[y].k) &#123; tr[x].r = merge(tr[x].r, y); pushup(x); return x; &#125; tr[y].l = merge(x, tr[y].l); pushup(y); return y; &#125; int Treap::find(int p, int v) &#123; if (!p) return 0; if (tr[p].v == v) return p; if (tr[p].v &gt; v) return find(tr[p].l, v); return find(tr[p].r, v); &#125; void Treap::insert(int v) &#123; auto o = splitByValue(root, v); int p = ++cnt; tr[p] = Treap::node(v); o.first = merge(o.first, p); root = merge(o.first, o.second); &#125; void Treap::erase(int v) &#123; auto o = splitByValue(root, v); auto t = o; if (find(o.second, v)) &#123; t = split(o.second, 1); &#125; root = merge(o.first, t.second); &#125; int Treap::getRank(int v) &#123; auto x = splitByValue(root, v); int r = tr[x.first].s; root = merge(x.first, x.second); return ++r; &#125; int Treap::getKth(int k) &#123; auto x = split(root, k - 1); auto y = split(x.second, 1); int o = y.first; root = merge(x.first, merge(y.first, y.second)); return tr[o].v; &#125; 技巧 求数 x 的前驱 // Treap tree; int prev = tree.getKth(tree.getRank(x) - 1); 求数 x 的后继 // Treap tree; int next = tree.getKth(tree.getRank(x + 1)); 参考资料 谈谈各种数据结构（文件存档备份），范浩强，WC2012。 Treap，OI Wiki，2022 年 2 月 7 日。 某科学的无旋 Treap（FHQ-Treap），星夜，2021 年 1 月 25 日。 "},{"title":"S2OJ - 1256. 牧场","date":"2022-02-13T11:24:09.000Z","url":"/s2oj-1256/","tags":["S2OJ","线段树","扫描线"],"categories":["题解"],"content":" 题面 题目描述 小 L 准备建一个牧场在里面放羊。他指定了一些他想围住的矩形草坪。他想知道把这些草坪围起来需要多长的栏杆。 例如，选取图一的草坪，栏杆将围成图二的样子。 ▲ 图 1 ▲ 图 2 输入格式 输入文件的第一行是一个整数 n，表示有多少个矩形。 接下来 n 行给出了每一个矩形左下角坐标 sx​,sy​ 和右上角坐标 tx​,ty​。 输出格式 一个正整数，表示所有矩形的周长 输入输出样例 样例输入 #1 7 -15 0 5 10 -5 8 20 25 15 -4 24 14 0 -6 16 4 2 15 10 22 30 10 36 20 34 0 40 16 样例输出 #1 228 数据范围与约定 数据点 n 特殊性质 时间限制 1 =1 无 1s 2 =2 3 ≤10 4 ≤100 0≤所有坐标≤1000 5 ≤2000 6 无 7 ≤5000 8 ≤50000 0≤所有坐标≤1000 1.5s 9 无 10 ≤200000 对于 100% 的数据，满足 1≤n≤2×105, −105≤sx​,sy​,tx​,ty​≤105。 思路 很容易想到可以在横向和纵向上各使用一次扫描线来计算周长。 可以发现增加一条边后会引起总和改变，总和的改变量就是新增的边长，而没改变的部分则是被已存在图形覆盖掉的，无需统计。 最后将横向上的边长和与纵向上的边长和相加即为图形总周长。 代码 #pragma GCC optimize(&quot;Ofast&quot;) #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; const int N = 2e5 + 5; int n; long long ans; std::vector&lt;int&gt; ys; template &lt;typename T&gt; void read(T&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; while (!isdigit(ch)) &#123; if (ch == &#x27;-&#x27;) f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - &#x27;0&#x27;; ch = getchar(); &#125; x *= f; &#125; struct segment &#123; int x, y1, y2, k; segment() : x(0), y1(0), y2(0), k(0) &#123;&#125; segment(int _x, int _y1, int _y2, int _k) : x(_x), y1(_y1), y2(_y2), k(_k) &#123;&#125; bool operator&lt;(const segment&amp; b) const &#123; return x == b.x ? k &gt; b.k : x &lt; b.x; &#125; &#125; seg[N &lt;&lt; 1]; struct rectangle &#123; int x1, y1, x2, y2; &#125; q[N]; struct node &#123; int l, r; long long cnt, len; node() : l(0), r(0), cnt(0), len(0) &#123;&#125; node(int _l, int _r) : l(_l), r(_r), cnt(0), len(0) &#123;&#125; &#125; tr[N &lt;&lt; 3]; inline int find(int y) &#123; return std::lower_bound(ys.begin(), ys.end(), y) - ys.begin(); &#125; inline void pushup(int u) &#123; if (tr[u].cnt) &#123; tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l]; &#125; else if (tr[u].l != tr[u].r) &#123; tr[u].len = tr[u &lt;&lt; 1].len + tr[u &lt;&lt; 1 | 1].len; &#125; else &#123; tr[u].len = 0; &#125; &#125; void build(int u, int l, int r) &#123; tr[u] = node(l, r); if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); &#125; void modify(int u, int l, int r, int x) &#123; if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) &#123; tr[u].cnt += x; &#125; else &#123; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, x); if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, x); &#125; pushup(u); &#125; void solve() &#123; std::sort(ys.begin(), ys.end()); std::sort(seg, seg + n * 2); ys.erase(std::unique(ys.begin(), ys.end()), ys.end()); build(1, 0, ys.size() - 2); for (int i = 0; i &lt; n * 2; i++) &#123; int last = tr[1].len; if (seg[i].y1 == seg[i].y2) continue; modify(1, find(seg[i].y1), find(seg[i].y2) - 1, seg[i].k); ans += abs(tr[1].len - last); &#125; ys.clear(); &#125; int main() &#123; read(n); for (int i = 0; i &lt; n; i++) &#123; read(q[i].x1), read(q[i].y1), read(q[i].x2), read(q[i].y2); &#125; for (int i = 0, j = 0; i &lt; n; i++) &#123; seg[j++] = segment(q[i].x1, q[i].y1, q[i].y2, 1); seg[j++] = segment(q[i].x2, q[i].y1, q[i].y2, -1); ys.push_back(q[i].y1); ys.push_back(q[i].y2); &#125; solve(); for (int i = 0, j = 0; i &lt; n; i++) &#123; seg[j++] = segment(q[i].y1, q[i].x1, q[i].x2, 1); seg[j++] = segment(q[i].y2, q[i].x1, q[i].x2, -1); ys.push_back(q[i].x1); ys.push_back(q[i].x2); &#125; solve(); printf(&quot;%lld\\n&quot;, ans); return 0; &#125; "},{"title":"S2OJ - 1238. Simple","date":"2022-02-11T01:00:23.000Z","url":"/s2oj-1238/","tags":["数学","S2OJ"],"categories":["题解"],"content":" 题面 题目描述 对于给定正整数 n,m，我们称正整数 c 为好的，当且仅当存在非负整数 x,y，使得 nx+my=c。 现在给出 T 组数据，对于每组数据，给定 n,m,q，求 [1,q] 内有多少个正整数不是好的。 输入格式 第一行，一个整数 T 表示数据组数。 接下来每行三个数，分别表示 n,m,q，即一组询问。 输出格式 对于每组数据，输出一行表示答案。 输入输出样例 输入样例 #1 2 78 100 4 70 3 34 输出样例 #1 4 23 数据范围及约定 对于 30% 的数据，n,m,q≤100； 对于 60% 的数据，n,m,q≤105； 对于 100% 的数据，n≤105,m≤109,q≤1018,T≤10。 思路 先考虑将 nx+my=c 中的 x,y 单独提出来，得到下面两个式子： x=nc−my​(1) y=mc−nx​(2) 可以考虑枚举 x,y 之中的任意一个数，根据 (1) 式或 (2) 式计算出对应 y,x 的值。 通过数据范围可以发现，当使用 (2) 式计算时会超时。 再通过暴力打表（程序见文末）可以发现一个规律：c 在到达 lcm(n,m) 时会重复，那么只需枚举 y 到 min(lcm(n,m),q)/m 即可。 最后输出时需要去掉 x=0,y=0 的情况，将 ans−1 即可。 代码 AC 代码 #include &lt;algorithm&gt; #include &lt;iostream&gt; using std::cin; using std::cout; #define endl &#x27;\\n&#x27; int t, n, m; long long q; inline long long lcm(int a, int b) &#123; return 1ll * a * b / std::__gcd(a, b); &#125; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; t; while (t--) &#123; long long ans = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (long long y = 0; y &lt;= std::min(lcm(n, m) - 1, q) / m; y++) &#123; ans += (q - y * m) / n + 1; &#125; cout &lt;&lt; q - ans + 1 &lt;&lt; endl; &#125; return 0; &#125; 暴力（60 分） #include &lt;iostream&gt; #include &lt;set&gt; using std::cin; using std::cout; #define endl &#x27;\\n&#x27; int t, n, m, q; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; t; while (t--) &#123; int ans = 0; std::set&lt;int&gt; set; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 0; i * n &lt;= q; i++) &#123; for (int j = 0; i * n + j * m &lt;= q; j++) &#123; if (i * n + j * m &lt;= q) &#123; set.insert(i * n + j * m); &#125; &#125; &#125; cout &lt;&lt; q - set.size() + 1 &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"S2OJ - 1230. 小奇的数列","date":"2022-01-21T09:05:39.000Z","url":"/s2oj-1230/","tags":["数学","S2OJ"],"categories":["题解"],"content":" 题面 题目描述 小奇总是在数学课上思考奇怪的问题。 给定一个长度为 n 的数列，以及 m 次询问，每次给出三个数 l，r 和 p，询问 (al′​+al′+1​+⋯+ar′​)(modp) 的最小值（其中 l≤l′≤r′≤r）。 即模意义下的区间子串和最小值。 输入格式 第一行包含两个正整数 n 和 m，表示数列的长度和询问的个数。 第二行包含 n 个整数 a1​,…,an​。 接下来 m 行，每行三个数 l，r 和 p，代表一次询问。 输出格式 对于每次询问，输出一行一个整数表示要求的结果。 输入输出样例 输入样例 #1 4 2 8 15 9 9 1 3 10 1 4 17 输出样例 #1 2 1 数据范围及约定 对于 20% 的数据，n≤100,m≤100,p≤200； 对于 40% 的数据，n≤200,m≤1000,p≤500； 对于 70% 的数据，n≤100000,m≤10000,p≤200； 对于 100% 的数据，n≤500000,m≤10000,p≤500,1≤ai​≤109。 思路 20 分 对于每个询问，在区间内暴力枚举子串求和、取模即可。复杂度为 O(mn3)。 40 分 考虑在 20 分做法的基础上优化。不难发现，区间求和可以使用前缀和优化。复杂度为 O(mn2)。 70 分 通过 抽屉原理 可知，当询问的区间长度大于等于 p 时（即 r−l≥p 时），一定有两个前缀和相减等于 0，此时直接输出 0 即可。 再考虑枚举 r，可知当 k 是 sumr​ 的前驱时 sumr​−k 最小。时间复杂度为 O(mp2)。 100 分 使用 std::set 维护前驱即可。时间复杂度为 O(mplogp)。 代码 40 分 #include &lt;iostream&gt; using std::cin; using std::cout; using std::endl; const int N = 100005; int n, m, l, r, p, a[N]; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; while (m--) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; p; int ans = p; for (int i = l; i &lt;= r; i++) &#123; int sum = 0; for (int j = i; j &lt;= r; j++) &#123; sum = (sum + a[j]) % p; ans = std::min(ans, sum); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; 70 分 OJ 上的数据比较水，所以这样也能 A 掉。 提交记录：0616685 #include &lt;cstring&gt; #include &lt;iostream&gt; using std::cin; using std::cout; using std::endl; const int N = 500005; const int P = 505; int n, m, l, r, p, a[N]; long long sum[N]; bool vis[P]; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; while (m--) &#123; long long ans = 0x3f3f3f3f; memset(vis, 0x00, sizeof(vis)); vis[0] = true; cin &gt;&gt; l &gt;&gt; r &gt;&gt; p; if (r - l &gt;= p) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; sum[l - 1] = 0; for (int i = l; i &lt;= r; i++) &#123; sum[i] = (sum[i - 1] + a[i]) % p; for (int j = sum[i]; j &gt;= 0; j--) &#123; if (vis[j]) &#123; ans = std::min(ans, sum[i] - j); &#125; &#125; vis[sum[i]] = true; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; 100 分 提交记录：d5b8f54 #include &lt;iostream&gt; #include &lt;set&gt; using std::cin; using std::cout; using std::endl; const int N = 500005; int n, m, l, r, p, a[N]; long long sum[N]; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; while (m--) &#123; long long ans = 0x3f3f3f3f; cin &gt;&gt; l &gt;&gt; r &gt;&gt; p; if (r - l &gt;= p) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; std::set&lt;long long&gt; s; s.insert(0); sum[l - 1] = 0; for (int i = l; i &lt;= r; i++) &#123; sum[i] = (sum[i - 1] + a[i]) % p; ans = std::min(ans, sum[i] - *(--s.upper_bound(sum[i]))); s.insert(sum[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"LibreOJ - 2759. 飞天鼠","date":"2022-01-16T19:57:47.000Z","url":"/libreoj-2759/","tags":["图论","2014","S2OJ","LibreOJ","JOI","最短路","Dijkstra"],"categories":["题解"],"content":" 本题有多个提交渠道： LibreOJ #2759 (ff4a803) S2OJ #1266 (5ddfd92) 题面 题目描述 译自 JOI 2014 Final T4「フクロモモンガ」 飞天鼠 JOI 君住着的森林里长着编号为 1 到 N 的 N 棵桉树。第 i 棵树的高度是 Hi​ 米。 JOI 君能在其中的 M 对桉树之间直接飞行，在各对树木之间飞行所需的时间是固定的。当 JOI 君在树木之间飞行的时候，他离地面的高度会每秒下降 1 米。也就是说，如果 JOI 君现在离地高度是 h 米，在树木之间飞行需要 t 秒，那么飞行之后的离地高度就会变成 h−t 米。当 h−t 小于 0 或大于目标树木的高度时则不能飞行。 JOI 君还能沿着树的侧面上下移动，使得他的离地高度在 0 到当前所在树木高度的范围内变化。JOI 君每使自己的离地高度增加或减少 1 米都需要 1 秒的时间。 JOI 君要从 1 号树木上高度为 X 米的位置出发，到树木 N 的顶端（高度为 HN​ 米的位置）去。他想知道为了达成这个目标所需时间的最小值。 给出各棵树木的高度、JOI 君能直接飞行的树木对和 JOI 君最初所在位置的高度，请求出到达树木 N 顶端所需时间的最小值。 输入格式 第一行包含三个以空格分开的整数 N,M 和 X，意义分别与题目描述中的 N,M 和 X 相同。 接下来 N 行中，第 i(1≤i≤N) 行有一个整数 Hi​，表示树木i的高度是 Hi​ 米。 接下来 M 行中，第 j(1≤j≤M) 行有三个以空格分开的整数 Aj​,Bj​,Tj​ (1≤Aj​,Bj​≤N, Aj​=Bj​)，表示 IOI 君能花 Tj​ 秒的时间从 Aj​ 飞到 Bj​ 或从 Bj​ 飞到 Aj​。 对于任意 1≤j&lt;k≤M，满足 (Aj​,Bj​)=(Ak​,Bk​) 且 (Aj​,Bj​)=(Bk​,Ak​)。 输出格式 输出到标准输出，仅一行一个整数，表示从树木 1 上高度为 X 米处移动到树木 N 顶端所需时间的最小值（单位：秒）。如果不能到达目的地则输出 −1。 输入输出样例 样例输入 #1 5 5 0 50 100 25 30 10 1 2 10 2 5 50 2 4 20 4 3 1 5 4 20 样例输出 #1 110 样例解释 #1 下列是其中一种最优解： 沿着树木 1 向上爬 50 米。 从树木 1 飞到树木 2。 从树木 2 飞到树木 4。 从树木 4 飞到树木 5。 沿着树木 5 向上爬 10 米。 样例输入 #2 2 1 0 1 1 1 2 100 样例输出 #2 -1 样例输出 #2 JOI 君无法从树木 1 飞到树木 2。 样例输入 #3 4 3 30 50 10 20 50 1 2 10 2 3 10 3 4 10 样例输出 #3 100 数据范围与约定 本题采用 Subtask 方式评测。 子任务编号 分值 数据范围 特殊性质 1 25 分 N≤1000M≤3000Hi​≤100Tj​≤100 无 2 25 分 2≤N≤1000001≤M≤3000001≤Hi​≤1091≤Tj​≤109 X=0 3 50 分 2≤N≤1000001≤M≤3000001≤Hi​≤1091≤Tj​≤109 无 表格中的 Hi​,Tj​ 满足：1≤i≤N,1≤j≤M。 所有数据满足 0≤X≤H1​。 思路 可以使用最短路算法解决本题。 对于每条边，会有以下几种情况： 到达点的高度大于树顶高度。 需要先向下爬到高度为 hv​+w 的点才能从该边飞过，可以证明这是最优选择。 在飞行途中落地。 这种情况又细分为两种情况： 从树顶开始飞行时，无法到达终点。 此种情况在加边时即可判定并丢弃这条边。 从树上某点开始飞行时，无法到达终点。 处理完上一种情况以后，树上一定存在一个高度，使得从该高度开始正好可以飞到下一个点的 0 米高处。 容易证明，先下降到高度为 w 的点再飞过该边是最优选择。 能正常飞到终点。 正常计算即可。 本题答案大小可能会超出 int 上界，因此需要使用 long long 存储。 代码 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; using std::cin; using std::cout; using std::endl; const int N = 100005; int n, m, x, h[N], nh[N]; std::vector&lt;std::pair&lt;int, long long&gt;&gt; g[N]; // Dijkstra - Shortest Path long long dist[N]; bool vis[N]; void dijkstra() &#123; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; std::priority_queue&lt;std::pair&lt;long long, int&gt;, std::vector&lt;std::pair&lt;long long, int&gt;&gt;, std::greater&lt;std::pair&lt;long long, int&gt;&gt;&gt; q; q.push(std::make_pair(0, 1)); nh[1] = x; while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = true; for (auto e : g[u]) &#123; int v = e.first; long long w = e.second; if (nh[u] - w &gt; h[v]) &#123; // 到达点的高度大于树顶高度 if (dist[v] &gt; dist[u] + nh[u] - h[v]) &#123; dist[v] = dist[u] + nh[u] - h[v]; nh[v] = h[v]; q.push(std::make_pair(dist[v], v)); &#125; &#125; else if (nh[u] - w &lt; 0) &#123; // 飞行中途会落地 if (dist[v] &gt; dist[u] + w - (nh[u] - w)) &#123; dist[v] = dist[u] + w - (nh[u] - w); nh[v] = 0; q.push(std::make_pair(dist[v], v)); &#125; &#125; else if (dist[v] &gt; dist[u] + w) &#123; // 其他情况 dist[v] = dist[u] + w; nh[v] = nh[u] - w; q.push(std::make_pair(dist[v], v)); &#125; &#125; &#125; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; h[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; int u, v; long long w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; // 保证飞行中途不落地 if (w &lt;= h[u]) g[u].push_back(std::make_pair(v, w)); if (w &lt;= h[v]) g[v].push_back(std::make_pair(u, w)); &#125; dijkstra(); cout &lt;&lt; (dist[n] == 0x3f3f3f3f3f3f3f3f ? -1 : dist[n] + h[n] - nh[n]) &lt;&lt; endl; return 0; &#125; "},{"title":"有向图的强连通分量","date":"2021-12-31T14:49:28.000Z","url":"/scc/","tags":["图论","Tarjan","强连通分量"],"categories":["笔记"],"content":" 定义 强连通的定义是：对于一个有向图 G 中任意一对节点 u 和 v 可以互相到达。 强连通分量的定义是：极大强连通子图。 在上面的定义中，我们称一个强连通子图 G′=(V′,E′)「极大」（其中 V′∈V,E′∈E），是指不存在包含 G′ 的更大的子图 G′′=(V′′,E′′)，满足 V′⊆V′′⊆V,E′⊆E′′⊆E，并且 G′′ 也是强连通子图。 DFS 生成树 在介绍 Tarjan 算法之前，需要先了解一下 DFS 生成树。 给定一个有向图 G=(V,E)，若存在 r∈V，满足从 r 出发能够到达 V 中的所有点，则称 G 是一个流图（Flow Graph），记为 (G,r)，其中 r 称为流图 G 的源点。 在一个流图 (G,r) 上从 r 出发进行深度优先遍历，每个点只访问一次。所有发生递归的边 x→y 构成一棵以 r 为根的树，我们称它为流图 (G,r) 的 DFS 生成树。 有向图的 DFS 生成树有四种边，以下面这个有向图为例： 树枝边：示意图中以黑色边表示（如 2→3），它是在搜索时访问到了一个还没有访问过的节点时形成的。 前向边：示意图中以绿色边表示（如 3→6），它是在搜索时遇到子树中的节点的时候形成的。 后向边：示意图中以红色边表示（如 7→1），它是在搜索时遇到祖先节点时形成的。 横叉边：示意图中以蓝色边表示（如 9→7），它是在搜索时遇到了一个已经访问过的且不是当前节点的祖先的结点时形成的。 不同书籍介绍的这四种边的名称可能不同，但定义内容基本上是一样的。 此外，在 DFS 过程中，按照每个节点第一次被访问的时间顺序，依次给流图中 n 个节点 1 n 的整数标记，该标记被称为 DFS 序（也被称为时间戳），记作 dfn。上图中节点的圆圈内的数字便是该节点的 DFS 序。 Tarjan 算法 Tarjan 发明了许多算法。本文中的「Tarjan 算法」指的是由 Tarjan 发明的在有向图中强连通分量的算法。 提示：请勿混淆 边 与 路径 的概念。 实现 一个环一定是强连通图。如果图中既存在从 x 到 y 的路径（不仅仅是边），又存在从 y 到 x 的边，那么 x,y 显然在一个环中。因此，Tarjan 算法的基本思路就是对于每个点，尽量找到与它一起能够构成环的所有节点。 容易发现，从 x 到 y 的前向边并没有什么用处，因为 DFS 生成树上本来就存在从 x 到 y 的路径。从 x 到 y 的后向边非常有用，因为它可以和 DFS 生成树上从 y 到 x 的路径一起构成环。从 x 到 y 的横向边需要视情况而定，如果从 y 出发能找到一条路径回到 x 的祖先节点，那么这条边也是有用的，可以成为环的一部分。 为了找到通过后向边和横叉边构成的环，Tarjan 算法需要在 DFS 的同时维护一个栈。当访问到节点 x 时，栈中需要保存以下两类节点： DFS 生成树上 x 的祖先节点，记为集合 A(x)。 设 y∈A(x)，若存在后向边 x→y，则 x→y 与从 y 到 x 的路径一起形成环。 已经访问过，并且存在一条路径能够到达 A(x) 中的节点。 设节点 z 符合该要求，从 z 出发存在一条路径能到达 y∈A(x)，若存在横叉边 x→z，则这条边和从 z 到 y 的路径还有从 y 到 x 的路径可以共同形成一个环。 综上所述，栈中的节点就是能与从 x 出发的后向边和横叉边形成环的节点。 追溯值 设 S(x) 表示流图的 DFS 生成树中以 x 为根的子树。x 的追溯值 lowx​ 定义为满足以下条件的节点的最小时间戳。 该点在栈中。 存在一条从 S(x) 中出发的有向边以该点为终点。 根据定义，Tarjan 算法按照以下步骤计算追溯值： 当节点 x 第一次被访问时，将 x 入栈，初始化 lowx​=dfnx​。 扫描从 x 出发的每一条边 x→y。 若 y 从未被访问过，则说明 x→y 是树枝边，递归访问 y，从 y 回溯后，令 lowx​=min(lowx​,lowy​)。 若 y 被访问过且 y 在栈中，则令 lowx​=min(lowx​,dfny​)。 在 x 回溯之前，判断是否有 lowx​=dfnx​ 成立。若成立，则不断从栈中弹出节点，直至 x 出栈。 判定强连通分量 在追溯值的计算过程中，若从 x 回溯前有 lowx​=dfnx​ 成立，则栈中从 x 到栈顶的所有节点均在同一个强连通分量中。 此处不作证明，有兴趣的读者可以自行查找相关论文与书籍。 实现 说明请见代码注释。 int cnt, // 搜索过的节点个数 dfn[N], // 每个点的 DFS 序 low[N]; // 每个点的追溯值 int scc_cnt, // 强连通分量个数 id[N], // 每个点对应的强连通分量编号 siz[N]; // 每个强连通分量的节点数 bool vis[N]; // 节点是否在栈内 std::stack&lt;int&gt; st; void tarjan(int u) &#123; dfn[u] = low[u] = ++cnt; st.push(u); vis[u] = true; for (int v : g[u]) &#123; if (!dfn[v]) &#123; // 未被访问过 tarjan(v); low[u] = std::min(low[u], low[v]); &#125; else if (vis[v]) &#123; // 被访问过且在栈中 low[u] = std::min(low[u], dfn[v]); &#125; &#125; if (dfn[u] == low[u]) &#123; scc_cnt++; // 强连通分量的个数加一 int v; do &#123; v = st.top(); st.pop(); // 出栈 vis[v] = false; // 取消标记 siz[scc_cnt]++; // 当前强连通分量的大小加一 &#125; while (v != u); // 循环到节点 x &#125; &#125; 例题及代码 对应题目：洛谷 - P3387 【模板】缩点 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;vector&gt; using std::cin; using std::cout; using std::endl; // Limits const int N = 10005; int n, m, u, v, a[N]; std::vector&lt;int&gt; g[N], g2[N]; // Tarjan int cnt, dfn[N], low[N]; int scc_cnt, id[N]; int w[N]; bool vis[N]; std::stack&lt;int&gt; st; void tarjan(int u) &#123; dfn[u] = low[u] = ++cnt; vis[u] = true; st.push(u); for (int v : g[u]) &#123; if (!dfn[v]) &#123; tarjan(v); low[u] = std::min(low[u], low[v]); &#125; else if (vis[v]) &#123; low[u] = std::min(low[u], dfn[v]); &#125; &#125; if (low[u] == dfn[u]) &#123; scc_cnt++; int v; do &#123; v = st.top(); st.pop(); vis[v] = false; id[v] = scc_cnt; w[scc_cnt] += a[v]; &#125; while (v != u); &#125; &#125; // Shortest Path int dist[N]; int spfa(int s) &#123; memset(dist, -0x3f, sizeof(dist)); std::queue&lt;int&gt; q; q.push(s); dist[s] = 0; int res = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); res = std::max(res, dist[u] + w[u]); for (int v : g2[u]) &#123; if (dist[v] &lt; dist[u] + w[u]) &#123; dist[v] = dist[u] + w[u]; q.push(v); &#125; &#125; &#125; return res; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; tarjan(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int v : g[i]) &#123; if (id[i] != id[v]) &#123; g2[id[i]].push_back(id[v]); &#125; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= scc_cnt; i++) &#123; ans = std::max(ans, spfa(i)); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 参考资料 22.5 强连通分量，《算法导论》中译本（ISBN 978-7-111-40701-0，机械工业出版社），2013 年 1 月第三版。 0x67 Tarjan 算法与有向图连接性，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 连通：有向图，图论：相关概念，OI Wiki，2021 年 8 月 23 日。 强连通分量，图论，OI Wiki，2021 年 11 月 8 日。 3.7 有向图的强连通分量，AcWing 算法提高课，闫学灿，2019 年 11 月 30 日。 本文图片由 OI Wiki 提供，在此对图片作者表示感谢。 "},{"title":"S2OJ - 1199. 90 岁的张哥哥","date":"2021-12-27T20:34:16.000Z","url":"/s2oj-1199/","tags":["S2OJ","线段树","模拟","栈"],"categories":["题解"],"content":"本题是 洛谷 - P1750 出栈序列 的加强版。 题面 题目背景 90 岁的张哥哥躺在床上，奄奄一息，No enemy 和小叶子在两旁伺候。 ck 赶来：「lzl 块状链表调不出来，你去帮他 debug 吧。」 张哥哥：「老了，让这蒟蒻自己去调。」 风雪山神猫的林教头的林妹妹赶来（好像有什么不和谐的东西乱入了）：「后宫『着火了』又！」 张哥哥：「老了，没力气了，我相信你能搞定的。」 这时，张哥哥的手机铃声「星空使者」响起，电话那头是镕昊和克凡：「我们在 ACM 的现场，发现栈不会写……」话音未落，张哥哥腾得一声跳了起来，容光焕发：「什么？！栈都不会写，放着我来！」 这件事情告诉我们，栈，是张哥哥生前最喜欢的数据结构（与事实不符别怪我）。 题目描述 我们知道，给定一个由 N 个元素构成的序列，将其中的元素按顺序压入一个大小为 C 的栈并弹出。元素按它们的出栈顺序进行排列，会得到一个新的序列。这样的序列可能会有很多种，请输出所有新序列中第一个元素最小的序列（若第一个元素最小的序列有多个，则令第二个尽可能小；若仍有多个，则令第三个最小，以此类推）。 输入格式 第一行两个正整数 N,C。 第二行 N 个整数，表示将顺序入栈的元素的值。 输出格式 仅一行，即满足要求的序列。 输入输出样例 样例输入 #1 3 2 5 3 2 样例输出 #1 3 2 5 样例说明 #1 因为栈的大小为 2，所以 2 3 5 尽管是最小的序列，但是是不合法的。正确的做法是先将 5、3 压入栈中，弹出 3，压入 2，弹出 2，弹出 5 数据规模与约定 对于 40% 的数据，n≤12； 对于 70% 的数据，n≤10000； 对于 100% 的数据，c≤n≤300000，元素大小均在 2×109 以内。 思路 70 分 考虑贪心。 设定两个指针 l,r，初始值为 1 和 C。 循环 n 次，每次找出 [l,r] 区间中未被标记的最小的数并输出、标记，然后将 l 跳到前一个未被标记的数，r 增加 1。 可以证明这个贪心是正确的。 100 分 使用线段树维护区间最小值可以将区间最值的查询从 O(n) 降至 O(logn)。 使用栈模拟实际操作可以省去标记已入栈的数，需要遵循以下几点注意事项： 入栈时需要将当前区间内的最小值前的所有未入栈元素入栈。 确保栈内元素数量不超过栈容量。 弹出栈顶元素后从栈顶元素的后一个元素开始执行上述过程。 代码 70 分代码 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;limits&gt; using std::cin; using std::cout; using std::endl; const int N = 300005; int n, c, l, r, a[N]; bool vis[N]; int main() &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; c; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; l = 1, r = c; for (int i = 1; i &lt;= n; i++) &#123; int p = std::min_element(a + l, a + r + 1) - a; cout &lt;&lt; a[p] &lt;&lt; &#x27; &#x27;; vis[p] = true; a[p] = std::numeric_limits&lt;int&gt;::max(); while (p &amp;&amp; vis[p]) p--; l = std::max(p, 1); r = std::min(r + 1, n); &#125; cout &lt;&lt; endl; return 0; &#125; 100 分代码 #include &lt;iostream&gt; #include &lt;limits&gt; #include &lt;stack&gt; using std::cin; using std::cout; using std::endl; // Limits const int N = 300005; // Variables int a[N]; bool vis[N]; // Segment Tree void build(int, int, int); int query(int, int, int); int main() &#123; std::ios::sync_with_stdio(false); int n, c; cin &gt;&gt; n &gt;&gt; c; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; a[0] = std::numeric_limits&lt;int&gt;::max(); build(1, 1, n); int pos = query(1, 1, c); std::stack&lt;int&gt; st; for (int i = 1; i &lt; pos; i++) &#123; st.push(i); &#125; cout &lt;&lt; a[pos] &lt;&lt; &#x27; &#x27;; for (int i = c + 1; i &lt;= n; i++) &#123; int p = query(1, pos + 1, i); if (!st.empty() &amp;&amp; a[st.top()] &lt;= a[p]) &#123; cout &lt;&lt; a[st.top()] &lt;&lt; &#x27; &#x27;; st.pop(); &#125; else &#123; for (int j = pos + 1; j &lt; p; j++) &#123; st.push(j); &#125; pos = p; cout &lt;&lt; a[p] &lt;&lt; &#x27; &#x27;; &#125; &#125; for (int i = 1; i &lt; c; i++) &#123; int p = pos + 1 &lt;= n ? query(1, pos + 1, n) : 0; if (!st.empty() &amp;&amp; a[st.top()] &lt;= a[p]) &#123; cout &lt;&lt; a[st.top()] &lt;&lt; &#x27; &#x27;; st.pop(); &#125; else &#123; for (int j = pos + 1; j &lt; p; j++) &#123; st.push(j); &#125; pos = p; cout &lt;&lt; a[p] &lt;&lt; &#x27; &#x27;; &#125; &#125; cout &lt;&lt; endl; return 0; &#125; // === Segment Tree === struct node &#123; int l, r, id; node() : l(0), r(0), id(0) &#123;&#125; node(int _l, int _r) : l(_l), r(_r), id(0) &#123;&#125; &#125; tr[N &lt;&lt; 2]; inline void pushup(int u) &#123; tr[u].id = a[tr[u &lt;&lt; 1].id] &lt;= a[tr[u &lt;&lt; 1 | 1].id] ? tr[u &lt;&lt; 1].id : tr[u &lt;&lt; 1 | 1].id; &#125; void build(int u, int l, int r) &#123; tr[u] = node(l, r); if (l == r) &#123; tr[u].id = l; return; &#125; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125; /** * 查询区间 [l, r] 最小值，并返回最小值在 a 数组中对应的**下标** * @param u 根节点坐标 * @param l 区间左端点 * @param r 区间右端点 * @return 最小值在 a 数组中对应的**下标** */ int query(int u, int l, int r) &#123; if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].id; int mid = tr[u].l + tr[u].r &gt;&gt; 1, pos = 0; if (l &lt;= mid) &#123; int t = query(u &lt;&lt; 1, l, r); if (a[t] &lt; a[pos]) pos = t; &#125; if (r &gt; mid) &#123; int t = query(u &lt;&lt; 1 | 1, l, r); if (a[t] &lt; a[pos]) pos = t; &#125; return pos; &#125; "},{"title":"可持久化线段树学习笔记","date":"2021-12-24T21:03:09.000Z","url":"/persistent-segment-tree/","tags":["数据结构","线段树","可持久化线段树"],"categories":["笔记"],"content":"本文讲述的是 可持久化权值线段树 。这种数据结构在普通线段树的基础之上支持查询某个历史版本，同时时间复杂度与线段树是同级，空间复杂度相较而言更高一些。 下文中将以「可持久化线段树」代指「可持久化权值线段树」。 注意：可持久化线段树难以进行区间修改操作，因为进行该操作可能会修改历史信息导致查询出错误结果，或者使用标记永久化避免出现这个问题，该项内容不在本文的讨论范围内。 前置知识 线段树 原理 可持久化线段树维护的是每个节点的历史版本，而最朴素的实现方式是每次进行修改操作都新开一颗线段树，而这样操作带来的时空复杂度是不可接受的。 稍微推导一下可以发现每次修改操作需要修改的节点个数只有 log(n) 个，那么可以使用动态开点并记录历史版本的方式来节约空间和时间的消耗，这就是可持久化线段树。 实现 先进行离散化，以节约存储空间，具体实现不再过多描述。 然后以数值为基础建立权值线段树，维护每个数值区间中一共有多少个数。 node 类型的定义如下： struct node &#123; int l, // 左儿子的数组下标 r, // 右儿子的数组下标 c; // 当前区间中一共有多少个数 node(); // 构造函数 &#125;; 这和 线段树学习笔记 中的定义有一些差别。首先，l 和 r 的存储的信息从左右端点变成了左右儿子的数组下标；其次，区间维护的信息从节点的和差与最值变成了区间中数据的个数。 再来看 build 函数。 int build(int l, int r) &#123; int p = ++cnt; // 新建节点 if (l == r) return p; // 返回节点编号 int mid = l + r &gt;&gt; 1; tr[p].l = build(l, mid); // 左子树 tr[p].r = build(mid + 1, r); // 右子树 return p; // 返回节点编号 &#125; 变化是线段树存储方式从原先的堆变成了动态开点，动态开点线段树可以在网上找到相关学习资料，在此不作过多赘述。 还有 insert 函数： int insert(int p, int l, int r, int x) &#123; int q = ++cnt; // 开点 tr[q] = tr[p]; // 拷贝旧节点 if (l == r) &#123; tr[q].c++; // 增加计数 return q; &#125; int mid = l + r &gt;&gt; 1; if (x &lt;= mid) &#123; tr[q].l = insert(tr[p].l, l, mid, x); // 左子树 &#125; else &#123; tr[q].r = insert(tr[p].r, mid + 1, r, x); // 右子树 &#125; tr[q].c = tr[tr[q].l].c + tr[tr[q].r].c; // 更新计数（内联的 pushup 操作） return q; &#125; 仍然是动态开点，新节点的初始值由 node(l, r) 变成了 tr[p] ，即以第 i−1 个版本为基础，再进行修改。 最后是 query 函数： int query(int q, int p, int l, int r, int k) &#123; if (l == r) return l; // 返回 int c = tr[tr[q].l].c - tr[tr[p].l].c; // 前缀和 int mid = l + r &gt;&gt; 1; if (k &lt;= c) return query(tr[q].l, tr[p].l, l, mid, k); // 查询左子树 return query(tr[q].r, tr[p].r, mid + 1, r, k - c); // 查询右子树 &#125; 通过 tr[tr[q].l].c - tr[tr[p].l].c 获得 [l,r] 区间内数的个数。 注：第 r 号节点的数的个数减去第 l−1 号节点的数的个数即为 [l,r] 中的数的个数，这里使用到了前缀和的思想。 取 [l,mid] 区间的数的个数并记为 cnt，接下来分两种情况： cnt≤k：第 k 小的数在左子树上。 cnt&gt;k：第 k 小的数在右子树上，查询右子树第 k−cnt 小的数。 递归查询即可。 代码 对应题目：洛谷 - P3834 【模板】可持久化线段树 2 8d70723 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using std::cin; using std::cout; using std::endl; const int N = 200005; int n, m, l, r, k, a[N]; std::vector&lt;int&gt; nums; // Helpers int find(int); // Segment Tree int cnt, root[N]; int build(int, int); int insert(int, int, int, int); int query(int, int, int, int, int); int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; nums.push_back(a[i]); &#125; std::sort(nums.begin(), nums.end()); nums.erase(std::unique(nums.begin(), nums.end()), nums.end()); root[0] = build(0, nums.size() - 1); for (int i = 1; i &lt;= n; i++) &#123; root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i])); &#125; while (m--) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] &lt;&lt; endl; &#125; return 0; &#125; // === Helpers === inline int find(int x) &#123; return std::lower_bound(nums.begin(), nums.end(), x) - nums.begin(); &#125; // === Segment Tree === struct node &#123; int l, r, c; node() : l(0), r(0), c(0) &#123;&#125; &#125; tr[N &lt;&lt; 5]; int build(int l, int r) &#123; int p = ++cnt; if (l == r) return p; int mid = l + r &gt;&gt; 1; tr[p].l = build(l, mid); tr[p].r = build(mid + 1, r); return p; &#125; int insert(int p, int l, int r, int x) &#123; int q = ++cnt; tr[q] = tr[p]; if (l == r) &#123; tr[q].c++; return q; &#125; int mid = l + r &gt;&gt; 1; if (x &lt;= mid) &#123; tr[q].l = insert(tr[p].l, l, mid, x); &#125; else &#123; tr[q].r = insert(tr[p].r, mid + 1, r, x); &#125; tr[q].c = tr[tr[q].l].c + tr[tr[q].r].c; return q; &#125; int query(int q, int p, int l, int r, int k) &#123; if (l == r) return l; int c = tr[tr[q].l].c - tr[tr[p].l].c; int mid = l + r &gt;&gt; 1; if (k &lt;= c) return query(tr[q].l, tr[p].l, l, mid, k); return query(tr[q].r, tr[p].r, mid + 1, r, k - c); &#125; 参考资料 第 255 ~ 258 页，0x48 可持久化数据结构，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。 可持久化线段树，OI Wiki，2021 年 12 月 11 日。 可持久化线段树，维基百科，2021 年 10 月 29 日。 4.4 可持久化数据结构，AcWing 算法提高课，闫学灿，2019 年 12 月 28 日。 "},{"title":"LibreOJ - 2130. 软件包管理器","date":"2021-12-05T00:15:28.000Z","url":"/libreoj-2130/","tags":["洛谷","AcWing","线段树","树链剖分","LibreOJ","NOI","2015"],"categories":["题解"],"content":" 题面 题目背景 Linux 用户和 OSX 用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu 使用的 apt-get，Fedora/CentOS 使用的 yum，以及 OSX 下可用的 homebrew 都是优秀的软件包管理器。 题目描述 你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 a 依赖软件包 b，那么安装软件包 a 以前，必须先安装软件包 b。同时，如果想要卸载软件包 b，则必须卸载软件包 a。 现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。且依赖关系不存在环（即不会存在 m 个软件包 a1​,a2​,…,am​，对于 i&lt;m，ai​ 依赖 ai​+1，而 am​ 依赖 a1​ 的情况）。 现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。 注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为 0。 输入格式 第一行一个正整数 n，表示软件包个数，从 0 开始编号。 第二行有 n−1 个整数，第 i 个表示 i 号软件包依赖的软件包编号。 然后一行一个正整数 q，表示操作个数，格式如下： install x 表示安装 x 号软件包 uninstall x 表示卸载 x 号软件包 一开始所有软件包都是未安装的。 对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。 输出格式 输出 q 行，每行一个整数，表示每次询问的答案。 输入输出样例 样例输入 #1 7 0 0 0 1 1 5 5 install 5 install 6 uninstall 1 install 4 uninstall 0 样例输出 #1 3 1 3 2 3 样例解释 #1 一开始所有软件包都处于未安装状态。 安装 5 号软件包，需要安装 0,1,5 三个软件包。 之后安装 6 号软件包，只需要安装 6 号软件包。此时安装了 0,1,5,6 四个软件包。 卸载 1 号软件包需要卸载 1,5,6 三个软件包。此时只有 0 号软件包还处于安装状态。 之后安装 4 号软件包，需要安装 1,4 两个软件包。此时 0,1,4 处在安装状态。最后，卸载 0 号软件包会卸载所有的软件包。 样例输入 #2 10 0 1 2 1 3 0 0 3 2 10 install 0 install 3 uninstall 2 install 7 install 5 install 9 uninstall 9 install 4 install 1 install 9 样例输出 #2 1 3 2 1 3 1 1 1 0 1 数据范围与约定 思路 一道树链剖分模板题。 通过分析可得：每次执行安装操作时，把根节点到软件 X 路径上的值设为 1 ；每次执行卸载操作时，把以 X 为根节点的子树上的所有值设为 0 。 然后题目就转化为了区间和问题，操作前记录下线段树整体的和，操作后再记录一次，两者相减取绝对值即为安装状态被改变了的软件包的数量。 几点注意事项： 线段树区间覆盖的实现：在修改时将 += 改为 = 即可。 懒标记初值不要用 0 ，因为修改的时候会有 0 。 推荐从 1 开始编号，方便维护，避免因编号起始值不同带来的麻烦。 代码 #include &lt;bits/stdc++.h&gt; using std::cin; using std::cout; using std::endl; const int N = 100005; int n, q, a, x; std::string op; std::vector&lt;int&gt; g[N]; // Heavy Path Decomposition int cnt, id[N], fa[N], dep[N], son[N], siz[N], top[N]; void dfs1(int, int); void dfs2(int, int); void modify_path(int, int, int); void modify_tree(int, int); // Segment Tree void pushup(int); void pushdown(int); void build(int, int, int); void modify(int, int, int, int); int query(int, int, int); int main() &#123; cin &gt;&gt; n; for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; x; x++; g[x].push_back(i); g[i].push_back(x); &#125; dfs1(1, 1); dfs2(1, 1); build(1, 1, n); cin &gt;&gt; q; while (q--) &#123; cin &gt;&gt; op &gt;&gt; x; x++; int before = query(1, 1, n); if (op == &quot;install&quot;) &#123; if (!query(1, id[x], id[x])) &#123; modify_path(1, x, 1); &#125; &#125; else &#123; if (query(1, id[x], id[x])) &#123; modify_tree(x, 0); &#125; &#125; int after = query(1, 1, n); cout &lt;&lt; std::abs(before - after) &lt;&lt; endl; &#125; return 0; &#125; // === Heavy Path Decomposition === void dfs1(int u, int f) &#123; dep[u] = dep[f] + 1; fa[u] = f; siz[u] = 1; for (int v : g[u]) &#123; if (v == f) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[son[u]] &lt; siz[v]) son[u] = v; &#125; &#125; void dfs2(int u, int t) &#123; id[u] = ++cnt; top[u] = t; if (!son[u]) return; dfs2(son[u], t); for (int v : g[u]) &#123; if (v == fa[u]) continue; if (v == son[u]) continue; dfs2(v, v); &#125; &#125; void modify_path(int u, int v, int d) &#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) std::swap(u, v); modify(1, id[top[u]], id[u], d); u = fa[top[u]]; &#125; if (dep[u] &lt; dep[v]) std::swap(u, v); modify(1, id[v], id[u], d); &#125; void modify_tree(int u, int d) &#123; modify(1, id[u], id[u] + siz[u] - 1, d); &#125; // === Segment Tree === struct node &#123; int l, r, s, d; node() : l(0), r(0), s(0), d(-1) &#123;&#125; node(int _l, int _r) : l(_l), r(_r), s(0), d(-1) &#123;&#125; &#125; tr[N &lt;&lt; 2]; inline void pushup(int u) &#123; tr[u].s = tr[u &lt;&lt; 1].s + tr[u &lt;&lt; 1 | 1].s; &#125; inline void pushdown(int u) &#123; auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1]; if (root.d == -1) return; left.s = (left.r - left.l + 1) * root.d; left.d = root.d; right.s = (right.r - right.l + 1) * root.d; right.d = root.d; root.d = -1; &#125; void build(int u, int l, int r) &#123; tr[u] = node(l, r); if (l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); &#125; void modify(int u, int l, int r, int d) &#123; if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) &#123; tr[u].s = (tr[u].r - tr[u].l + 1) * d; tr[u].d = d; return; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; pushdown(u); if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, d); if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, d); pushup(u); &#125; int query(int u, int l, int r) &#123; if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].s; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int sum = 0; pushdown(u); if (l &lt;= mid) sum += query(u &lt;&lt; 1, l, r); if (r &gt; mid) sum += query(u &lt;&lt; 1 | 1, l, r); return sum; &#125; "},{"title":"LibreOJ - 2633. 宝藏与维京海盗 Treasures and Vikings","date":"2021-11-19T18:42:14.000Z","url":"/libreoj-2633/","tags":["洛谷","S2OJ","LibreOJ","搜索","BalticOI","2011"],"categories":["题解"],"content":" 题面 本题译自 BalticOI 2011 Day1 T4「Treasures and Vikings」。 题目描述 你有一张藏宝图，藏宝图可视为 N×M 的网格。每个格子可能是你的船、贼船、海、陆地或藏宝点。你只有一条船，整张图只有一条贼船。你和贼船都只能在海域移动。藏宝点在海中。 你与贼船交替移动，你移动一次 + 贼船移动一次算作一回合。每次移动，你可以移动到上下左右四个相邻格子中的一格，也可以不移动。贼船的移动同理，贼船也可以不移动。你先移动。 每一回合结束后，如果你和贼船在同一行或同一列，你就挂了；在你没挂的情况下，如果你位于藏宝点，你就拿到了宝藏。 请问：是否有一条安全的路径，使得无论贼船怎么跑你都能或者拿到宝藏。 输入格式 第一行有两个整数 N 和 M。 在接下来的 N 行中，每行 M 个字符。字符的含义如下： 字符 . I V Y T 含义 海 陆地 贼船 你 藏宝点 保证只会出现表中的五种字符，保证 V, Y, T 都只出现一次。 输出格式 输出 YES 或 NO，表示是否有一条安全的路径。 输入输出样例 样例输入 #1 5 7 Y.....V ..I.... ..IIIII ....... ...T... 样例输出 #1 YES 样例输入 #2 5 7 Y....V. ..I.... ..IIIII ....... ...T... 样例输出 #2 NO 样例输入 #3 2 3 .YT VII 样例输出 #3 NO 数据范围与约定 对于 50% 的数据，1≤N,M≤200 。 对于 100% 的数据，1≤N,M≤700 。 思路 先使用广搜预处理一下贼船到达每个非陆地点的最小时间并存储下来，然后再使用广搜搜一下是否能到 T 点即可。 在第二遍广搜的时候需要注意，如果到达某个点的用时比贼船到达的用时长，那么这条路就是走不通的，不能扩展。 其余信息可以看代码注释. 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int to[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; int n, m, book[705][705]; bool vis[705][705]; char g[705][705]; pair&lt;int, int&gt; y, v, t; struct node &#123; int x, y, step; node() : x(0), y(0), step(0) &#123;&#125; node(int _x, int _y) : x(_x), y(_y), step(0) &#123;&#125; node(pair&lt;int, int&gt; _point) : x(_point.first), y(_point.second), step(0) &#123;&#125; node(pair&lt;int, int&gt; _point, int _step) : x(_point.first), y(_point.second), step(_step) &#123;&#125; node(int _x, int _y, int _step) : x(_x), y(_y), step(_step) &#123;&#125; &#125;; /** * @brief Preprocess the map */ void bfsV() &#123; memset(vis, 0x00, sizeof(vis)); memset(book, 0xff, sizeof(book)); queue&lt;node&gt; q; q.push(v); vis[v.first][v.second] = true; book[v.first][v.second] = 0; while (!q.empty()) &#123; int now; auto u = q.front(); q.pop(); // Top now = u.x - 1; while (now &gt;= 0 &amp;&amp; g[now][u.y] != &#x27;I&#x27;) &#123; if (book[now][u.y] == -1) &#123; book[now][u.y] = u.step; &#125; now--; &#125; // Bottom now = u.x + 1; while (now &lt; n &amp;&amp; g[now][u.y] != &#x27;I&#x27;) &#123; if (book[now][u.y] == -1) &#123; book[now][u.y] = u.step; &#125; now++; &#125; // Left now = u.y - 1; while (now &gt;= 0 &amp;&amp; g[u.x][now] != &#x27;I&#x27;) &#123; if (book[u.x][now] == -1) &#123; book[u.x][now] = u.step; &#125; --now; &#125; // Right now = u.y + 1; while (now &lt; m &amp;&amp; g[u.x][now] != &#x27;I&#x27;) &#123; if (book[u.x][now] == -1) &#123; book[u.x][now] = u.step; &#125; now++; &#125; // Expand for (int i = 0; i &lt; 4; i++) &#123; node e = node(u.x + to[i][0], u.y + to[i][1], u.step + 1); if (e.x &gt;= 0 &amp;&amp; e.x &lt; n &amp;&amp; e.y &gt;= 0 &amp;&amp; e.y &lt; m &amp;&amp; g[e.x][e.y] != &#x27;I&#x27; &amp;&amp; !vis[e.x][e.y]) &#123; vis[e.x][e.y] = true; q.push(e); &#125; &#125; &#125; &#125; /** * @brief Search path to treasure */ void bfsY() &#123; memset(vis, 0x00, sizeof(vis)); queue&lt;node&gt; q; q.push(node(y, 1)); while (!q.empty()) &#123; auto u = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) &#123; node e = node(u.x + to[i][0], u.y + to[i][1], u.step + 1); if (e.x &gt;= 0 &amp;&amp; e.x &lt; n &amp;&amp; e.y &gt;= 0 &amp;&amp; e.y &lt; m &amp;&amp; e.step &lt;= book[e.x][e.y] &amp;&amp; !vis[e.x][e.y]) &#123; vis[e.x][e.y] = true; // Reached if (e.x == t.first &amp;&amp; e.y == t.second) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; return; &#125; // Expand q.push(e); &#125; &#125; &#125; // Can&#x27;t reach treasure cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; int main() &#123; // Read from stdin cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; g[i]; &#125; // Mark you, viking and treasure for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (g[i][j] == &#x27;Y&#x27;) y = make_pair(i, j); if (g[i][j] == &#x27;V&#x27;) v = make_pair(i, j); if (g[i][j] == &#x27;T&#x27;) t = make_pair(i, j); &#125; &#125; bfsV(); bfsY(); return 0; &#125; "},{"title":"CSP-J 2021 题解","date":"2021-11-15T11:45:03.000Z","url":"/csp-j-2021/","tags":["数学","模拟","NOIP","CSP-J","2021"],"categories":["题解"],"content":" 本文篇幅较长，可以通过页面右下角的目录功能快速跳转。 分糖果 题面 题目背景 红太阳幼儿园的小朋友们开始分糖果啦！ 题目描述 红太阳幼儿园有 n 个小朋友，你是其中之一。保证 n≤2 。 有一天你在幼儿园的后花园里发现无穷多颗糖果，你打算拿一些糖果回去分给幼儿园的小朋友们。 由于你只是个平平无奇的幼儿园小朋友，所以你的体力有限，至多只能拿 R 块糖回去。 但是拿的太少不够分的，所以你至少要拿 L 块糖回去。保证 n≤L≤R 。 也就是说，如果你拿了 k 块糖，那么你需要保证 L≤k≤R 。 如果你拿了 k 块糖，你将把这 k 块糖放到篮子里，并要求大家按照如下方案分糖果：只要篮子里有不少于 n 块糖果，幼儿园的所有 n 个小朋友（包括你自己）都从篮子中拿走恰好一块糖，直到篮子里的糖数量少于 n 块。此时篮子里剩余的糖果均归你所有——这些糖果是作为你搬糖果的奖励。 作为幼儿园高质量小朋友，你希望让作为你搬糖果的奖励的糖果数量（而不是你最后获得的总糖果数量！）尽可能多；因此你需要写一个程序，依次输入 n,L,R ，并输出出你最多能获得多少作为你搬糖果的奖励的糖果数量。 输入格式 输入一行，包含三个正整数 n,L,R，分别表示小朋友的个数、糖果数量的下界和上界。 输出格式 输出一行一个整数，表示你最多能获得的作为你搬糖果的奖励的糖果数量。 输入输出样例 样例输入 #1 7 16 23 样例输出 #1 6 样例解释 #1 拿 k=20 块糖放入篮子里。 篮子里现在糖果数 20≥n=7，因此所有小朋友获得一块糖； 篮子里现在糖果数变成 13≥n=7，因此所有小朋友获得一块糖； 篮子里现在糖果数变成 6&lt;n=7，因此这 6 块糖是作为你搬糖果的奖励。 容易发现，你获得的作为你搬糖果的奖励的糖果数量不可能超过 6 块（不然，篮子里的糖果数量最后仍然不少于 n，需要继续每个小朋友拿一块），因此答案是 6。 样例输入 #2 10 14 18 样例输出 #2 8 样例解释 #2 容易发现，当你拿的糖数量 k 满足 14=L≤k≤R=18 时，所有小朋友获得一块糖后，剩下的 k−10 块糖总是作为你搬糖果的奖励的糖果数量，因此拿 k=18 块是最优解，答案是 8。 数据范围与约定 测试点 n≤ R≤ R−L≤ 1 2 5 2 5 10 3 103 4 105 5 103 109 0 6 103 7 105 105 8 109 109 9 10 对于所有数据，保证 2≤n≤L≤R≤109。 思路 此题是一道结论题。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, l, r, ans; int main() &#123; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; cout &lt;&lt; min((int)(ceil(1.0 * l / n) * n + n - 1), r) % n &lt;&lt; endl; return 0; &#125; 网络连接 题面 题目描述 TCP/IP 协议是网络通信领域的一项重要协议。今天你的任务，就是尝试利用这个协议，还原一个简化后的网络连接场景。 在本问题中，计算机分为两大类：服务机（Server）和客户机（Client）。服务机负责建立连接，客户机负责加入连接。 需要进行网络连接的计算机共有 n 台，编号为 1∼n，这些机器将按编号递增的顺序，依次发起一条建立连接或加入连接的操作。 每台机器在尝试建立或加入连接时需要提供一个地址串。服务机提供的地址串表示它尝试建立连接的地址，客户机提供的地址串表示它尝试加入连接的地址。 一个符合规范的地址串应当具有以下特征： 必须形如 a.b.c.d:e 的格式，其中 a,b,c,d,e 均为非负整数； 0≤a,b,c,d≤255 ， 0≤e≤65535； a,b,c,d,e 均不能含有多余的前导 0。 相应地，不符合规范的地址串可能具有以下特征： 不是形如 a.b.c.d:e 格式的字符串，例如含有多于 3 个字符 . 或多于 1 个字符 : 等情况； 整数 a,b,c,d,e 中某一个或多个超出上述范围； 整数 a,b,c,d,e 中某一个或多个含有多余的前导 0。 例如，地址串 192.168.0.255:80 是符合规范的，但 192.168.0.999:80、192.168.00.1:10、192.168.0.1:088、192:168:0:1.233 均是不符合规范的。 如果服务机或客户机在发起操作时提供的地址串不符合规范，这条操作将被直接忽略。 在本问题中，我们假定凡是符合上述规范的地址串均可参与正常的连接，你无需考虑每个地址串的实际意义。 由于网络阻塞等原因，不允许两台服务机使用相同的地址串，如果此类现象发生，后一台尝试建立连接的服务机将会无法成功建立连接；除此之外，凡是提供符合规范的地址串的服务机均可成功建立连接。 如果某台提供符合规范的地址的客户机在尝试加入连接时，与先前某台已经成功建立连接的服务机提供的地址串相同，这台客户机就可以成功加入连接，并称其连接到这台服务机；如果找不到这样的服务机，则认为这台客户机无法成功加入连接。 请注意，尽管不允许两台不同的服务机使用相同的地址串，但多台客户机使用同样的地址串，以及同一台服务机同时被多台客户机连接的情况是被允许的。 你的任务很简单：在给出每台计算机的类型以及地址串之后，判断这台计算机的连接情况。 输入格式 第一行，一个正整数 n。 接下来 n 行，每行两个字符串 op,ad，按照编号从小到大给出每台计算机的类型及地址串。 其中 op 保证为字符串 Server 或 Client 之一，ad 为一个长度不超过 25 的，仅由数字、字符 . 和字符 : 组成的非空字符串。 每行的两个字符串之间用恰好一个空格分隔开，每行的末尾没有多余的空格。 输出格式 输出共 n 行，每行一个正整数或字符串表示第 i 台计算机的连接状态。其中： 如果第 i 台计算机为服务机，则： 如果其提供符合规范的地址串且成功建立连接，输出字符串 OK。 如果其提供符合规范的地址串，但由于先前有相同地址串的服务机而无法成功建立连接，输出字符串 FAIL。 如果其提供的地址串不是符合规范的地址串，输出字符串 ERR。 如果第 i 台计算机为客户机，则： 如果其提供符合规范的地址串且成功加入连接，输出一个正整数表示这台客户机连接到的服务机的编号。 如果其提供符合规范的地址串，但无法成功加入连接时，输出字符串 FAIL。 如果其提供的地址串不是符合规范的地址串，输出字符串 ERR。 输入输出样例 样例输入 #1 5 Server 192.168.1.1:8080 Server 192.168.1.1:8080 Client 192.168.1.1:8080 Client 192.168.1.1:80 Client 192.168.1.1:99999 样例输出 #1 OK FAIL 1 FAIL ERR 样例解释 #1 计算机 1 为服务机，提供符合规范的地址串 192.168.1.1:8080，成功建立连接； 计算机 2 为服务机，提供与计算机 1 相同的地址串，未能成功建立连接； 计算机 3 为客户机，提供符合规范的地址串 192.168.1.1:8080，成功加入连接，并连接到服务机 1； 计算机 4 为客户机，提供符合规范的地址串 192.168.1.1:80，找不到服务机与其连接； 计算机 5 为客户机，提供的地址串 192.168.1.1:99999 不符合规范。 样例输入 #2 10 Server 192.168.1.1:80 Client 192.168.1.1:80 Client 192.168.1.1:8080 Server 192.168.1.1:80 Server 192.168.1.1:8080 Server 192.168.1.999:0 Client 192.168.1.1.8080 Client 192.168.1.1:8080 Client 192.168.1.1:80 Client 192.168.1.999:0 样例输出 #2 OK 1 FAIL FAIL OK ERR ERR 5 1 ERR 数据范围与约定 测试点编号 n≤ 特殊性质 1 10 性质 1 2 3 2∼3 100 4∼5 1000 6∼8 性质 1 2 9∼11 性质 1 12∼13 性质 2 14∼15 性质 4 16∼17 性质 5 18∼20 无特殊性质 性质 1：保证所有的地址串均符合规范； 性质 2：保证对于任意两台不同的计算机，如果它们同为服务机或者同为客户机，则它们提供的地址串一定不同； 性质 3：保证任意一台服务机的编号都小于所有的客户机； 性质 4：保证所有的地址串均形如 a.b.c.d:e 的格式，其中 a,b,c,d,e 均为不超过 109 且不含有多余前导 0 的非负整数； 性质 5：保证所有的地址串均形如 a.b.c.d:e 的格式，其中 a,b,c,d,e 均为只含有数字的非空字符串。 对于 100% 的数据，保证 1≤n≤1000。 思路 细节稍多的模拟题。 先按照题意检查读入的地址串是否合法，如果合法则继续操作，使用 map 记录即可。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n; string op, ad; map&lt;string, int&gt; server; bool check(string s) &#123; int cnt1 = 0, cnt2 = 0, flag = 0; long long now = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27;.&#x27;) &#123; cnt1++; // 统计到了一个 `.` if (cnt2) return 0; // `:` 在 `.` 之前出现不合法 if (i == 0 || s[i - 1] == &#x27;.&#x27;) return false; // `.` 在开头出现或者有两个连续的 `.` if (cnt1 &gt; 3) return false; // 三个以上的 `.` 不合法 if (now &lt; 0 || now &gt; 255) return false; // 不合法的数字 flag = 0; // 清零 now = 0; continue; &#125; if (s[i] == &#x27;:&#x27;) &#123; cnt2++; // 统计到了一个 `:` if (i == s.size() - 1) return false; // 在字符串最后不合法 if (cnt2 &gt; 1) return false; // 多个 `:` 不合法 if (i == 0 || s[i - 1] == &#x27;:&#x27;) return false; // `:` 在开头出现或者有两个连续的 `:` if (now &lt; 0 || now &gt; 255) return false; // 不合法的数字 flag = 0; // 清零 now = 0; continue; &#125; if (s[i] &lt; &#x27;0&#x27; || s[i] &gt; &#x27;9&#x27;) return false; // 不合法的字符 if (s[i] == &#x27;0&#x27; &amp;&amp; flag == 0) flag = 1; // 查到第一个前导零时返回 if (s[i] != &#x27;0&#x27; &amp;&amp; flag == 1) return false; // 重复的前导零 if (s[i] != &#x27;0&#x27;) flag = 2; now = now * 10 + s[i] - &#x27;0&#x27;; &#125; if (cnt1 != 3 || cnt2 != 1) return false; if (now &lt; 0 || now &gt; 65535) return false; // 不合法的端口号 return true; &#125; int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; op &gt;&gt; ad; if (check(ad)) &#123; if (op == &quot;Server&quot;) &#123; if (server.count(ad)) &#123; cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl; &#125; else &#123; server[ad] = i; cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl; &#125; &#125; else &#123; if (server.count(ad)) &#123; cout &lt;&lt; server[ad] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl; &#125; &#125; &#125; else &#123; cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl; &#125; &#125; return 0; &#125; 小熊的果篮 题面 题目描述 小熊的水果店里摆放着一排 n 个水果。每个水果只可能是苹果或桔子，从左到右依次用正整数 1,2,…,n 编号。连续排在一起的同一种水果称为一个“块”。小熊要把这一排水果挑到若干个果篮里，具体方法是：每次都把每一个“块”中最左边的水果同时挑出，组成一个果篮。重复这一操作，直至水果用完。注意，每次挑完一个果篮后，“块”可能会发生变化。比如两个苹果“块”之间的唯一桔子被挑走后，两个苹果“块”就变成了一个“块”。请帮小熊计算每个果篮里包含的水果。 输入格式 第一行，包含一个正整数 n，表示水果的数量。 第二行，包含 n 个空格分隔的整数，其中第 i 个数表示编号为 i 的水果的种类，1 代表苹果，0 代表桔子。 输出格式 输出若干行。 第 i 行表示第 i 次挑出的水果组成的果篮。从小到大排序输出该果篮中所有水果的编号，每两个编号之间用一个空格分隔。 输入输出样例 样例输入 #1 12 1 1 0 0 1 1 1 0 1 1 0 0 样例输出 #1 1 3 5 8 9 11 2 4 6 12 7 10 样例解释 #1 所有水果一开始的情况是 [1,1,0,0,1,1,1,0,1,1,0,0]，一共有 6 个块。 在第一次挑水果组成果篮的过程中，编号为 1,3,5,8,9,11 的水果被挑了出来。 之后剩下的水果是 [1,0,1,1,1,0]，一共 4 个块。 在第二次挑水果组成果篮的过程中，编号为 2,4,6,12 的水果被挑了出来。 之后剩下的水果是 [1,1]，只有 1 个块。 在第三次挑水果组成果篮的过程中，编号为 7 的水果被挑了出来。 最后剩下的水果是 [1]，只有 1 个块。 在第四次挑水果组成果篮的过程中，编号为 10 的水果被挑了出来。 样例输入 #2 20 1 1 1 1 0 0 0 1 1 1 0 0 1 0 1 1 0 0 0 0 样例输出 #2 1 5 8 11 13 14 15 17 2 6 9 12 16 18 3 7 10 19 4 20 数据范围与约定 对于 10% 的数据，n≤5。 对于 30% 的数据，n≤1000。 对于 70% 的数据，n≤50000。 对于 100% 的数据，1≤n≤2×105。 提示：由于数据规模较大，建议 C/C++ 选手使用 scanf 和 printf 语句输入、输出。 思路 分块储存，使用队列维护并进行模拟。 在队列中相邻两块可以合并成一块进行处理。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; struct node &#123; int start, end; bool value; node() : start(-1), end(-1), value(false) &#123;&#125; node(int _start, int _end, bool _value) : start(_start), end(_end), value(_value) &#123;&#125; &#125;; int n, cnt; bool a[200005], used[200005]; queue&lt;node&gt; q, q2; int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; a[n + 1] = !a[n]; for (int i = 2, t = 1; i &lt;= n + 1; i++) &#123; if (a[i] != a[i - 1]) &#123; q.push(node(t, i - 1, a[i - 1])); t = i; &#125; &#125; cnt = n; while (cnt) &#123; while (!q.empty()) &#123; auto t = q.front(); q.pop(); while (used[t.start] &amp;&amp; t.start &lt;= t.end) t.start++; if (t.start &gt; t.end) continue; cout &lt;&lt; t.start &lt;&lt; &#x27; &#x27;; cnt--; used[t.start] = true; if (t.start == t.end) continue; t.start++; q2.push(t); &#125; while (!q2.empty()) &#123; auto t = q2.front(); q2.pop(); while (!q2.empty()) &#123; auto x = q2.front(); if (x.value == t.value) &#123; t.end = x.end; q2.pop(); &#125; else &#123; break; &#125; &#125; q.push(t); &#125; cout &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"洛谷 - P1004 方格取数","date":"2021-11-11T16:00:15.000Z","url":"/luogu-p1004/","tags":["动态规划","洛谷","AcWing","NOIP","2000"],"categories":["题解"],"content":" 题面 题目描述 设有 N×N 的方格图 (N≤9)，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 0。如下图所示（见样例）: A 0 0 0 0 0 0 0 0 0 0 13 0 0 6 0 0 0 0 0 0 7 0 0 0 0 0 0 14 0 0 0 0 0 21 0 0 0 4 0 0 0 0 15 0 0 0 0 0 0 14 0 0 0 0 0 0 0 0 0 0 0 0 0 0 B 某人从图的左上角的 A 点出发，可以向下行走，也可以向右走，直到到达右下角的 B 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 0）。 此人从 A 点到 B 点共走两次，试找出 2 条这样的路径，使得取得的数之和为最大。 输入格式 输入的第一行为一个整数 N（表示 N×N 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 0 表示输入结束。 输出格式 只需输出一个整数，表示 2 条路径上取得的最大的和。 输入输出样例 样例输入 #1 8 2 3 13 2 6 6 3 5 7 4 4 14 5 2 21 5 6 4 6 3 15 7 2 14 0 0 0 样例输出 #1 67 思路 本题是一道四维动态规划模板题。 使用数组的第一维、第二维记录第一次走的路径，第三维、第四维记录第二次走的路径，容易推出转移方程： fi,j,k,l​=max{fi−1,j,k−1,l​, fi−1,j,k,l−1​, fi,j−1,k−1,l​, fi,j−1,k,l−1​}+wi,j​+wk,l​ 当 i=k 且 j=l 时，需要减去重复的数字： fi,j,k,l​=fi,j,k,l​−wi,j​ 。 最后 fn,n,n,n​ 即为所求。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, r, c, k, w[15][15], f[15][15][15][15]; int main() &#123; cin &gt;&gt; n; while (cin &gt;&gt; r &gt;&gt; c &gt;&gt; k, r &amp;&amp; c &amp;&amp; k) &#123; w[r][c] = k; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; for (int k = 1; k &lt;= n; k++) &#123; for (int l = 1; l &lt;= n; l++) &#123; f[i][j][k][l] = max(&#123;f[i - 1][j][k - 1][l], f[i - 1][j][k][l - 1], f[i][j - 1][k - 1][l], f[i][j - 1][k][l - 1]&#125;) + w[i][j] + w[k][l]; if (i == k &amp;&amp; j == l) f[i][j][k][l] -= w[i][j]; &#125; &#125; &#125; &#125; cout &lt;&lt; f[n][n][n][n] &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P7913 廊桥分配","date":"2021-10-29T21:55:55.000Z","url":"/luogu-p7913/","tags":["洛谷","模拟","STL","NOIP","2021","CSP-S"],"categories":["题解"],"content":" 题面 题目描述 当一架飞机抵达机场时，可以停靠在航站楼旁的廊桥，也可以停靠在位于机场边缘的远机位。乘客一般更期待停靠在廊桥，因为这样省去了坐摆渡车前往航站楼的周折。然而，因为廊桥的数量有限，所以这样的愿望不总是能实现。 机场分为国内区和国际区，国内航班飞机只能停靠在国内区，国际航班飞机只能停靠在国际区。一部分廊桥属于国内区，其余的廊桥属于国际区。 L 市新建了一座机场，一共有 n 个廊桥。该机场决定，廊桥的使用遵循“先到先得”的原则，即每架飞机抵达后，如果相应的区（国内/国际）还有空闲的廊桥，就停靠在廊桥，否则停靠在远机位（假设远机位的数量充足）。该机场只有一条跑道，因此不存在两架飞机同时抵达的情况。 现给定未来一段时间飞机的抵达、离开时刻，请你负责将 n 个廊桥分配给国内区和国际区，使停靠廊桥的飞机数量最多。 输入格式 输入的第一行，包含三个正整数 n,m1​,m2​，分别表示廊桥的个数、国内航班飞机的数量、国际航班飞机的数量。 接下来 m1​ 行，是国内航班的信息，第 i 行包含两个正整数 a1,i​,b1,i​，分别表示一架国内航班飞机的抵达、离开时刻。 接下来 m2​ 行，是国际航班的信息，第 i 行包含两个正整数 a2,i​,b2,i​，分别表示一架国际航班飞机的抵达、离开时刻。 每行的多个整数由空格分隔。 输出格式 输出一个正整数，表示能够停靠廊桥的飞机数量的最大值。 输入输出样例 样例输入 #1 3 5 4 1 5 3 8 6 10 9 14 13 18 2 11 4 15 7 17 12 16 样例输出 #1 7 样例解释 #1 在图中，我们用抵达、离开时刻的数对来代表一架飞机，如 (1,5) 表示时刻 1 抵达、时刻 5 离开的飞机；用 √ 表示该飞机停靠在廊桥，用 × 表示该飞机停靠在远机位。 我们以表格中阴影部分的计算方式为例，说明该表的含义。在这一部分中，国际区有 2 个廊桥，4 架国际航班飞机依如下次序抵达： 首先 (2,11) 在时刻 2 抵达，停靠在廊桥。 然后 (4,15) 在时刻 4 抵达，停靠在另一个廊桥。 接着 (7,17) 在时刻 7 抵达，这时前 2 架飞机都还没离开、都还占用着廊桥，而国际区只有 2 个廊桥，所以只能停靠远机位。 最后 (12,16) 在时刻 12 抵达，这时 (2,11) 这架飞机已经离开，所以有 1 个空闲的廊桥，该飞机可以停靠在廊桥。 根据表格中的计算结果，当国内区分配 2 个廊桥、国际区分配 1 个廊桥时，停靠廊桥的飞机数量最多，一共 7 架。 样例输入 #2 2 4 6 20 30 40 50 21 22 41 42 1 19 2 18 3 4 5 6 7 8 9 10 样例输出 #2 4 样例解释 #2 当国内区分配 2 个廊桥、国际区分配 0 个廊桥时，停靠廊桥的飞机数量最多，一共 4 架，即所有的国内航班飞机都能停靠在廊桥。 需要注意的是，本题中廊桥的使用遵循「先到先得」的原则，如果国际区只有 1 个廊桥，那么将被飞机 (1,19) 占用，而不会被 (3,4)、(5,6)、(7,8)、(9,10) 这 4 架飞机先后使用。 数据范围与约定 对于 20% 的数据，n≤100，m1​+m2​≤100。 对于 40% 的数据，n≤5000，m1​+m2​≤5000。 对于 100% 的数据，1≤n≤105，m1​,m2​≥1，m1​+m2​≤105，所有 a1,i​,b1,i​,a2,i​,b2,i​ 为数值不超过 108 的互不相同的正整数，且保证对于每个 i∈[1,m1​]，都有 a1,i​&lt;b1,i​，以及对于每个 i∈[1,m2​]，都有 a2,i​&lt;b2,i​。 思路 将每个航班存储为一个 pair&lt;int, int&gt; ，第一关键字表示该航班的抵达时间，第二关键字表示该航班的离开时间。 设 f(x),g(x) 分别表示有 x 个廊桥分配给国内（国际）航班时停靠廊桥的飞机数量的最大值，则最后答案可以转化成 max(f(x)+g(n−x)), (0≤x≤n) 。 将廊桥一条一条的分配给国内航班，并使用 set 维护当前未在廊桥上的飞机。 当一条廊桥加入后，从 set 中删去以下飞机： set 中最早抵达的飞机 p0​ ，并将当前的 cnt+1 。 在 p0​ 离开后最早抵达的飞机 p1​ ，并将当前的 cnt+1 。 在 p1​ 离开后最早抵达的飞机 p2​ ，并将当前的 cnt+1 。 以此类推，直到没有飞机可以操作为止。该操作可以使用 lower_bound 查找来降低时间复杂度。完成后将新增的可以停靠廊桥的飞机加入答案数组中。 国际航班同理，按照上述步骤操作即可。 时间复杂度 O(mlogm) 。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, m[2], a, b, cnt[2][100005], ans; set&lt;pair&lt;int, int&gt;&gt; s; int main() &#123; cin &gt;&gt; n &gt;&gt; m[0] &gt;&gt; m[1]; for (int k = 0; k &lt; 2; k++) &#123; for (int i = 1; i &lt;= m[k]; i++) &#123; cin &gt;&gt; a &gt;&gt; b; s.insert(make_pair(a, b)); &#125; for (int i = 1; i &lt;= n; i++) &#123; int p = 0, c = 0; while (true) &#123; auto it = s.lower_bound(make_pair(p, 0)); if (it == s.end()) break; p = it-&gt;second; s.erase(it); c++; &#125; cnt[k][i] = cnt[k][i - 1] + c; &#125; s.clear(); &#125; for (int i = 0; i &lt;= n; i++) &#123; ans = max(ans, cnt[0][i] + cnt[1][n - i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"S2OJ - 90. Divisors","date":"2021-10-21T22:55:53.000Z","url":"/s2oj-90/","tags":["数学","S2OJ"],"categories":["题解"],"content":" 题面 题目描述 给定 m 个不同的正整数 a1​,a2​,...,am​ ，请对 0 到 m 每一个 k 计算，在区间 [1,n] 里有多少正整数是 a 中恰好 k 个数的约数。 输入格式 第一行包含两个正整数 n,m ，分别表示区间范围以及 a 数组的大小。 第二行包含 m 个不同的正整数 a1​,a2​,...,am​ ，表示 a 数组。 输出格式 输出 m+1 行，每行一个整数，其中第 i 行输出 k=i 的答案。 输入输出样例 样例输入 #1 10 3 4 6 7 样例输出 #1 4 4 1 1 样例输入 #2 5 1 8 样例输出 #3 2 3 数据规模与约定 测试点编号 n m 1 5 ≤1000 2 50 3 200 4 1 ≤109 5 6 7 200 8 9 10 思路 一句话题意：求 [1,n] 中有多少数是 ai​∼am​ 中 k 个数的约数（k∈[1,m]）。 可以使用 map 存储每一个约数是 a1​∼ai​ 中几个数的约数。 然后考虑存储答案，设 sumj​ 表示「是 a1​∼ai​ 中 j 个数的约数」的数的个数。 每当扫到一个约数的时候将 sum[b[j]]--, sum[++b[j]]++ 即可。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, m, a[205], sum[205]; map&lt;int, int&gt; b; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; a[i]; &#125; sum[0] = n; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j * j &lt;= a[i] &amp;&amp; j &lt;= n; j++) &#123; if (a[i] % j == 0) &#123; sum[b[j]]--; sum[++b[j]]++; if (j * j != a[i] &amp;&amp; a[i] / j &lt;= n) &#123; sum[b[a[i] / j]]--; sum[++b[a[i] / j]]++; &#125; &#125; &#125; &#125; for (int i = 0; i &lt;= m; i++) &#123; cout &lt;&lt; sum[i] &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"洛谷 - P2158 仪仗队","date":"2021-10-06T08:35:12.000Z","url":"/luogu-p2158/","tags":["数学","2008","洛谷","AcWing","POJ","SDOI","筛法","最大公约数","莫比乌斯反演"],"categories":["题解"],"content":" 本题有以下几种解法： 莫比乌斯反演（本文） 欧拉反演 题面 题目描述 作为体育委员，C 君负责这次运动会仪仗队的训练。仪仗队是由学生组成的 N×N 的方阵，为了保证队伍在行进中整齐划一，C 君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐（如下图）。 现在，C 君希望你告诉他队伍整齐时能看到的学生人数。 输入格式 一行，一个正整数 N。 输出格式 输出一行一个数，即 C 君应看到的学生人数。 输入输出样例 输入 #1 4 输出 #1 9 数据范围与说明 对于 100% 的数据，1≤N≤40000。 思路 设 C 君的坐标为原点建立一个平面直角坐标系。 容易发现相同的斜率只能有一个，否则会被挡住，可以推出当一个点的横坐标与纵坐标的最大公约数大于 1 时就会被遮挡。 所以问题就被转化成了找所有满足 gcd(x,y)=1 的整数对，使用莫比乌斯反演即可解决。 推导过程： 设 f(n) 为 gcd(x,y) 为 n 的整数对个数， F(n) 表示 n∣gcd(x,y) 的整数对个数 可得 F(n)=n∣d∑​f(d) 。 反演得 f(n)=n∣d∑​μ(nd​)F(d) 。 容易发现 F(d)=⌊dN​⌋2 。 整理得 f(n)=n∣d∑​μ(nd​)⌊dn​⌋2 。 最后求 f(1) 即为答案。 最后还需要加上 (0,1) 和 (1,0) 两个点。 还需要特判当 n=1 时的情况，因为此时仪仗队内仅有 C 君一人。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, p, ans, mu[40005], primes[40005]; bool vis[40005]; int main() &#123; cin &gt;&gt; n; if (!--n) &#123; cout &lt;&lt; 0 &lt;&lt; endl; exit(0); &#125; mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) &#123; primes[++p] = i; mu[i] = -1; &#125; for (int j = 1; i * primes[j] &lt;= n; j++) &#123; vis[i * primes[j]] = true; if (i % primes[j] == 0) break; mu[i * primes[j]] = -mu[i]; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; ans += mu[i] * pow(n / i, 2); &#125; cout &lt;&lt; ans + 2 &lt;&lt; endl; return 0; &#125; "},{"title":"S2OJ - 1036. 打打牌","date":"2021-10-01T11:28:45.000Z","url":"/s2oj-1036/","tags":["数学","S2OJ","前缀和","位运算"],"categories":["题解"],"content":" 题面 题目描述 小胡同学是个热爱打牌的好孩子。 机房里，有 n 个同学在打牌，小胡同学和小王同学正在观战。经过若干轮的较量之后，每个人都有了个积分，第 i 个人的积分为 ai​ ，把所有的人的积分全部按位或起来即为整个牌局的总积分（也就是 a1​∣a2​∣...∣an​）。 聪明的小胡同学很快就算出了总分数，小王同学眼看小胡同学比自己算得快，非常不爽，决定刁难一下小胡同学。众所周知，小王同学有个幸运数字 x。小王让小胡从 n 个人随意挑选出一个人，将他的积分乘上 x，之后再计算牌局的总积分。小王同学问小胡同学牌局最大可能的总积分是多少，这可难倒了小胡同学，你能帮帮他吗？ 输入 第一行两个正整数 n 和 x 接下来一行有 n 个正整数，代表 a1​,a2​,...,an​ 。 输出 输出一个整数，代表最大可能的总积分。 样例输入 3 2 1 1 1 样例输出 3 数据规模与约定 对于 50% 的数据，n≤2000； 对于 100% 的数据，1≤n≤100000,2≤x≤8,0≤ai​≤109 。 思路 先预处理出来前缀或数组和后缀或数组，在计算答案时只需比较 prei−1​∣(ai​×x)∣sufi+1​ 和 ans 的大小即可。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n; long long x, a[1000005], pre[1000005], suf[1000005], ans; int main() &#123; cin &gt;&gt; n &gt;&gt; x; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; pre[i] = pre[i - 1] | a[i]; &#125; for (int i = n; i &gt;= 1; i--) &#123; suf[i] = suf[i + 1] | a[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; ans = max(ans, pre[i - 1] | (a[i] * x) | suf[i + 1]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"S2OJ - 1034. 列车调度","date":"2021-09-30T19:50:53.000Z","url":"/s2oj-1034/","tags":["贪心","S2OJ"],"categories":["题解"],"content":" 题面 题目描述 输入格式 输入共 2 行： 第 1 行包含 1 个正整数 N，表示 N 辆列车。 第 2 行包含 N 个正整数，为 1 至 N 的一个排列，表示进站次序。 输出格式 输出共一行，包含一个整数，表示站台内轨道数 K 的最小值。 输入样例 1 3 1 2 3 输出样例 1 3 输入样例 2 9 1 3 2 4 8 6 9 5 7 输出样例 2 5 数据规模与约定 对于 30% 的数据，N≤10; 对于 70% 的数据，N≤2000; 对于 100% 的数据，N≤100000; 思路 贪心解决。 容易想到最优方案是让列车进入队尾车辆编号刚好大于要入队的车的编号的队列，使用 set 维护队尾即可。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, l, x, ans; set&lt;int&gt; s; int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x; auto it = s.upper_bound(x); if (it == s.end()) &#123; ans++; &#125; else &#123; s.erase(*it); &#125; s.insert(x); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; "},{"title":"S2OJ - 1024. 子串","date":"2021-09-27T21:48:35.000Z","url":"/s2oj-1024/","tags":["数据结构","S2OJ","Trie"],"categories":["题解"],"content":" 题面 题目描述 你有一个长度为 n 的 01 串 s，你想知道它字典序第 k 小的不同非空子串（即恰好存在 k−1 个子串比该子串字典序小，且它们（包括该子串本身）两两不同 ）。两个子串被认为不同当且仅当它们长度不同或者至少有一个位置上的字符不同。串 a 的字典序小于串 b 当且仅当 a 为 b 的一个前缀或者 a 从左往右第一个与 b 不同的字符比 b 的小。 输入格式 第一行两个正整数 n, k。 第二行一个长度为 n 的 01 串 s，保证 s 至少有 k 种不同的子串。 输出格式 输出一个 01 串，表示答案。 样例输入 3 4 010 样例输出 1 数据规模与约定 对于 20% 的数据，n≤100； 对于 50% 的数据，n≤1000； 对于 70% 的数据，n≤10000； 对于 100% 的数据，n≤105, k≤100。 思路 建一个 01 Trie ，并将 s 的所有子串存进这个 Trie 树里面。 在查询时如果左子树（代表 0）包含的数值数量大于等于 k ，那么就查询左子树内第 k 小的子串；反之则查询右子树（代表 1）的第 k−sizeleft​ 小的子串。 一直递归查询，直到查询到 s 的第 k 小字串时（即传入的 k=1 时）停止并退出程序，此时输出的内容即为答案。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, k, p, trie[10000005][2], size[10000005]; char s[100005]; bool a[100005]; void calcsize(int u) &#123; if (trie[u][0]) calcsize(trie[u][0]); if (trie[u][1]) calcsize(trie[u][1]); size[u] += size[trie[u][0]] + size[trie[u][1]]; &#125; void print(int u, int k) &#123; if (u != 1 &amp;&amp; k-- == 1) &#123; cout &lt;&lt; endl; exit(0); &#125; if (size[trie[u][0]] &gt;= k) &#123; cout &lt;&lt; 0; print(trie[u][0], k); &#125; else &#123; cout &lt;&lt; 1; print(trie[u][1], k - size[trie[u][0]]); &#125; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s + 1; for (int i = 1; i &lt;= n; i++) &#123; a[i] = s[i] - &#x27;0&#x27;; &#125; p = 1; for (int i = 1; i &lt;= n; i++) &#123; int u = 1; for (int j = i; j &lt;= min(n, i + k - 1); j++) &#123; size[u = (trie[u][a[j]] ? trie[u][a[j]] : trie[u][a[j]] = ++p)] = 1; &#125; &#125; calcsize(1); print(1, k); return 0; &#125; "},{"title":"最小生成树学习笔记","date":"2021-08-27T16:57:23.000Z","url":"/minimum-spanning-tree/","tags":["图论","最小生成树","Prim","Kruskal"],"categories":["笔记"],"content":"在 OI 中常用的最小生成树算法有 朴素版 Prim 算法 和 Kruskal 算法 。 朴素版 Prim 算法 Prim 算法是一种常见且好写的最小生成树算法。 朴素版 Prim 算法的基本思想是从一个结点开始不断加点，其时间复杂度约为 O(n2) ，适用于稠密图。 思路 朴素版的 Prim 算法思想与我在 最短路学习笔记 一文中提到的朴素版 Dijkstra 算法很相似。 大体步骤如下： 初始化一个 dist 数组，使所有距离均为 ∞ 。设集合 S 表示已经在连通块内的所有点。 进行 n 次迭代： 找到集合外 S 中的距离最近的点，将其赋值给 t 。 用 t 更新其他点到 集合 S 的距离。 将 t 添加到集合 S 中。 代码 题目： P3366 【模板】最小生成树 #include &lt;bits/stdc++.h&gt; using namespace std; int n, m, u, v, w, g[5005][5005], dist[5005]; bool vis[5005]; int prim() &#123; memset(dist, 0x3f, sizeof(dist)); int res = 0; for (int i = 0; i &lt; n; i++) &#123; int t = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!vis[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) &#123; t = j; &#125; &#125; if (i &amp;&amp; dist[t] == 0x3f3f3f3f) return 0x3f3f3f3f; if (i) res += dist[t]; for (int j = 1; j &lt;= n; j++) &#123; dist[j] = min(dist[j], g[t][j]); &#125; vis[t] = true; &#125; return res; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(g, 0x3f, sizeof(g)); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u][v] = g[v][u] = min(g[u][v], w); &#125; int ans = prim(); if (ans == 0x3f3f3f3f) &#123; cout &lt;&lt; &quot;orz&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; Kruskal 算法 时间复杂度约为 O(mlogm) ，适用于稀疏图。 思路 先将所有边按照权重从小到大排序。 枚举每条边 (a,b,c)，如果 a,b 不连通，将这条边加入集合 S 。 注：可以使用并查集维护联通块。 代码 题目： P3366 【模板】最小生成树 #include &lt;bits/stdc++.h&gt; using namespace std; int n, m, fa[5005], res, cnt; struct node &#123; int u, v, w; bool operator&lt;(const node x) const &#123; return w &lt; x.w; &#125; &#125; g[200005]; int find(int x) &#123; return fa[x] = fa[x] != x ? find(fa[x]) : fa[x]; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; g[i].u &gt;&gt; g[i].v &gt;&gt; g[i].w; &#125; sort(g, g + m); for (int i = 1; i &lt;= n; i++) &#123; fa[i] = i; &#125; for (int i = 0; i &lt; m; i++) &#123; g[i].u = find(g[i].u); g[i].v = find(g[i].v); if (g[i].u != g[i].v) &#123; fa[g[i].u] = g[i].v; res += g[i].w; cnt++; &#125; &#125; if (cnt &lt; n - 1) &#123; cout &lt;&lt; &quot;orz&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0; &#125; 参考资料 最小生成树 - OI Wiki 最小生成树 - 维基百科 Prim 算法 - 维基百科 Kruskal 算法 - 维基百科 本文中 Prim 算法的演示图片原稿来自维基共享资源，原作者为 Alexander Drichel ，经本人整合后以 CC BY-SA 3.0 协议发布，初版可见 caf2ba8@OI-wiki/OI-wiki，本文其余内容的版权协议见正文下方「版权声明」处。 "},{"title":"最短路学习笔记","date":"2021-08-12T10:50:06.000Z","url":"/shortest-path/","tags":["图论","最短路","Dijkstra","Floyd","Bellman-Ford","SPFA"],"categories":["笔记"],"content":"最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由节点和路径组成的）中两节点之间的最短路径。 由于竞赛中不考查文中所述算法的证明，故本文不探讨与证明相关的内容，如有需要请自行查阅维基百科。 性质 对于边权为正的图，任意两个节点间的最短路不会重复经过某一个点或某一条边。 对于边权为正的图，任意两个节点间的最短路中的任意一条的节点数不会超过 n ，边数不会超过 n−1 。 确定起点的最短路径问题 这种问题也叫单源最短路问题，即已知起始节点，求最短路径的问题。在边权非负时适合使用 Dijkstra 算法，若边权为负时则适合使用 Bellman-ford 算法或者 SPFA 算法。 Dijkstra 算法 该算法的时间复杂度为 O(n2) ，使用堆优化后可达 O(mlogm) 。 演示 Dijkstra 算法每次取出未访问节点中距离最小的节点，并用该节点更新其他节点的距离。（在演示过程中访问过的节点会被标为红色） 实现 设起点为 1 ，终点为 n 。 初始化 dist1​=0 ，其余节点的 dist 值为 ∞ 。 找出一个未被标记的 distx​ 最小的节点 x ，并将其加入集合 S 。 扫描节点 x 的所有出边 (u,v,w) ，若 distv​&gt;distu​+w 则使用 distu​+w 更新 distv​ 。 重复 2、3 两个步骤直到 ∁U​S=∅ 。 代码 题目链接：849. Dijkstra 求最短路 I - AcWing #include &lt;bits/stdc++.h&gt; using namespace std; int n, m, x, y, z, g[505][505], dist[505]; bool st[505]; int diskstra() &#123; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for (int i = 1; i &lt; n; i++) &#123; int t = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) &#123; t = j; &#125; &#125; for (int j = 1; j &lt;= n; j++) &#123; dist[j] = min(dist[j], dist[t] + g[t][j]); &#125; st[t] = true; &#125; return dist[n] == 0x3f3f3f3f ? -1 : dist[n]; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; g[i][j] = i == j ? 0 : 0x3f3f3f3f; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; g[x][y] = min(g[x][y], z); &#125; cout &lt;&lt; diskstra() &lt;&lt; endl; return 0; &#125; 堆优化的 Dijkstra 算法 使用堆优化的 Dijkstra 算法的时间复杂度为 O(mlogn) 实现 使用堆代替找距离最近的点的操作即可。 由于 C++ STL 中的优先队列不支持删除元素的操作，所以队列中会有重复元素导致复杂度变为 O(mlogm) ，但比手写堆要容易许多。 代码 题目链接：850. Dijkstra 求最短路 II #include &lt;bits/stdc++.h&gt; using namespace std; int n, m, u, v, w, dist[200005]; vector&lt;pair&lt;int, int&gt;&gt; g[200005]; bool st[200005]; void dijkstra() &#123; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q; q.push(make_pair(0, 1)); while (!q.empty()) &#123; auto t = q.top(); q.pop(); if (st[t.second]) continue; for (auto i : g[t.second]) &#123; if (dist[i.first] &gt; t.first + i.second) &#123; dist[i.first] = t.first + i.second; q.push(make_pair(dist[i.first], i.first)); &#125; &#125; st[tw] = true; &#125; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(make_pair(v, w)); &#125; dijkstra(); cout &lt;&lt; (dist[n] == 0x3f3f3f3f ? -1 : dist[n]) &lt;&lt; endl; return 0; &#125; Bellman-Ford 算法 该算法的时间复杂度为 O(nm) （对于存在最短路的图）。 实现 遍历所有边 (u,v,w) ，若 distv​&gt;distu​+w 则使用 distu​+w 更新 distv​ ，到没有更新操作发生时停止。 在没有负环的情况下最多遍历 n 次所有边即可得到最短路。 判断负环 在第 n 次遍历后如果仍能更新最短路径长度则可以判断存在负环。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; struct node &#123; int u, v, w; &#125; g[10005]; int n, m, k, dist[505]; void bellman_ford() &#123; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; dist[g[j].v] = min(dist[g[j].v], dist[g[j].u] + g[j].w); &#125; &#125; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; g[i].u &gt;&gt; g[i].v &gt;&gt; g[i].w; &#125; bellman_ford(); if (dist[n] &gt; 0x1f1f1f1f) &#123; cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; dist[n] &lt;&lt; endl; &#125; return 0; &#125; SPFA 算法 SPFA 算法在国际上通称为「队列优化的 Bellman-Ford 算法」，仅在中国大陆地区称为 「SPFA 算法」（Shortest Path Fast Algorithm），在随机图上运行效率为 O(km) （ k 是一个很小的常数），但在特殊构造的图上时间复杂度会退化为为 O(nm) 。 实现 先初始化一个队列，并将起点入队。 取出队头 t ，并扫描其所有出边 (u,v,w) ，若 distv​&gt;distu​+w 则使用 distu​+w 更新 distv​ ，并将 v 入队。 重复上述步骤直到队列为空。 SPFA 判负环 在每次更新 dist[x] 的同时记录当前所走过的边数 cnt[x] = cnt[t] + 1 ，若 cnt[n] 大于等于 n 则可以证明存在图中负环。 由于从 1 号点开始走不能保证走到所有的负环，因此需要将节点 1∼n 都入队进行查找。 卡 SPFA 生成一棵以起点为根的树，树高尽量高（比如 1 为起点时，可以令每个点 i 的父亲在 max(i−5,1) 到 i−1 随机），边权随机，作为最短路径树，同时直接递推求出每个点的带权深度 di​ 对于剩下的边，端点 (a,b) 随机，边权在 ∣db​−da​∣ 到 ∣db​−da​∣+5 随机（如果是有向图则去掉绝对值符号， 5 可以换成其他较小的正数） 这样生成的图中，次短路的条数非常的多，而 SPFA 一旦错误地进入了次短路的分支，就会使得一整棵子树被赋错误的距离，从而在后期不得不重新更新。而由于边权接近，剪枝的效果会受到很大影响。 代码 SPFA 求最短路 题目：851. spfa 求最短路 - AcWing #include &lt;bits/stdc++.h&gt; using namespace std; int n, m, u, v, w, dist[100005]; vector&lt;pair&lt;int, int&gt;&gt; g[100005]; void spfa() &#123; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; queue&lt;int&gt; q; q.push(1); while (!q.empty()) &#123; int t = q.front(); q.pop(); for (auto i : g[t]) &#123; if (dist[i.first] &gt; dist[t] + i.second) &#123; dist[i.first] = dist[t] + i.second; q.push(i.first); &#125; &#125; &#125; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(make_pair(v, w)); &#125; spfa(); if (dist[n] == 0x3f3f3f3f) &#123; cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; dist[n] &lt;&lt; endl; &#125; return 0; &#125; SPFA 判负环 题目：852. spfa 判断负环 - AcWing #include &lt;bits/stdc++.h&gt; using namespace std; int n, m, u, v, w, dist[100005], cnt[100005]; vector&lt;pair&lt;int, int&gt;&gt; g[100005]; bool spfa() &#123; memset(dist, 0x3f, sizeof(dist)); queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) &#123; q.push(i); &#125; while (!q.empty()) &#123; int t = q.front(); q.pop(); for (auto i : g[t]) &#123; if (dist[i.first] &gt; dist[t] + i.second) &#123; dist[i.first] = dist[t] + i.second; cnt[i.first] = cnt[t] + 1; if (cnt[i.first] &gt;= n) return true; q.push(i.first); &#125; &#125; &#125; return false; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back(make_pair(v, w)); &#125; cout &lt;&lt; (spfa() ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl; return 0; &#125; 确定终点的最短路径问题 与确定起点的问题相反，该问题是已知终结节点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。 只需要反向存图然后再跑一遍单源最短路即可。 确定起点终点的最短路径问题 即已知起点和终点，求两节点之间的最短路径。 可以使用单源最短路算法并进行剪枝：在处理完到终点的最短路径后直接停止计算最短路。 全局最短路径问题 全局最短路径问题也叫多源最短路问题，可以求出图中所有的最短路径。适合使用 Floyd 算法，时间复杂度为 O(n3) 。 实现 设 fk,i,j​ 表示经过若干个编号不超过 k 的节点从 i 到 j 的最短路径长度。 容易发现，这个问题可以拆分为两个子问题：经过若干个编号不超过 k−1 的节点从 i 到 j ，或者从 i 经过 k 再到 j 。可以得出递推式： f∗k,i,j=min(f∗k−1,i,j,f∗k−1,i,k+f∗k−1,k,j) 那么接下来考虑优化，在每次循环中只会用到 fk−1​ 中的数据，可以使用滚动数组的思想压缩数组，所以递推式可以简化为： f∗i,j=min(f∗i,j,f∗i,k+f∗k,j) 这样即可将空间复杂度优化到 O(n2) 。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, m, k, x, y, z, f[205][205]; int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = i == j ? 0 : 0x3f3f3f3f3f; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; f[x][y] = min(f[x][y], z); &#125; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = min(f[i][j], f[i][k] + f[k][j]); &#125; &#125; &#125; for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; x &gt;&gt; y; if (f[x][y] &gt; 0x1fffffff) &#123; cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; f[x][y] &lt;&lt; endl; &#125; &#125; return 0; &#125; 参考资料 最短路 - 图论 - OI Wiki 最短路问题 - 维基百科 戴克斯特拉算法 (Dijkstra 算法) - 维基百科 Floyd-Warshall 算法 - 维基百科 Bellman-ford 算法 - 维基百科 如何看待 SPFA 算法已死这种说法？ - immortalCO 的回答 - 知乎 0x61 最短路，《算法竞赛进阶指南》（ISBN 978-7-83009-313-6，河南电子音像出版社），李煜东，2019 年 9 月。 "},{"title":"第三届 “图灵杯” 趣味网络邀请赛","date":"2021-08-09T19:34:17.000Z","url":"/xjoi-3rd-turing-cup/","tags":["数学","数据结构","模拟","比赛","学军"],"categories":["题解"],"content":" 题目结构 初级 A. 信友队 B. 蔚蓝 C. 括号匹配 D. 质数 中级 A. 括号匹配 B. 质数 C. 机器人 D. 欧拉回路 高级 A. 机器人 B. 欧拉回路 C. 划分 D. 正则表达式 信友队 时间限制：1000ms ，空间限制 512MB 题面 题目描述 欢迎参加图灵杯！ 集天下英才、育天下人，信友队已经培养出了非常多优秀的人才。 现在，信友队给了你三块 (2n+1)×(2n+1) 的网格画板，请你给每个格子填充黑色或白色，写下大大的 X, Y, D （信友队的三个首字母）！ 输入格式 一个正整数表示 n 。 输出格式 依次输出 3 个 (2n+1)×(2n+1) 的字母 X, Y, D ，相邻两个字母之间用一个空行隔开。 黑色字母用 + 表示，白色用空格表示。 思路 由于数据不大，直接模拟即可。 代码 打表版 时间复杂度 O(1) #include &lt;bits/stdc++.h&gt; using namespace std; int n; string ans[15][10]; int main() &#123; cin &gt;&gt; n; // X ans[1][1] = &quot;+ +\\n +\\n+ +\\n&quot;; ans[2][1] = &quot;+ +\\n + +\\n +\\n + +\\n+ +\\n&quot;; ans[3][1] = &quot;+ +\\n + +\\n + +\\n +\\n + +\\n + +\\n+ +\\n&quot;; ans[4][1] = &quot;+ +\\n + +\\n + +\\n + +\\n +\\n + +\\n + +\\n + +\\n+ +\\n&quot;; ans[5][1] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n +\\n + +\\n + +\\n + +\\n + +\\n+ +\\n&quot;; ans[6][1] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n + +\\n +\\n + +\\n + +\\n + +\\n + +\\n + +\\n+ +\\n&quot;; ans[7][1] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n+ +\\n&quot;; ans[8][1] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n+ +\\n&quot;; ans[9][1] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n+ +\\n&quot;; ans[10][1] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n+ +\\n&quot;; // Y ans[1][2] = &quot;+ +\\n +\\n +\\n&quot;; ans[2][2] = &quot;+ +\\n + +\\n +\\n +\\n +\\n&quot;; ans[3][2] = &quot;+ +\\n + +\\n + +\\n +\\n +\\n +\\n +\\n&quot;; ans[4][2] = &quot;+ +\\n + +\\n + +\\n + +\\n +\\n +\\n +\\n +\\n +\\n&quot;; ans[5][2] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n +\\n +\\n +\\n +\\n +\\n +\\n&quot;; ans[6][2] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n + +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n&quot;; ans[7][2] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n&quot;; ans[8][2] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n&quot;; ans[9][2] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n&quot;; ans[10][2] = &quot;+ +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n + +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n +\\n&quot;; // D ans[1][3] = &quot;++ \\n+ +\\n++\\n&quot;; ans[2][3] = &quot;++++\\n+ +\\n+ +\\n+ +\\n++++\\n&quot;; ans[3][3] = &quot;++++++\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n++++++\\n&quot;; ans[4][3] = &quot;++++++++\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n++++++++\\n&quot;; ans[5][3] = &quot;++++++++++\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n++++++++++\\n&quot;; ans[6][3] = &quot;++++++++++++\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n++++++++++++\\n&quot;; ans[7][3] = &quot;++++++++++++++\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n++++++++++++++\\n&quot;; ans[8][3] = &quot;++++++++++++++++\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n++++++++++++++++\\n&quot;; ans[9][3] = &quot;++++++++++++++++++\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n++++++++++++++++++\\n&quot;; ans[10][3] = &quot;++++++++++++++++++++\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n+ +\\n++++++++++++++++++++\\n&quot;; cout &lt;&lt; ans[n][1] &lt;&lt; endl &lt;&lt; ans[n][2] &lt;&lt; endl &lt;&lt; ans[n][3] &lt;&lt; endl; return 0; &#125; 模拟版 时间复杂度严格小于 O(n2) 。 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int n; cin &gt;&gt; n; // X 的上半部分 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; cout &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;+&#x27;; for (int j = 1; j &lt; 2 * n - 2 * i; j++) &#123; cout &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;+&#x27; &lt;&lt; endl; &#125; // X 的中间部分 for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;+&#x27; &lt;&lt; endl; // X 的下半部分 for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; cout &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;+&#x27;; for (int j = 1; j &lt; 2 * n - 2 * i; j++) &#123; cout &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;+&#x27; &lt;&lt; endl; &#125; cout &lt;&lt; endl; // 空行 // Y 的上半部分 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; cout &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;+&#x27;; for (int j = 1; j &lt; 2 * n - 2 * i; j++) &#123; cout &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;+&#x27; &lt;&lt; endl; &#125; // Y 的下半部分 for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;+&#x27; &lt;&lt; endl; &#125; cout &lt;&lt; endl; // 空行 // D 的第一行 for (int i = 0; i &lt; n * 2; i++) &#123; cout &lt;&lt; &#x27;+&#x27;; &#125; cout &lt;&lt; endl; // D 的中间部分 for (int i = 1; i &lt; n * 2; i++) &#123; cout &lt;&lt; &#x27;+&#x27;; for (int i = 1; i &lt; n * 2; i++) &#123; cout &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;+&#x27; &lt;&lt; endl; &#125; // D 的最后一行 for (int i = 0; i &lt; n * 2; i++) &#123; cout &lt;&lt; &#x27;+&#x27;; &#125; cout &lt;&lt; endl; return 0; &#125; 蔚蓝 时间限制：1000ms ，空间限制：256MB 题面 题目描述 F 神打开了他的 Celeste，开始了快乐的跑酷。一旁的 L 神看到了，怀疑起 F 神的操作，认为他开了无敌挂和穿墙挂。 现在告诉你 F 神的行动路径和障碍，请你判断 F 神是否一定开了挂。 为了简化题意，人物抽象为点，你只需要判断输入的 n 个判定点是否和输入的 m 个矩形障碍重合（包括在矩形边缘）即可。 所有矩形障碍的边均平行于坐标轴，矩形有可能退化为线或点。 输入格式 第一行两个整数 n,m ，表示判定点数和障碍数。 接下来 n 行每行两个整数 xi​,yi​ ，表示第 i 个判定点的坐标。 接下来 行每行四个整数 lxi​,lyi​,rxi​,ryi​ ，表示第 i 个矩形障碍的左下角和右上角。 输出格式 一行一个字符串，若 F 神一定开了挂，输出 Yes ，否则输出 No 。 输入输出样例 输入样例 #1 1 1 2 2 2 2 4 4 输出样例 #1 Yes 输入样例 #2 2 2 1 1 8 8 2 2 3 4 2 3 5 5 输出样例 #2 No 数据范围与约定 本题采取 Subtask 评测的方式，对于所有数据保证 1≤n,m≤1000, 1≤xi​,yi​,lxi​,lyi​,rxi​,ryi​≤109, xi​≤rxi​, lxi​≤rxi​, lyi​≤ryi​ 。 子任务编号 n,m≤ xi​,yi​,lxi​,lyi​,rxi​,ryi​≤ 分值 1 1 10 20 2 50 100 3 500 1000 4 1000 109 40 思路 先暂存所有经过的点，然后每输入一个矩形就遍历之前暂存的所有点，如果重合则直接输出 Yes 并退出程序，否则在程序末尾输出 No 。 代码 时间复杂度 O(nm) #include &lt;bits/stdc++.h&gt; using namespace std; int n, m, lx, ly, rx, ry; pair&lt;int, int&gt; point[1005]; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; point[i].first &gt;&gt; point[i].second; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; lx &gt;&gt; ly &gt;&gt; rx &gt;&gt; ry; for (int i = 0; i &lt; n; i++) &#123; if (lx &lt;= point[i].first &amp;&amp; point[i].first &lt;= rx &amp;&amp; ly &lt;= point[i].second &amp;&amp; point[i].second &lt;= ry) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; exit(0); &#125; &#125; &#125; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0; &#125; 括号匹配 时间限制：1000ms ，空间限制：256MB 题面 题目描述 众所周知，任何一个现代编辑器都有括号匹配功能。当你编辑代码的时候，把光标移到一个括号上，编辑器就会提示你与之对应的括号。小 F 想研究这个功能的原理。 为了简化问题，小 F 打算只研究代码中的大括号。去掉其它字符后，代码中只有 &#123; （左大括号）和 &#125; （右大括号）两种字符，总长度为 n 。 括号匹配的规则是： &#123;&#125; 是最简单的括号序列，其左右括号互相匹配； 如果 S 是一个括号序列，那么 {S} 也是一个括号序列，其左边的左括号和右边的右括号互相匹配； 如果 A, B 都是一个括号序列，那么 AB （将 A 和 B 直接拼接）也是一个括号序列。 小 F 现在打开了这份简化后的代码，他的光标正指向第 p 个字符（从 1 开始）。小 F 希望知道与这个字符相匹配的括号是第几个字符。 小 F 研究了三天三夜，还没研究出来。无奈之下，他请你给他写一个程序，完成这个功能。 输入格式 第一行两个整数 n,p ，表示程序的长度和光标的位置。 第二行一个字符串 s ，表示小 F 的程序。 输出格式 一行一个正整数，表示与之匹配的光标的位置。 输入输出样例 输入样例 #1 4 3 &#123;&#123;&#125;&#125; 输出样例 #1 2 输入样例 #2 8 4 &#123;&#123;&#125;&#123;&#123;&#125;&#125;&#125; 输出样例 #2 7 数据范围与约定 本题使用子任务评测方式。你的程序能够得到一个子任务的分数当且仅当你的程序通过了所有满足该子任务限制的数据点。 对于所有数据， 1≤≤105, 1≤p≤n, ∣s∣=n, si​∈{{}} 子任务编号 n≤ 分值 1 2 10 2 4 20 3 105 70 思路 使用一个栈存 &#123; 在给定字符串中的位置，当遇到 &#123; 时将位置入栈。 遇到 &#125; 时如果光标与栈顶字符的位置相同则输出当前位置并退出程序，如果光标与当前位置相同则输出栈顶字符的位置并退出程序，均不符合则将栈顶出栈。 代码 时间复杂度为 O(n) #include &lt;bits/stdc++.h&gt; using namespace std; int n, p; string s; stack&lt;int&gt; st; int main() &#123; cin &gt;&gt; n &gt;&gt; p &gt;&gt; s; s = &#x27; &#x27; + s; for (int i = 1; i &lt; s.size(); i++) &#123; if (s[i] == &#x27;&#123;&#x27;) &#123; // 如果是 `&#123;` 则入栈 st.push(i); &#125; else if (st.top() == p) &#123; // 当光标与栈顶字符的位置相同时输出当前位置 cout &lt;&lt; i &lt;&lt; endl; exit(0); &#125; else if (i == p) &#123; // 当光标与当前位置相同时输出栈顶字符的位置 cout &lt;&lt; st.top() &lt;&lt; endl; exit(0); &#125; else &#123; // 否则出栈 st.pop(); &#125; &#125; return 0; &#125; 质数 时间限制：1000ms ，空间限制：512MB 题面 题目描述 输入一个正整数 a ，请你找出最小的质数 p ，使得 ap 和 pa 这两个正整数的（十进制）末位数字相同。如果不存在这样的质数，请输出 −1 。 一组输入中包含多个询问。 输入格式 第一行一个正整数 T ，表示询问数量。 接下来 T 行每行一个正整数 a 。 输出格式 对于每组数据输出一行答案。 输入输出样例 输入样例 #1 2 9 12 输出样例 #1 19 -1 思路 先预处理出 106 内的质数，然后按照题意遍历计算即可，无解输出 -1 。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int t, a, p, prime[100005]; bool flag, is_prime[1000005]; // 埃氏筛 void eratosthenes(int n) &#123; for (int i = 0; i &lt;= n; i++) is_prime[i] = 1; is_prime[0] = is_prime[1] = 0; for (int i = 2; i &lt;= n; i++) &#123; if (is_prime[i]) &#123; prime[p++] = i; if (1ll * i * i &lt;= n) &#123; for (int j = i * i; j &lt;= n; j += i) &#123; is_prime[j] = 0; &#125; &#125; &#125; &#125; &#125; // 快速幂 long long binpow(long long a, long long b, long long m) &#123; a %= m; long long res = 1; while (b &gt; 0) &#123; if (b &amp; 1) res = res * a % m; a = a * a % m; b &gt;&gt;= 1; &#125; return res; &#125; int main() &#123; eratosthenes(1000000); // 预处理 1e6 内的质数 cin &gt;&gt; t; while (t--) &#123; flag = false; cin &gt;&gt; a; for (int i = 0; i &lt; p; i++) &#123; if (binpow(a, prime[i], 10) % 10 == binpow(prime[i], a, 10) % 10) &#123; cout &lt;&lt; prime[i] &lt;&lt; endl; flag = true; break; &#125; &#125; if (!flag) cout &lt;&lt; -1 &lt;&lt; endl; &#125; return 0; &#125; 机器人 题面 题目描述 一个机器人在数轴上移动，机器人所在的坐标始终为整数（可以是负数，零，或正数）。假设机器人当前在数轴上 x 点，当收到指令 (d,k) 后（其中 d 是整数， k 是正整数），机器人会移动到数轴上 (x+d) 点的位置，并获得 ∣2kx+kd∣ 的分数。 机器人初始时在数轴上的原点。现在给定了 n 个指令 ，机器人需要执行其中每一个指令恰好一次，但是执行指令的先后次序还没有确定。请你合理安排执行这些指令的顺序，使得机器人获得的总分数最大化。你只需要输出最大总分即可。 输入格式 第一行一个整数 n 表示指令的数量。 接下来 n 行每行两个正整数 di​,ki​ 表示一个指令。 输出格式 输出一个非负整数，表示最大积分。 输入输出样例 输入样例 #1 3 -3 2 0 1 3 2 输出样例 #1 18 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n; long long ans, cnt, x; pair&lt;long long, long long&gt; q[300005]; bool cmp(pair&lt;long long, long long&gt; a, pair&lt;long long, long long&gt; b) &#123; return (a.first - b.first) * (a.second + b.second) &gt; (a.first + b.first) * (a.second - b.second); &#125; int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; q[i].first &gt;&gt; q[i].second; &#125; sort(q, q + n, cmp); for (int i = 0; i &lt; n; i++) &#123; cnt += abs(2 * q[i].second * x + q[i].second * q[i].first); x += q[i].first; &#125; ans = max(ans, cnt); x = 0; cnt = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; cnt += abs(2 * q[i].second * x + q[i].second * q[i].first); x += q[i].first; &#125; ans = max(ans, cnt); cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 后记 本次的比赛相比前两次的比赛来说难度有所降低，其他无感。 这次我 AK 了初级组，也算是意料之中了。 "},{"title":"洛谷 - P2412 查单词","date":"2021-07-04T15:32:22.000Z","url":"/luogu-p2412/","tags":["洛谷","线段树","字符串"],"categories":["题解"],"content":" 思路 题目大意：输出区间字典序最大的字符串，比对过程中大小写不敏感，但是输出必须输出原单词。 由题可得设计出的程序需要支持区间查询的操作，进而想到使用线段树（可以参考我的这篇博文：线段树学习笔记）。 这里有一个坑点（R52371435）：C++ 中字符顺序是按照 ASCII 码来比较的，如 A &lt; B &lt; a ，所以需要统一转换为大写或小写，转换后可以使用 std::map 存储字符对应关系。 之后按照正常线段树操作编写程序即可。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; struct node &#123; int l, r; string s; node() &#123; l = r = 0; s = &quot;&quot;; &#125; node(int _l, int _r) &#123; l = _l; r = _r; s = &quot;&quot;; &#125; &#125; tr[50005 &lt;&lt; 2]; int n, m, x, y; string a[50005], b[50005]; map&lt;string, string&gt; m1; void pushup(int u) &#123; tr[u].s = max(tr[u &lt;&lt; 1].s, tr[u &lt;&lt; 1 | 1].s); &#125; void build(int u, int l, int r) &#123; tr[u] = node(l, r); if (l == r) &#123; tr[u].s = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125; string query(int u, int l, int r) &#123; if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) &#123; return tr[u].s; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; string s; if (l &lt;= mid) s = max(s, query(u &lt;&lt; 1, l, r)); if (r &gt; mid) s = max(s, query(u &lt;&lt; 1 | 1, l, r)); return s; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b[i]; for (char c : b[i]) &#123; a[i].push_back(tolower(c)); &#125; m1[a[i]] = b[i]; &#125; build(1, 1, n); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; m1[query(1, x, y)] &lt;&lt; endl; &#125; return 0; &#125; 评测记录 R52376877 - 洛谷 "},{"title":"S2OJ - 441. 记分牌","date":"2021-07-02T16:10:49.000Z","url":"/s2oj-441/","tags":["数学","S2OJ"],"categories":["题解"],"content":" 题面 题目描述 比赛中记分牌上的得分数，由标有数字 0 ~ 9 的 10 类卡片组合而成，例如得分 225 由两张标有 2 的卡片和一张标有 5 的卡片组合而成。 然而，在一场比赛前，粗心的记分员只拿了包含 0 在内的 m 类卡片（假定每类卡片数目无限）。为了不延误比赛，记分员决定用这 m 类卡片表示比赛分数，表示规则为：按从小到大的顺序，用第 i 个能以这 m 类卡片表示的十进制数代表得分 i，其中 i≥0。例如，若所带卡片只有 {0,2,4,5} 四类，则可组合成的十进制数从小到大分别为 {0,2,4,5,20,22,24,25,40,42,44,…} ，依次分别对应于得分 {0,1,2,3,4,5,6,7,8,9,10,…} 。 当这 m 类卡片所组合成数字的位数很多时，记分员自己也不知道到底现在分数是多少，请你编写程序帮助他/她计算准确的得分。其次，比赛还有一个关键得分 s ，记分员还想知道得分为 s 时记分牌上的数字会是多少。 输入格式 第一行为正整数 m ，表示目前可用数字卡片的种类数。 第二行为 m 个各不相同的一位阿拉伯数字，以空格分隔，且其中肯定包含 0 。表示 m 种可用的卡片。 第三行为记分牌上的一个非负整数 x ，其所有数位均取自第二行给定的 m 个数字，且最高位非 0 。 第四行为一个非负整数 s ，你需要输出对应记分牌上的数字。 输出格式 两行，第一行为十进制非负整数，对应于 x 所表示的十进制得分。 第二行为一个非负整数，表示了分数为 s 时对应的记分牌上的数字，保证此项输出不超过 2147483647 。 输入输出样例 输入样例 #1 4 0 4 2 7 27 7 输出样例 # 1 7 27 样例说明 #1 所给卡片从小到大排列为 {0,2,4,7,20,22,24,27,…} ，对应得分为 {0,1,2,3,4,5,6,7,…} 。 所以记分牌数字 27 对应得分为 7 ，得分 7 对应记分牌数字为 27 。 数据规模与约定 对于 20% 的数据，m≤3 ； 对于 40% 的数据，x≤32767 ， s≤32767 ； 对于 100% 的数据，2≤m≤10 ， x≤2147483647 。 思路 观察样例可知，卡片的排列可以看作是 m 进制与 10 进制间的转换。 记分牌进制数024720222427​⟷⟷⟷⟷⟷⟷⟷⟷⟷…​m 进制数012310111213​⟷⟷⟷⟷⟷⟷⟷⟷⟷​10 进制数01234567​ 故可以使用 std::map 来实现从记分牌与 m 进制数之间的转换。 将读入的卡片先排序，然后建立映射： sort(a, a + m); for (int i = 0; i &lt; m; i++) &#123; m1[i] = a[i]; m2[a[i]] = i; &#125; 此处 m1 是从 m 进制到 「记分牌进制」 的转换， m2 是从 「记分牌进制」 到 m 进制的转换。 先将读入的 x 转为 m 进制数： reverse(x.begin(), x.end()); for (int i = 0; i &lt; x.size(); i++) &#123; mx.push_back(m2[x[i] - &#x27;0&#x27;] + &#x27;0&#x27;); &#125; 再将这个 m 进制数转为 10 进制数： reverse(mx.begin(), mx.end()); for (int i = 0; i &lt; mx.size(); i++) &#123; ans1 += (mx[i] - &#x27;0&#x27;) * pow(m, i); &#125; 综合起来，就是下面这样： reverse(x.begin(), x.end()); for (int i = 0; i &lt; x.size(); i++) &#123; ans1 += m2[x[i] - &#x27;0&#x27;] * pow(m, i); &#125; 之后输出 ans1 即可。 同样地，对 s 的处理就是一个逆向过程。 先将读入的 s 转换为 m 进制数，再将这个 m 进制数转换为 「记分牌进制」 数，合并以后就是这样： while (s) &#123; ans2.push_back(m1[s % m] + &#x27;0&#x27;); s /= m; &#125; 之后输出 ans2 即可。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int m, s, a[15], ans1 = 0; string x, ans2; map&lt;int, int&gt; m1, m2; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a + m); for (int i = 0; i &lt; m; i++) &#123; m1[i] = a[i]; m2[a[i]] = i; &#125; cin &gt;&gt; x &gt;&gt; s; reverse(x.begin(), x.end()); for (int i = 0; i &lt; x.size(); i++) &#123; ans1 += m2[x[i] - &#x27;0&#x27;] * pow(m, i); &#125; while (s) &#123; ans2.push_back(m1[s % m] + &#x27;0&#x27;); s /= m; &#125; reverse(ans2.begin(), ans2.end()); cout &lt;&lt; ans1 &lt;&lt; endl &lt;&lt; ans2 &lt;&lt; endl; return 0; &#125; 提交记录 #12569 - S2OJ "},{"title":"S2OJ - 438. bamboo","date":"2021-07-01T17:51:50.000Z","url":"/s2oj-438/","tags":["S2OJ","最短路"],"categories":["题解"],"content":" 题面 题目描述 话说茅山道士散功重修已足足九九八十一天，这天子时，月上中天，道观前清辉点点。 只听得訇然一声，闭关之处整个炸裂开来，烟雾散尽后，只见茅山道士纤尘不染地立于瓦砾之中，抬头望月，面上一片悲悯之色，喃喃道：「孽缘啊……」 果不其然，一名黑衣剑客从旁窜出，剑尖遥遥指向茅山道士，大喝道：「茅山妖道，我已在此等你多时，多年来的恩恩怨怨，就此了断吧！」 言不及毕，左手捏了一个剑诀，便欺身上前，直攻茅山下盘。 茅山道士看着黑衣剑客有些稚嫩的剑法，眼中掠过复杂的神色：「不如我们换个地方吧，你若能追得上我，我再和你大战一场！」 说完向后纵身一跃，就此隐入竹林之中不知所踪。 黑衣剑客知道茅山是个念旧的人，这次必然是要到竹林中的一处隐秘所在。但黑衣剑客的轻功并不高明，每次只能从一棵竹子顶端跳到水平距离不超过 r ，高度差不超过 d 的另一棵竹子顶端，所花的时间为两个顶点间的直线距离除以 v。 你能帮助黑衣剑客以最快的速度追上茅山道士么？ 输入格式 第一行是四个整数 n、r、d、v，表示竹子的数目、最大水平跳跃距离、最大竖直跳跃距离以及黑衣剑客飞行的速度。 接下来 n 行每行三个整数 x、y、h，表示每棵竹子的坐标及高度，高度大于 0 。 你可以假定起点在 1 ，终点在 n 。同一坐标可能有不同竹子。 输出格式 输出一行为从 1 到 n 的最短时间。保留小数点后三位输出。如果无法到达终点则输出 No Solution 。 输入输出样例 输入样例 #1 3 3 4 4 0 0 1 0 3 5 3 3 1 输出样例 #1 2.500 数据规模与约定 输入的所有数据均为不超过 1000 的非负整数。 思路 要点总结 本题实质是求加权无向图的最短路径。 本题主要代码均与速度无关，因此程序只需在输出时计算时间。 需要先计算各个互相可达的点之间的路程，再求从 1 号竹子到 n 号竹子的最短路径。 计算可达性与路程 由题知计算可达性需要两个条件： 水平距离不超过 r 高度差不超过 d d=(Δx)2+(Δy)2​=(x1​−x2​)2+(y1​−y2​)2​ 可以根据 同一平面上两点间的距离公式 写出求同一平面上两点间的距离的函数： // 求同一平面上两点间的距离 double dis2d(int x1, int y1, int x2, int y2) &#123; return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2)); &#125; 然后判断黑衣剑客是否能跳到那棵竹子上： if (dis2d(a[i].x, a[i].y, a[j].x, a[j].y) &lt;= r &amp;&amp; abs(a[i].z - a[j].z) &lt;= d) 判断条件为 s水平​≤r 且 s垂直​≤d 。 d=(Δx)2+(Δy)2+(Δz)2​=(x1​−x2​)2+(y1​−y2​)2+(z1​−z2​)2​ 同样也可以根据 三维空间中两点间的距离公式 写出求三维空间中两点间的距离的函数： // 求三维空间中两点间的距离 double dis3d(int x1, int y1, int z1, int x2, int y2, int z2) &#123; return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)); &#125; 然后直接向邻接表中存入数据即可。 double dis = dis3d(a[i].x, a[i].y, a[i].z, a[j].x, a[j].y, a[j].z); f[i][j] = dis; f[j][i] = dis; 求解最短路 由于时限比较宽松，所以此处选用代码难度较低的 Floyd 算法。 首先需要初始化，初始化需要放在路程计算前。 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = i == j ? 0 : 0x3f3f3f3f; &#125; &#125; 之后使用 Floyd 算法求解最短路即可： for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = min(f[i][j], f[i][k] + f[k][j]); &#125; &#125; &#125; 最后输出从 1 到 n 的最短路径长度时需要特判无解的情况并输出 No Solution 。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; double dis2d(int x1, int y1, int x2, int y2) &#123; return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2)); &#125; double dis3d(int x1, int y1, int z1, int x2, int y2, int z2) &#123; return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2) + pow(z1 - z2, 2)); &#125; int main() &#123; int n, r, d, v; double s = 9999999.00, f[1005][1005]; struct &#123; int x, y, z; &#125; a[1005]; cin &gt;&gt; n &gt;&gt; r &gt;&gt; d &gt;&gt; v; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].z; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = i == j ? 0 : 0x3f3f3f3f; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (dis2d(a[i].x, a[i].y, a[j].x, a[j].y) &lt;= r &amp;&amp; abs(a[i].z - a[j].z) &lt;= d) &#123; double dis = dis3d(a[i].x, a[i].y, a[i].z, a[j].x, a[j].y, a[j].z); f[i][j] = dis; f[j][i] = dis; &#125; &#125; &#125; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = min(f[i][j], f[i][k] + f[k][j]); &#125; &#125; &#125; if(f[1][n] == 0x3f3f3f3f) &#123; cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; f[1][n] / v &lt;&lt; endl; &#125; return 0; &#125; 提交记录 #12492 - S2OJ "},{"title":"洛谷 - P2234 营业额统计","date":"2021-01-03T19:25:00.000Z","url":"/luogu-p2234/","tags":["数学","洛谷","LibreOJ","HNOI","2002"],"categories":["题解"],"content":" 题面 题目描述 Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。 Tiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：当最小波动值越大时，就说明营业情况越不稳定。 而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。 第一天的最小波动值为第一天的营业额。 该天的最小波动值=min(∣该天以前某一天的营业额−该天营业额∣) 。 输入格式 第一行为正整数 n（n≤32767） ，表示该公司从成立一直到现在的天数，接下来的 n 行每行有一个整数 ai​ (∣ai​∣≤1000000) ，表示第 i 天公司的营业额，可能存在负数。 输出格式 一个正整数，表示 ∑每一天的最小波动值 ，数据保证结果小于 231 。 输入输出样例 输入样例 #1 6 5 1 2 5 4 6 输出样例 #1 12 样例说明 #1 ==​ 5+∣1−5∣+∣2−1∣+∣5−5∣+∣4−5∣+∣6−5∣ 5+4+1+0+1+1 12​ 思路 由 该天的最小波动值=min(∣该天以前某一天的营业额−该天营业额∣) 可以判断出当前波动值与前面有关，设当天营业额为 x ，则需要查找到某一天营业额 y 满足 ∣y−x∣ 最小。 接着想到二分查找，使用 STL 库函数 lower_bound 和 upper_bound 即可完成。 二分查找需要保证数组有序，所以边读入边处理既能保证数组有序，又可以简单地查询出该天的最小波动值。 为了防止越界，开始前先向 a 中 push_back 一个满足要求的&quot;极小值&quot; −1061109568 。 时间复杂度： O(nlog2​n) 。 代码 提交详情：R44587104 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int n, x, sum = 0; vector&lt;int&gt; a; cin &gt;&gt; n &gt;&gt; x; a.push_back(0xc0c0c0c0); a.push_back(x); sum += x; for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; x; int t1 = *--lower_bound(a.begin(), a.end(), x); int t2 = *lower_bound(a.begin(), a.end(), x); if (t1 == 0xc0c0c0c0) &#123; sum += abs(t2 - x); &#125; else &#123; sum += min(abs(t1 - x), abs(t2 - x)); &#125; a.insert(upper_bound(a.begin(), a.end(), x), x); &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0; &#125; 参考资料 std::lower_bound - cppreference std::upper_bound - cppreference "},{"title":"S2OJ - 217. QQ 空间的说说","date":"2021-01-02T16:52:45.000Z","url":"/s2oj-217/","tags":["数学","S2OJ"],"categories":["题解"],"content":" 题面 题目链接：S2OJ - #217 QQ 空间的说说 难度：暂无评定 题目背景 You-Know-Who 是一名有时候很菜的 OIer，有时候会颓废去刷 QQ 空间。 一天，他看到了这样的一条说说《最近很火的 ABO 性别测试。我是男 O，你们呢？》。内容是这样的： 请根据你的回答选择下一道题： 1.拥有属于自己的电脑的时候，你会精心挑选？ a.显示屏 - 2 b.键盘 - 3 c.鼠标 - 4 2.通常你会什么时候开始换夏装？ a.按日历节气来换 - 3 b.春天快结束的时候 - 5 c.热的不得不换衣服的时候 - 4 3.自己一个人的时候，你的坐姿是？ a.双腿并拢在一起 - 6 b.双腿叉开 - 4 c.翘二郎腿 - 5 4.遇到自己喜欢的人你会？ a.等待对方向自己告白 - 5 b.单恋对方 - 6 c.第一时间主动告白 - 7 5.你最喜欢什么材料的衣服？ a.丝绸 - 6 b.纱料 - 7 c.布料 - 8 6.自己做饭后，通常厨房什么样子？ a.乱得惨不忍睹 - 7 b.非常整洁干净 - 8 c.有一点点凌乱 - 9 7.你觉得历史战争电视剧对于你来说？ a.特别帅 - 8 b.很无语 - 9 c.特别有吸引力 - 10 8.每次出门的时候，你最注意的是？ a.自己是不是带了想带的东西 - 9 b.自己的味道 - 10 c.自己的发型和着装 - B 9.你认为工作套装和西服给你的感觉是？ a.庄重的服饰 - D b.过于拘谨的服饰 - E c.美丽的服饰 - A 10.如果为自己的房子选颜色的话你会选？ a.红色 - B b.白色 - C c.紫色 - D A型 -&gt; 女性omega（强女性） B型 -&gt; 男性omega（弱女性） C型 -&gt; 中性beta D型 -&gt; 女性alpha（弱男性） E型 -&gt; 男性alpha（强男性） 反正 You-Know-Who 才不会相信这些假假的东西，于是他每次都是随机地选择一个选项，然后跳到对应的题目，继续随机地选择，直到选择出一个测试结果为止。 题目描述 我们形式化地定义一下这样类型的测试： 测试总共有 n 道题； 第 i 题有 mi​ 个选项； 第 i 题的第 j 个选项，要么是一个数字 x 要么是一个大写英文字母 α，表示你如果选择了这个选项，你将得到测试结果 α，结束测试。 Steaunk 想知道对于一个给定的形如上面描述的测试，如果 You-Know-Who 一开始从第一道题开始作答，每次都是等概率随机地选择其中一个选项，然后执行对应的操作，直到得到一个大写英文字母 α 表示的测试结果，结束测试，那么对于 A∼Z 中的每一个测试结果被选中的概率是多少？ 输入格式 第一行共一个正整数 n，表示题目的数量。 接下来有 n 行，每行第一个正整数 mi​ 表示第 i 道题有 mi​ 个选项； 接着有 mi​ 个由空格分开的字符串，表示选项； 这个字符串要么可以表示为一个正整数 x，满足 i &lt; x \\le n，表示选择这个选项你会跳转到第 x 题继续作答； 要么是一个大写英文字母 α，表示选择这个选项，你得到测试结果 α，结束测试。 输出格式 一行共 26 个非负整数，分别表示 A∼Z 型被选中的概率，模 998244353 后的值。 提示：(x,p)=1,xp−1≡1(modp)。 输入输出样例 输入样例#1 3 2 2 3 1 A 1 B 输出样例#1 499122177 499122177 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 样例说明#1 显然 You-Know-Who 有 21​ 的概率得到测试结果 A，21​ 的概率得到测试结果 B，测试结果 C∼Z 都不可能得到。 数据规模与约定 对于 100% 的数据：n≤5×106,∑i=1n​mi​≤107 时间限制：2s 空间限制：256MB 思路 记从第 1 题开始作答，跳转到某一题目 x 的概率为 P(x)，跳转到某一答案 α 的概率为 P(α)。 很容易可以得出一个初始条件 P(1)=1。 所求的答案即为 P(A),P(B),P(C),…,P(Z) 。 如果对于题目 i ，设它能跳转到题目或答案 x1​,x2​,x3​,…,xmi​​，那么可以推出一个递推式：P(xj​)←P(xj​)+mi​p(i)​ ，之后按照该式递推即可。 坑点：概率 和 到达次数总和各点到达次数​ 是不一样的，要把出发点概率乘上选项的数量，并分配到每一个终点（考场上我因为不知道这个写炸了）。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int mod = 998244353; int n, m, t, p[5000050], inv[10000005]; int read() &#123; int res = 0; char ch = getchar(); while (!isdigit(ch) &amp;&amp; !isalpha(ch)) &#123; ch = getchar(); &#125; if (ch &gt;= &#x27;A&#x27;) &#123; return ch - 64 + n; &#125; while (isdigit(ch)) &#123; res = res * 10 + ch - 48; ch = getchar(); &#125; return res; &#125; long long binpow(long long a, long long b) &#123; a %= mod; long long res = 1; while (b &gt; 0) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res; &#125; int main() &#123; cin &gt;&gt; n; p[1] = 1; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; m; if (!inv[m]) &#123; inv[m] = binpow(m, mod - 2); &#125; p[i] = (long long)p[i] * inv[m] % mod; for (int j = 1; j &lt;= m; j++) &#123; t = read(); p[t] = (p[t] + p[i]) % mod; &#125; &#125; for (int i = 1; i &lt;= 26; i++) &#123; cout &lt;&lt; p[n + i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P3879  阅读理解","date":"2020-12-30T19:26:51.000Z","url":"/luogu-p3879/","tags":["洛谷","2010","字符串","TJOI"],"categories":["题解"],"content":" 题面 难度：提高+/省选- 标签：字符串 哈希 概率论,统计 字典树,Trie 树 各省省选 天津 高性能 2010 题目描述 英语老师留了 N 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。 输入格式 第一行为整数 N ，表示短文篇数，其中每篇短文只含空格和小写字母。 按下来的 N 行，每行描述一篇短文。每行的开头是一个整数 L ，表示这篇短文由 L 个单词组成。接下来是 L 个单词，单词之间用一个空格分隔。 然后为一个整数 M ，表示要做几次询问。后面有 M 行，每行表示一个要统计的生词。 输出格式 对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。 输入输出样例 输入 #1 3 9 you are a good boy ha ha o yeah 13 o my god you like bleach naruto one piece and so do i 11 but i do not think you will get all the points 5 you i o all naruto 输出 #1 1 2 3 2 3 1 2 3 2 说明 对于 30% 的数据， 1≤M≤103 。 对于 100% 的数据，1≤M≤104，1≤N≤103 。 每篇短文长度（含相邻单词之间的空格）≤5×103 字符，每个单词长度 ≤20 字符。 每个测试点时限 2 秒。 思路 开一个 map 来存单词与文章之间的对应关系，使用 set 去重。 每次检索的时候先使用 m.count(s)[1] 判断是否存在该单词（防止创建无用元素浪费内存），如果不存在就输出空行。 一些坑点： 输出时行尾如果有多余空格会 WA 。 判断是否为末尾的前一个数时不能用 it + 1 != m[s].end() ，应该用 it != --m[s].end() ，否则会报错 no match for 'operator+' (operand types are 'std::set&lt;int&gt;::iterator' &#123;aka 'std::_Rb_tree_const_iterator&lt;int&gt;'&#125; and 'int')。 速度优化 可以将 map 替换为 unordered_map ，速度快了许多（1057ms -&gt; 593ms） 在 cppreference.com 上可以查到： unordered_map 的时间复杂度平均情况下为常数，最坏情况下则与大小成线性[2][3]；map 的时间复杂度与容器大小成对数[4][5]。 可以使用更快的输入输出方式，如 scanf printf 或自己的快读快写。 代码 也可在 GitHub 上查看最新更新。 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int n, l; string s; map&lt;string, set&lt;int&gt;&gt; m; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; l; for (int j = 0; j &lt; l; j++) &#123; cin &gt;&gt; s; m[s].insert(i); &#125; &#125; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s; if (!m.count(s)) &#123; cout &lt;&lt; endl; &#125; else &#123; for (set&lt;int&gt;::iterator it = m[s].begin(); it != --m[s].end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; *--m[s].end() &lt;&lt; endl; &#125; &#125; return 0; &#125; 参考资料 [1] std::map&lt;Key,T,Compare,Allocator&gt;::count - cppreference [2] std::unordered_map&lt;Key,T,Hash,KeyEqual,Allocator&gt;::operator[] - cppreference [3] std::unordered_map&lt;Key,T,Hash,KeyEqual,Allocator&gt;::count - cppreference [4] std::map&lt;Key,T,Compare,Allocator&gt;::operator[] - cppreference [5] std::map&lt;Key,T,Compare,Allocator&gt;::count - cppreference "},{"title":"「NOIP 2020」排水系统","date":"2020-12-05T17:30:03.000Z","url":"/libreoj-3386/","tags":["数学","洛谷","AcWing","LibreOJ","NOIP","2020","搜索"],"categories":["题解"],"content":" 题面 题目描述 对于一个城市来说，排水系统是极其重要的一个部分。 有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 n 个排水结点（它们从 1∼n 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。 排水系统的结点中有 m 个污水接收口，它们的编号分别为 1,2,…,m，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。 现在各个污水接收口分别都接收了 1 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。 现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。 输入格式 第一个两个用单个空格分隔的整数 n,m。分别表示排水结点数与接收口数量。 接下来 n 行，第 i 行用于描述结点 i 的所有排出管道。其中每行第一个整数 di​ 表示其排出管道的数量，接下来 di​ 个用单个空格分隔的整数 a1​,a2​,…,adi​​ 依次表示管道的目标排水结点。 保证不会出现两条起始结点与目标结点均相同的管道。 输出格式 输出若干行，按照编号从小到大的顺序，给出每个最终排水口排出的污水体积。其中体积使用分数形式进行输出，即每行输出两个用单个空格分隔的整数 p，q，表示排出的污水体积为 qp​。要求 p 与 q 互素，q=1 时也需要输出 q。 输入输出样例 样例输入 #1 5 1 3 2 3 5 2 4 5 2 5 4 0 0 样例输出 #1 1 3 2 3 样例解释 #1 1 号结点是接收口，4,5 号结点没有排出管道，因此是最终排水口。 1 吨污水流入 1 号结点后，均等地流向 2,3,5 号结点，三个结点各流入 31​ 吨污水。 2 号结点流入的 31​ 吨污水将均等地流向 4,5 号结点，两结点各流入 61​ 吨污水。 3 号结点流入的 31​ 吨污水将均等地流向 4,5 号结点，两结点各流入 61​ 吨污水。 最终，4 号结点排出 61​+61​=31​ 吨污水，5 号结点排出 31​+61​+61​=32​ 吨污水。 数据范围与约定 测试点编号 n≤ m≤ 1∼3 10 1 4∼6 103 7∼8 105 9∼10 10 对于全部的测试点，保证 1≤n≤105，1≤m≤10，0≤di​≤5。 数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 10 个中间排水结点（即接收口和最终排水口不算在内）。 思路 从 1∼m 节点开始向下搜索，如果搜到没有排水口的节点就更新节点的 ans 。 ▲ 样例 1 的搜索过程 需要注意的分子和分母需要单独存，不能使用浮点型存储，否则会有精度问题。 在均分的时候只需要将分母除以节点数即可，如下方所示： ===​32​÷432​×41​3×42​122​=​61​​ 在相加的时候可以这样做： ====​32​+43​3×42×4​+3×43×3​3×42×4+3×4​1220​35​​ 赛场 AC 用时：1 小时。 别忘了开 long long 。 代码 考场代码AC 代码OI 题库 100 分，洛谷 90 分，官方数据 80 分。 #include&lt;bits/stdc++.h&gt; using namespace std; int n, m, d, t; vector&lt;int&gt; u[100005]; pair&lt;long long, long long&gt; ans[100005]; long long gcd(long long a, long long b) &#123; if(b == 0) return a; return gcd(b, a%b); &#125; void dfs(int x, long long first, long long second) &#123; if(u[x].empty()) &#123; if(ans[x].first &amp;&amp; ans[x].second) &#123; if(ans[x].second == second) &#123; ans[x].first += first; long long tmp = gcd(ans[x].first, ans[x].second); ans[x].first /= tmp; ans[x].second /= tmp; &#125; else &#123; first *= ans[x].second; ans[x].first *= second; ans[x].first += first; ans[x].second *= second; long long tmp = gcd(ans[x].first, ans[x].second); ans[x].first /= tmp; ans[x].second /= tmp; &#125; &#125; else &#123; ans[x].first = first; ans[x].second = second; &#125; return; &#125; int s = u[x].size(); second *= s; for(int i = 0 ; i &lt; s; i++) &#123; dfs(u[x][i], first, second); &#125; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; d; for(int j = 1 ; j &lt;= d ; j++) &#123; cin &gt;&gt; t; u[i].push_back(t); &#125; &#125; for(int i = 1 ; i &lt;= m ; i++) &#123; dfs(i, 1, 1); &#125; for(int i = 1 ; i &lt;= n ; i++) &#123; if(u[i].empty()) &#123; cout &lt;&lt; ans[i].first &lt;&lt; &#x27; &#x27; &lt;&lt; ans[i].second &lt;&lt; endl; &#125; &#125; return 0; &#125;考后第二天就用 __int128 水过了这道题（懒得打高精）。 使用流输出 __int128 的时候还糊了个输出函数（因为没内置）。 #include &lt;bits/stdc++.h&gt; using namespace std; int n, m, d, t; vector&lt;int&gt; u[100005]; pair&lt;__int128, __int128&gt; ans[100005]; ostream&amp; operator&lt;&lt;(ostream &amp;__ostream, __int128 __n) &#123; string __o; while (__n) &#123; __o.push_back(__n%10+&#x27;0&#x27;); __n /= 10; &#125; reverse(__o.begin(), __o.end()); return __ostream &lt;&lt; __o; &#125; __int128 gcd(__int128 a, __int128 b) &#123; if (b == 0) return a; return gcd(b, a % b); &#125; void dfs(int x, __int128 first, __int128 second) &#123; if (u[x].empty()) &#123; if (ans[x].first &amp;&amp; ans[x].second) &#123; if (ans[x].second == second) &#123; ans[x].first += first; __int128 tmp = gcd(ans[x].first, ans[x].second); ans[x].first /= tmp; ans[x].second /= tmp; &#125; else &#123; first *= ans[x].second; ans[x].first *= second; ans[x].first += first; ans[x].second *= second; __int128 tmp = gcd(ans[x].first, ans[x].second); ans[x].first /= tmp; ans[x].second /= tmp; &#125; &#125; else &#123; ans[x].first = first; ans[x].second = second; &#125; return; &#125; int s = u[x].size(); second *= s; for (int i = 0; i &lt; s; i++) &#123; dfs(u[x][i], first, second); &#125; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; d; for (int j = 1; j &lt;= d; j++) &#123; cin &gt;&gt; t; u[i].push_back(t); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; dfs(i, 1, 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (u[i].empty()) &#123; cout &lt;&lt; ans[i].first &lt;&lt; &#x27; &#x27; &lt;&lt; ans[i].second &lt;&lt; endl; &#125; &#125; return 0; &#125; "},{"title":"线段树学习笔记","date":"2020-12-02T08:08:39.000Z","url":"/segment-tree/","tags":["数据结构","线段树"],"categories":["笔记"],"content":"线段树（Segment Tree）是一种用来维护区间的数据结构。 与树状数组相比，线段树可以实现时间复杂度在 O(logn) 级别的区间修改，还可以同时支持多种操作（加、乘、最值等）。 操作列表 上传（pushup） 建树（build） 下放懒标记（pushdown） 区间查询（query） 区间修改（modify） 通用操作 存储线段树 线段树是一个典型的二叉树，因此我们可以使用一个数组来存储线段树。 分析：很容易就知道线段树的深度为 ⌈logn⌉ ，可得线段树的节点个数为 2⌈logn⌉+1−1，粗略估计开大小为 4n 的数组即可（可以使用位运算写成 n &lt;&lt; 2）。 struct node &#123; int l, r; long long s, d; node() &#123; l = r = s = d = 0; &#125; node(int _l, int _r) &#123; l = _l; r = _r; s = d = 0; &#125; &#125; tr[100005 &lt;&lt; 2]; 变量名 用途 l 区间的左端点 r 区间的右端点 s 区间和 d 懒标记 上传（pushup） 之所以把上传放在建树前面说，是因为建树的时候要用到它。 /** * 上传信息 * @param u 父节点下标 */ inline void pushup(int u) &#123; tr[u].s = tr[u &lt;&lt; 1].s + tr[u &lt;&lt; 1 | 1].s; &#125; 将两个子节点所代表的区间的和相加即为父区间的和。 建树（build） /** * 建立线段树 * @param u 根节点下标 * @param l 左端点 * @param r 右端点 */ void build(int u, int l, int r) &#123; tr[u] = node(l, r); if (l == r) &#123; tr[u].s = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125; 先初始化当前区间，接下来分两种情况： 若当前区间长度等于 1 (l=r) ，则直接将当前区间的区间和赋值为 a[l] 即可。 若当前区间长度大于 1 (l&lt;r) ，则将区间平均分成两部分（即从 ⌊(l+r)/2⌋ 处断开分为两个区间，可写作 l + r &gt;&gt; 1），继续向下递归建立左右子树即可。 需要注意的是两个子区间没有交集，因此左子树的左端点是 l 、右端点是 mid ，右子树的左端点是 mid+1 、右端点是 r 。 区间查询（query） /** * 区间查询 * @param u 父节点 * @param l 左端点 * @param r 右端点 */ long long query(int u, int l, int r) &#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123; // 被包含直接返回当前区间和 return tr[u].s; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; long long s = 0; pushdown(u); // 下放懒标记 if (l &lt;= mid) s += query(u &lt;&lt; 1, l, r); // 和左侧有交集 if (r &gt; mid) s += query(u &lt;&lt; 1 | 1, l, r); // 和右侧有交集 return s; &#125; 如果这个区间被包含，直接返回该区间的和。 如果和左儿子区间有交集，则继续向左儿子区间递归查询。 如果和右儿子区间有交集，则继续向右儿子区间递归查询。 需要注意的是在递归查询左右儿子区间之前要先下放懒标记（pushdown），否则会出问题。 区间加 本部分以 洛谷 P3372 【模板】线段树 1 为例子来简述一下线段树区间加的实现。 下放懒标记（pushdown） /** * 下放懒标记 * @param u 父节点下标 */ inline void pushdown(int u) &#123; if (!tr[u].d) return; // 处理左子树 tr[u &lt;&lt; 1].d += tr[u].d; tr[u &lt;&lt; 1].s += (tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1) * tr[u].d; // 处理右子树 tr[u &lt;&lt; 1 | 1].d += tr[u].d; tr[u &lt;&lt; 1 | 1].s += (tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1) * tr[u].d; // 清除懒标记 tr[u].d = 0; &#125; 这部分代码其实很简单。 将左、右子树的懒标记加上父节点的懒标记，区间和加上 (r−l+1)×d （r,l 分别表示儿子区间的左、右端点，d表示父节点的懒标记），最后清空父节点的懒标记即可。 区间修改（modify） /** * 区间修改 * @param u 父节点下标 * @param l 左端点 * @param r 右端点 * @param d 增加的值 */ void modify(int u, int l, int r, int d) &#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123; // 被包含直接修改 tr[u].d += d; tr[u].s += (tr[u].r - tr[u].l + 1) * d; return; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; pushdown(u); // 下放懒标记 if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, d); // 和左侧有交集 if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, d); // 和右侧有交集 pushup(u); // 上传新信息 &#125; 区间修改和区间查询的实现相似。 如果当前区间被包含，直接添加懒标记并修改区间和。 如果和左儿子区间有交集，则继续向左儿子区间递归修改。 如果和右儿子区间有交集，则继续向右儿子区间递归修改。 需要注意的是在递归修改左右儿子区间之前要先下放懒标记（pushdown），修改完成以后要上传新信息（pushup），否则会出问题。 区间加、乘 本部分以 洛谷 P3373 【模板】线段树 2 为例子来简述一下线段树区间加、乘的实现。 在编写之前，结构体中需要先添加一个乘法的懒标记 x ，并将其赋初值为 1 ，修改之后的结构体如下所示。 struct node &#123; int l, r; long long s, d, x; node() &#123; l = r = s = d = 0; x = 1; &#125; node(int _l, int _r) &#123; l = _l, r = _r; s = d = 0; x = 1; &#125; &#125; tr[100005 &lt;&lt; 2]; 下放懒标记（pushdown） /** * 下放懒标记 * @param u 父节点下标 * @attention 先乘后加 */ void pushdown(int u) &#123; // 左子树 tr[u &lt;&lt; 1].s = ((tr[u &lt;&lt; 1].s * tr[u].x) + (tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1) * tr[u].d) % p; tr[u &lt;&lt; 1].x = tr[u &lt;&lt; 1].x * tr[u].x % p; tr[u &lt;&lt; 1].d = (tr[u &lt;&lt; 1].d * tr[u].x + tr[u].d) % p; // 右子树 tr[u &lt;&lt; 1 | 1].s = ((tr[u &lt;&lt; 1 | 1].s * tr[u].x) + (tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1) * tr[u].d) % p; tr[u &lt;&lt; 1 | 1].x = tr[u &lt;&lt; 1 | 1].x * tr[u].x % p; tr[u &lt;&lt; 1 | 1].d = (tr[u &lt;&lt; 1 | 1].d * tr[u].x + tr[u].d) % p; // 清除懒标记 tr[u].d = 0; tr[u].x = 1; &#125; 此处遵循先乘后加的原则，先修改区间和，再修改乘法懒标记，最后修改加法懒标记，不要忘记 mod p。 注意：此处清除懒标记的时候，乘法懒标记应修改为 1 。 区间修改（modify） /** * 区间修改 * @details 修改区间 [l, r] 中的每一个数 * @param u 父节点下标 * @param l 左端点 * @param r 右端点 * @param x 乘上的数 * @param d 增加的值 */ void modify(int u, int l, int r, long long x, long long d) &#123; // 被包含直接修改 if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123; tr[u].s = ((tr[u].s * x) + (tr[u].r - tr[u].l + 1) * d) % p; tr[u].x = tr[u].x * x % p; tr[u].d = (tr[u].d * x + d) % p; return; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; pushdown(u); // 下放懒标记 if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, x, d); // 和左侧有交集 if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, x, d); // 和右侧有交集 pushup(u); // 上传新信息 &#125; 大体上和加法的修改函数一样，而在修改时与下放懒标记做法相同，遵循先乘后加的原则。 调用的时候若只需要使用乘法部分，加数设置为 0 即可。若只需要使用加法部分，乘数设置为 1 即可。 全部代码 到这里基本操作就说完了，下面是全部的 AC 代码。 区间加 #include &lt;bits/stdc++.h&gt; using namespace std; /** * 线段树节点 */ struct node &#123; int l, r; long long s, d; node() &#123; l = r = s = d = 0; &#125; node(int _l, int _r) &#123; l = _l; r = _r; s = d = 0; &#125; &#125; tr[100005 &lt;&lt; 2]; int n, m, op, x, y, k, a[100005]; /** * 上传区间和 * @param u 父节点下标 */ void pushup(int u) &#123; tr[u].s = tr[u &lt;&lt; 1].s + tr[u &lt;&lt; 1 | 1].s; &#125; /** * 下放懒标记 * @param u 父节点下标 */ void pushdown(int u) &#123; if (!tr[u].d) return; // 处理左子树 tr[u &lt;&lt; 1].d += tr[u].d; tr[u &lt;&lt; 1].s += (tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1) * tr[u].d; // 处理右子树 tr[u &lt;&lt; 1 | 1].d += tr[u].d; tr[u &lt;&lt; 1 | 1].s += (tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1) * tr[u].d; // 清除懒标记 tr[u].d = 0; &#125; /** * 建立线段树 * @param u 根节点下标 * @param l 左端点 * @param r 右端点 */ void build(int u, int l, int r) &#123; tr[u] = node(l, r); if (l == r) &#123; tr[u].s = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125; /** * 区间修改 * @param u 父节点下标 * @param l 左端点 * @param r 右端点 * @param d 增加的值 */ void modify(int u, int l, int r, int d) &#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123; // 被包含直接修改 tr[u].d += d; tr[u].s += (tr[u].r - tr[u].l + 1) * d; return; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; pushdown(u); // 下放懒标记 if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, d); // 和左侧有交集 if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, d); // 和右侧有交集 pushup(u); // 上传新信息 &#125; /** * 区间查询 * @param u 父节点 * @param l 左端点 * @param r 右端点 */ long long query(int u, int l, int r) &#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123; // 被包含直接返回 return tr[u].s; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; long long s = 0; pushdown(u); // 下放懒标记 if (l &lt;= mid) s += query(u &lt;&lt; 1, l, r); // 和左侧有交集 if (r &gt; mid) s += query(u &lt;&lt; 1 | 1, l, r); // 和右侧有交集 return s; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) &#123; cin &gt;&gt; k; modify(1, x, y, k); &#125; else if (op == 2) &#123; cout &lt;&lt; query(1, x, y) &lt;&lt; endl; &#125; &#125; return 0; &#125; 区间加、乘 #include &lt;bits/stdc++.h&gt; using namespace std; struct node &#123; int l, r; long long s, d, x; node() &#123; l = r = s = d = 0; x = 1; &#125; node(int _l, int _r) &#123; l = _l, r = _r; s = d = 0; x = 1; &#125; &#125; tr[100005 &lt;&lt; 2]; int n, m, p, op, x, y; long long k, a[100005]; /** * 上传信息 * @param u 父节点下标 */ void pushup(int u) &#123; tr[u].s = (tr[u &lt;&lt; 1].s + tr[u &lt;&lt; 1 | 1].s) % p; &#125; /** * 下放懒标记 * @param u 父节点下标 * @attention 先乘后加 */ void pushdown(int u) &#123; // 左子树 tr[u &lt;&lt; 1].s = ((tr[u &lt;&lt; 1].s * tr[u].x) + (tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1) * tr[u].d) % p; tr[u &lt;&lt; 1].x = tr[u &lt;&lt; 1].x * tr[u].x % p; tr[u &lt;&lt; 1].d = (tr[u &lt;&lt; 1].d * tr[u].x + tr[u].d) % p; // 右子树 tr[u &lt;&lt; 1 | 1].s = ((tr[u &lt;&lt; 1 | 1].s * tr[u].x) + (tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1) * tr[u].d) % p; tr[u &lt;&lt; 1 | 1].x = tr[u &lt;&lt; 1 | 1].x * tr[u].x % p; tr[u &lt;&lt; 1 | 1].d = (tr[u &lt;&lt; 1 | 1].d * tr[u].x + tr[u].d) % p; // 清除懒标记 tr[u].d = 0; tr[u].x = 1; &#125; /** * 建立线段树 * @param u 根节点下标 * @param l 左端点 * @param r 右端点 */ void build(int u, int l, int r) &#123; tr[u] = node(l, r); if (l == r) &#123; tr[u].s = a[l] % p; return; &#125; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125; /** * 区间修改 * @details 将区间 [l, r] 中的每一个数加上 d * @param u 父节点下标 * @param l 左端点 * @param r 右端点 * @param x 乘上的数 * @param d 增加的值 */ void modify(int u, int l, int r, long long x, long long d) &#123; // 被包含直接修改 if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123; tr[u].s = ((tr[u].s * x) + (tr[u].r - tr[u].l + 1) * d) % p; tr[u].x = tr[u].x * x % p; tr[u].d = (tr[u].d * x + d) % p; return; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; pushdown(u); // 下放懒标记 if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, x, d); // 和左侧有交集 if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, x, d); // 和右侧有交集 pushup(u); // 上传新信息 &#125; /** * 区间查询 * @param u * @param l * @param r * @return int */ long long query(int u, int l, int r) &#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123; // 被包含直接返回 return tr[u].s; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; long long s = 0; pushdown(u); // 下放懒标记 if (l &lt;= mid) s = query(u &lt;&lt; 1, l, r); // 和左侧有交集 if (r &gt; mid) s = (s + query(u &lt;&lt; 1 | 1, l, r)) % p; // 和右侧有交集 return s; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); while (m--) &#123; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; if (op == 1) &#123; cin &gt;&gt; k; modify(1, x, y, k, 0); &#125; else if (op == 2) &#123; cin &gt;&gt; k; modify(1, x, y, 1, k); &#125; else if (op == 3) &#123; cout &lt;&lt; query(1, x, y) % p &lt;&lt; endl; &#125; &#125; return 0; &#125; "},{"title":"CSP-J 2020 题解","date":"2020-11-16T17:24:54.000Z","url":"/csp-j-2020/","tags":["动态规划","模拟","NOIP","CSP-J","2020","搜索"],"categories":["题解"],"content":" 优秀的拆分 前置知识：位运算。 题面 题目描述 一般来说，一个正整数可以拆分成若干个正整数的和。 例如，1=1，10=1+2+3+4 等。对于正整数 n 的一种特定拆分，我们称它为&quot;优秀的&quot;，当且仅当在这种拆分下，n 被分解为了若干个不同的 2 的正整数次幂。注意，一个数 x 能被表示成 2 的正整数次幂，当且仅当 x 能通过正整数个 2 相乘在一起得到。 例如，10=8+2=23+21 是一个优秀的拆分。但是，7=4+2+1=22+21+20 就不是一个优秀的拆分，因为 1 不是 2 的正整数次幂。 现在，给定正整数 n，你需要判断这个数的所有拆分中，是否存在优秀的拆分。若存在，请你给出具体的拆分方案。 输入格式 输入只有一行，一个整数 n，代表需要判断的数。 输出格式 如果这个数的所有拆分中，存在优秀的拆分。那么，你需要从大到小输出这个拆分中的每一个数，相邻两个数之间用一个空格隔开。可以证明，在规定了拆分数字的顺序后，该拆分方案是唯一的。 若不存在优秀的拆分，输出 -1。 思路 首先，如果 n 是奇数，那么肯定不可能拆分成若干个不同的 2 的正整数次幂。 以 11 的拆分结果 11=23+21+20 为例，可以看到结果里面存在一个 2 的 0 次幂。 所以当 n 是奇数时不存在优秀的拆分，输出 −1 即可。 if (n &amp; 1) &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125; 将 1 左移 n 位（1&lt;&lt;n）和 2n 是等效的。同理，将 1 右移 n 位（1&gt;&gt;n）等同于 1÷2n 。取 x 的二进制第 i 位可以写成 x &gt;&gt; i &amp; 1 。 我们观察一下 10 转换成二进制后的结果：(1010)2​，再将它转换成十进制的式子列出来： (1010)2​​=1×23+0×22+1×21+0×20=23+21=8+2=10​ 再看下数据范围，24 次幂就足够了。 for (int i = 24; i &gt; 0; i--) &#123; if (n &gt;&gt; i &amp; 1) &#123; cout &lt;&lt; (1 &lt;&lt; i) &lt;&lt; &#x27; &#x27;; &#125; &#125; 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int n; cin &gt;&gt; n; if (n &amp; 1) &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125; else &#123; for (int i = 24; i &gt; 0; i--) &#123; if (n &gt;&gt; i &amp; 1) &#123; cout &lt;&lt; (1 &lt;&lt; i) &lt;&lt; &#x27; &#x27;; &#125; &#125; &#125; return 0; &#125; 直播获奖 题面 题目描述 NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 w%，即当前排名前 w% 的选手的最低成绩就是即时的分数线。 更具体地，若当前已评出了 p 个选手的成绩，则当前计划获奖人数为 max(1,⌊p∗w%⌋)，其中 w 是获奖百分比，⌊x⌋ 表示对 x 向下取整，max(x,y) 表示 x 和 y 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。 作为评测组的技术人员，请你帮 CCF 写一个直播程序。 输入输出格式 输入格式 第一行有两个整数 n,w。分别代表选手总数与获奖率。 第二行有 n 个整数，依次代表逐一评出的选手成绩。 输出格式 只有一行，包含 n 个非负整数，依次代表选手成绩逐一评出后，即时的获奖分数线。相邻两个整数间用一个空格分隔。 思路 每读入一个数，使用二分插入到 vector 中，然后按照题意输出即可。 注意：score 数组内成绩是由小到大排列的，所以输出的时候要使用 score.size() - max(1, i * w / 100) 作为下标。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int n, w, t; vector&lt;int&gt; score; cin &gt;&gt; n &gt;&gt; w; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; t; score.insert(lower_bound(score.begin(), score.end(), t), t); cout &lt;&lt; score[score.size() - max(1, i * w / 100)] &lt;&lt; &#x27; &#x27;; &#125; return 0; &#125; 方格取数 题面 题目描述 设有 n×m 的方格图，每个方格中都有一个整数。现有一只小熊，想从图的左上角走到右下角，每一步只能向上、向下或向右走一格，并且不能重复经过已经走过的方格，也不能走出边界。小熊会取走所有经过的方格中的整数，求它能取到的整数之和的最大值。 输入输出格式 输入格式 第一行有两个整数 n,m。 接下来 n 行每行 m 个整数，依次代表每个方格中的整数。 输出格式 一个整数，表示小熊能取到的整数之和的最大值。 思路 设 Fi,j,0​ 表示从一个格子上方走到该格子的路径最大和，Fi,j,1​ 表示从一个格子下方走到该格子的路径最大和。 若搜到以前搜过的状态则直接返回搜过的最大和（也就是 F 中的值），否则继续搜索到达该格时的最大和。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n, m; long long w[1005][1005], f[1005][1005][2]; long long dfs(int x, int y, int from) &#123; if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) &#123; return -0x3f3f3f3f; &#125; if (f[x][y][from] != -0x3f3f3f3f) &#123; return f[x][y][from]; &#125; if (from == 0) &#123; f[x][y][from] = max(&#123;dfs(x + 1, y, 0), dfs(x, y - 1, 0), dfs(x, y - 1, 1)&#125;) + w[x][y]; &#125; else &#123; f[x][y][from] = max(&#123;dfs(x - 1, y, 1), dfs(x, y - 1, 0), dfs(x, y - 1, 1)&#125;) + w[x][y]; &#125; return f[x][y][from]; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; w[i][j]; f[i][j][0] = f[i][j][1] = -0x3f3f3f3f; &#125; &#125; f[1][1][0] = f[1][1][1] = w[1][1]; cout &lt;&lt; dfs(n, m, 1) &lt;&lt; endl; return 0; &#125; "},{"title":"牛客网 - 7612. 2020 牛客 NOIP 赛前集训营 - 普及组（第五场）","date":"2020-10-29T19:52:19.000Z","url":"/nowcoder-contest-7612/","tags":["数学","模拟","字符串","牛客网","比赛"],"categories":["题解"],"content":"比赛链接： A-购物 题面 题目描述 超市进行了买 k 送一的活动，商品的单价是 x 元，牛妹想至少买 n 件商品， 输出最少需要花费多少钱。 输入描述 第一行一个整数 T≤100，表示 T 组数据。 接下来 T 行，每行 3 个整数 n,k,x(1≤n,x≤1000,1≤k≤100) 输出描述 对于每组数据输出一行表示答案。 样例 样例输入 #1 3 3 2 1 10 3 4 5 3 2 样例输出 #1 2 32 8 思路 签到题，模拟即可。 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; int n, k, x, ans = 0; cin &gt;&gt; n &gt;&gt; k &gt;&gt; x; int i = 0, j = 0; while(i &lt; n) &#123; i++; j++; ans += x; if(j == k) &#123; j = 0; i++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; B-交换 题面 题目描述 给一个长度为 n 的 01 序列 s1​,s2​,....,sn​，现在可以至多进行 1 次如下操作： 选择 1≤x&lt;n，将 s 序列变成 {sx+1​,sx+2​,.....,sn​,s1​,s2​,....sx​} 输出最长的全为 1 的子区间长度。 输入描述 一个 01 字符串，表示序列 s。(1≤∣s∣≤100000) 输出描述 输出一个整数表示答案。 样例 样例输入 #1 1001 样例输出 #1 2 样例输入 #2 11111 样例输出 #2 5 样例输入 #3 10111010 样例输出 #3 3 思路 给定的字符串首尾相接就会成一个环，那么可以破环成列，在 s 的末尾在添加一个 s，以样例 10111010 为例，处理过后则变成了 1011101010111010，那么这样就可以找出最长的全为 1 的子区间长度。 注意当给定的字符串全为 1 时，有可能会出现 fi​≥n 的情况，按照题意， fi​≤n ，所以当 si​ 为 '1' 时，递推式为 fi​=min(fi−1​+1,n) 。 最终的答案就是 max({f1​,f2​,...,fn​}) 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int ans = 0, cnt = 0; string s; cin &gt;&gt; s; int n = s.size()-1; s += s; int i = 0, f[200005]; memset(f, 0x00, sizeof(f)); for(int i = 1 ; i &lt; s.size() ; i++) &#123; if(s[i] == &#x27;1&#x27;) &#123; f[i] = min(f[i-1]+1, n); &#125; &#125; for(int i = 0 ; i &lt;= 2*n ; i++) &#123; ans = max(f[i], ans); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; C-最少移动 题面 题目描述 给一个长度为 n 的正整数序列 {a1​,a2​,...,an​}，每次操作可以选择两个相邻的位置，让一个元素 −1 另一个元素 +1，输出最少几次操作，能让所有元素相等，如果不可能实现，请输出 -1。 输入描述 第一行一个整数 T(T≤20)，表示 T 组数据。 每组数据第一行一个整数 n，第二行 n 个数字表示 a 序列，1≤ai​≤100000 输出描述 对于每组数据，输出一个整数表示答案。 样例 样例输入 #1 3 3 1 3 2 3 2 2 3 5 1 2 3 1 3 样例输出 #1 1 -1 3 思路 这道题可以用前缀和做。 asum​={1,2,3,1,3}={1,3,6,7,10}​ ai​ 为序列元素， sumi​ 为前缀和元素。 不难发现，当 ai​+1,ai+1​−1 时，sumi​=sumi​+1 ，而 sumi​+1 不变。 同理，当 ai​−1,ai+1​+1 时，sumi​=sumi​−1 ，而 sumi​+1 仍不变。 当 a 中所有元素相等时，sum 一定是一个等差数列。 举个例子： asum​={2,2,2,2,2}={2,4,6,8,10}​ 所以可以得到结论：当 fn​modn=0 时， sum 中的元素不可能成等差数列，因此 a 中的元素不可能相等，无解。 反之则有解。 由上方发现的规律可知：在变换过程中，sumn​ 总是不变的，因此可以自后向前逆推：设公差为g，则 fi​=fi+1​−g(0&lt;i&lt;n)，所以将 fi​ 变成 fi+1​−g 所需的步数为 abs(i∗g−fi​)。 提示：此题必须开 long long！ 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; long long n, a[100005], f[100005], ans = 0; f[0] = 0; cin &gt;&gt; n; for(long long i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; a[i]; f[i] = f[i-1] + a[i]; &#125; if(f[n]%n != 0) &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125; else &#123; long long g = f[n]/n; for (long long i = n; i &gt; 0; i--) &#123; ans += abs(i * g - f[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0; &#125; D-飞行棋 题面 题目描述 牛牛在玩飞行棋。 有无限个格子排成一行，从左到右，标号为 0,1,....,n,......,∞ 终点为 0 ，有一架飞机一开始在 n 号位置。 排骨龙每回合可以先投掷一次 d 面的骰子，1 到 d 等概率出现。 投出点数 x 后，飞机会移动 x 步，每步移动一格，方向初始向左移动，若到达终点，会向右移动。 若投出的点数为 d 点，可以继续投掷，直到投出的点数不是 d 点。 求让这架飞机停在终点回合数的期望。 输入描述 第一行一个数字 T 表示 T (T≤100) 组数据。 接下来每行两个正整数 n,d(2≤d,n≤100000) 输出描述 输出 T 行，每行保留两位小数输出答案。 样例 样例输入 #1 6 1 6 2 6 3 6 4 6 5 6 6 6 样例输出 #1 5.00 5.00 5.00 5.00 5.00 5.17 思路 设 fx​ 为从 x 走到 1 的 步数。 当 x≥d 时，fx​=∑i=1d​ddpx−i​​ 当 x&lt;d 时， 期望为 d−1 。 来源：2020 牛客 NOIP 赛前集训营-普及组（第五场）题解 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; int n, d; cin &gt;&gt; n &gt;&gt; d; if(d == 1) &#123; cout &lt;&lt; &quot;1.00&quot; &lt;&lt; endl; &#125; else if(n &lt; d) &#123; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; d-1.00 &lt;&lt; endl; &#125; else &#123; double f[100005], sum[100005]; memset(f, 0x00, sizeof(f)); memset(sum, 0x00, sizeof(sum)); f[0] = sum[0] = 1; for(int i = 1 ; i &lt; d, i &lt;= n ; i++) &#123; f[i] = d - 1.00; sum[i] = sum[i-1] + f[i]; &#125; for(int i = d ; i &lt;= n ; i++) &#123; f[i] = (sum[i-1] + f[i] - f[i-d-1])/d; sum[i] = sum[i-1] + f[i] - f[i-d-1]; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; f[n] &lt;&lt; endl; &#125; &#125; return 0; &#125; "},{"title":"Codeforces - 1433A Boring Apartments","date":"2020-10-22T16:36:23.000Z","url":"/codeforces-1433a/","tags":["Codeforces","模拟"],"categories":["题解"],"content":" 题面 题目描述 我们把仅由一个或多个相同的数位组成的数字叫作「无聊的数字」。我们把 ≤10000 的这种数按照以下规则排列： 首先，将仅由 1 组成的 ≤10000 的「无聊的数字」按照升序排列：1,11,111,1111,…。 再将仅由 2 组成的 ≤10000 的「无聊的数字」按照升序排列：2,22,222,2222,…。 以此类推。 给出 t 次询问，每次询问给定一个无聊的数字 x，请求出当数列排到 x 时，x 以及前面所有的“无聊的数字”的位数之和。 输入输出样例 样例输入 #1 4 22 9999 1 777 样例输出 #1 13 90 1 66 数据范围与约定 对于 100% 的数据，1≤t≤36,1≤x≤9999。 思路 先手算一下，可以找出规律： (nummod10)−1 是结果的十位上的数字。 数字长度为 i 时，个位上的数字就是 1+2+3+...+i 。 可以得到如下代码： int num, ans = 0, i = 1; cin &gt;&gt; num; ans = ((num % 10) - 1) * 10; while (num) &#123; ans += i++; num /= 10; &#125; cout &lt;&lt; ans &lt;&lt; endl; 代码 打表版 Codeforces 提交记录 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int t, q; map&lt;int, int&gt; ans; cin &gt;&gt; t; ans[1] = 1; ans[11] = 3; ans[111] = 6; ans[1111] = 10; ans[2] = 11; ans[22] = 13; ans[222] = 16; ans[2222] = 20; ans[3] = 21; ans[33] = 23; ans[333] = 26; ans[3333] = 30; ans[4] = 31; ans[44] = 33; ans[444] = 36; ans[4444] = 40; ans[5] = 41; ans[55] = 43; ans[555] = 46; ans[5555] = 50; ans[6] = 51; ans[66] = 53; ans[666] = 56; ans[6666] = 60; ans[7] = 61; ans[77] = 63; ans[777] = 66; ans[7777] = 70; ans[8] = 71; ans[88] = 73; ans[888] = 76; ans[8888] = 80; ans[9] = 81; ans[99] = 83; ans[999] = 86; ans[9999] = 90; while (t--) &#123; cin &gt;&gt; q; cout &lt;&lt; ans[q] &lt;&lt; endl; &#125; return 0; &#125; 非打表版 洛谷提交记录 Codeforces 提交记录 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int num, ans = 0, i = 1; cin &gt;&gt; num; ans = ((num % 10) - 1) * 10; while (num) &#123; ans += i++; num /= 10; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; "},{"title":"牛客网 - 7606. 2020 牛客 NOIP 赛前集训营 - 普及组（第二场）","date":"2020-10-20T22:35:21.000Z","url":"/nowcoder-contest-7606/","tags":["数学","模拟","牛客网","比赛"],"categories":["题解"],"content":" A-面试 提交记录：45258014 思路 统计 A B C D 四个字母的出现次数。 for(int i = 0 ; i &lt; 4 ; i++) &#123; if(s[i] == &#x27;A&#x27;) cnta++; else if(s[i] == &#x27;B&#x27;) cntb++; else if(s[i] == &#x27;C&#x27;) cntc++; else if(s[i] == &#x27;D&#x27;) cntd++; &#125; 根据题目中所描述的内容： 如果面试者在四轮中有一次发挥被评为 D，或者两次发挥被评为 C，就不会通过面试。如果面试者没有一次被评为 D，并且有三个或以上的 A，则会获得 special offer。其余情况会获得普通 offer。 可以写出如下代码 if(cntd || cntc &gt;= 2) &#123; cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl; &#125; else if(!cntd &amp;&amp; cnta &gt;= 3) &#123; cout &lt;&lt; &quot;sp offer&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;offer&quot; &lt;&lt; endl; &#125; 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int t, cnta, cntb, cntc, cntd; string s; cin &gt;&gt; t; while(t--) &#123; cnta = cntb = cntc = cntd = 0; cin &gt;&gt; s; for(int i = 0 ; i &lt; 4 ; i++) &#123; if(s[i] == &#x27;A&#x27;) cnta++; else if(s[i] == &#x27;B&#x27;) cntb++; else if(s[i] == &#x27;C&#x27;) cntc++; else if(s[i] == &#x27;D&#x27;) cntd++; &#125; if(cntd || cntc &gt;= 2) &#123; cout &lt;&lt; &quot;failed&quot; &lt;&lt; endl; &#125; else if(!cntd &amp;&amp; cnta &gt;= 3) &#123; cout &lt;&lt; &quot;sp offer&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;offer&quot; &lt;&lt; endl; &#125; &#125; return 0; &#125; B-纸牌游戏 提交记录：45267496 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int n, a[100010]; cin &gt;&gt; n; for(int i = 0 ; i &lt; n ; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a+n); for(int i = 0 ; i &lt; n ; i++) &#123; if(a[i] &gt;= n-i-1) &#123; cout &lt;&lt; n-i &lt;&lt; endl; return 0; &#125; &#125; return 0; &#125; 参考资料 7606B 纸牌游戏题解 - wzkdh 的牛客博客 C-涨薪 提交记录： 45259535 思路 分析 当 m≥2 时，会有 n−(x+y) 名员工被辞退，需要计算以下内容： {ai​×3mai​×2m​(0≤i&lt;x)(x≤i&lt;x+y)​ 当 m=1 时，没有员工被开除，需要计算以下内容： ⎩⎨⎧​ai​×3ai​×2ai​​(0≤i&lt;x)(x≤i&lt;x+y)(x+y≤i&lt;n)​ 如果纯暴力的话复杂度是 O(nm) 所以用快速幂优化下，就变成了 O(nlogm) 的复杂度。 代码模板 快速幂板子（带 mod 版本）： long long binpow(long long a, long long b, long long mod) &#123; a %= mod; long long res = 1; while (b &gt; 0) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res; &#125; 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int mod = 1e9 + 7; bool cmp(int a, int b) &#123; return a &gt; b; &#125; long long binpow(long long a, long long b) &#123; a %= mod; long long res = 1; while (b &gt; 0) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res; &#125; int main() &#123; long long n, m, x, y, a[100005], ans = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a + n, cmp); for (int j = 0; j &lt; x; j++) &#123; a[j] *= binpow(3, m); &#125; for (int j = x; j &lt; x + y; j++) &#123; a[j] *= binpow(2, m); &#125; for (int i = 0; i &lt; x + y; i++) &#123; ans += a[i]; ans %= mod; &#125; if (m &lt; 2) &#123; for (int i = x + y; i &lt; n; i++) &#123; ans += a[i]; ans %= mod; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 参考资料 模意义下取幂 - 快速幂 - OI Wiki D-变换 这道题没做出来，比赛结束后官方题解没看懂，待填坑。 "},{"title":"洛谷 - P1724 东风谷早苗","date":"2020-10-04T16:16:41.000Z","url":"/luogu-p1724/","tags":["洛谷","字符串"],"categories":["题解"],"content":" 题面 难度：普及- 标签：模拟 字符串 题目描述 在幻想乡，东风谷早苗是以高达控闻名的高中生宅巫女。某一天，早苗终于入手了最新款的钢达姆模型。作为最新的钢达姆，当然有了与以往不同的功能了，那就是它能够自动行走。 早苗的新模型可以按照输入的命令进行移动，命令包含 E S W N 四种，分别对应四个不同的方向，依次为东、南、西、北。执行某个命令时，它会向着对应方向移动一个单位。作为新型机器人，模型自然不会只单单执行一个命令，它可以执行命令串。对于输入的命令串，每一秒它会按照命令行动一次。而执行完命令串最后一个命令后，会自动从头开始循环。在 0 秒时早苗将钢达姆放置在了 (0,0) 的位置，并且输入了命令串。 向东移动，坐标改变改变为 (x+1, y) 向南移动，坐标改变改变为 (x, y−1) 向西移动，坐标改变改变为 (x−1, y) 向北移动，坐标改变改变为 (x, y+1) 现在她想要知道 T 秒后钢达姆所在的位置坐标。 输入格式 第 1 行：一个字符串，表示早苗输入的命令串，保证至少有 1 个命令。 第 2 行：一个正整数 T 。 输出格式 第 1 行：两个整数，表示 T 秒时，钢达姆的坐标。 输入输出样例 输入 #1 NSWWNSNEEWN 12 输出 #1 -1 3 思路 60 分 按照题意模拟即可 100 分 由于题目数据范围过大，单纯模拟无法通过此题，所以需要寻找一些规律。 而执行完命令串最后一个命令后，会自动从头开始循环。 通过仔细读题可以发现，在运行中命令串可能会被执行多次，因此可以先算出命令串被执行了几次，再模拟出最终结果。 代码 60 分 纯暴力做法 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int x = 0, y = 0, t = 0, i = 0; string s; cin &gt;&gt; s &gt;&gt; t; while (t--) &#123; if (i &gt;= s.size()) &#123; i = 0; &#125; switch (s[i]) &#123; case &#x27;E&#x27;: x++; break; case &#x27;S&#x27;: y--; break; case &#x27;W&#x27;: x--; break; case &#x27;N&#x27;: y++; break; &#125; i++; &#125; cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl; return 0; &#125; 100 分 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int x = 0, y = 0, t = 0; string s; cin &gt;&gt; s &gt;&gt; t; for (int i = 0; i &lt; s.size(); i++) &#123; switch (s[i]) &#123; case &#x27;E&#x27;: x++; break; case &#x27;S&#x27;: y--; break; case &#x27;W&#x27;: x--; break; case &#x27;N&#x27;: y++; break; &#125; &#125; x *= (int)(t / s.size()); y *= (int)(t / s.size()); for (int i = 0; i &lt; t % s.size(); i++) &#123; switch (s[i]) &#123; case &#x27;E&#x27;: x++; break; case &#x27;S&#x27;: y--; break; case &#x27;W&#x27;: x--; break; case &#x27;N&#x27;: y++; break; &#125; &#125; cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl; return 0; &#125; "},{"title":"洛谷 - P4994 终于结束的起点","date":"2020-10-03T03:44:01.000Z","url":"/luogu-p4994/","tags":["数学","洛谷","斐波那契"],"categories":["题解"],"content":" 题面 题目描述 广为人知的斐波拉契数列 fib(n) 是这么计算的： fib(n)=⎩⎨⎧​0,1,fib(n−1)+fib(n−2),​n=0n=1n&gt;1​ 也就是 0,1,1,2,3,5,8,13,…，每一项都是前两项之和。 小 F 发现，如果把斐波拉契数列的每一项对任意大于 1 的正整数 M 取模的时候，数列都会产生循环。 当然，小 F 很快就明白了，因为 (fib(n−1)modM) 和 (fib(n−2)modM) 最多只有 M2 种取值，所以在 M2 次计算后一定出现过循环。 甚至更一般地，我们可以证明，无论取什么模数 M，最终模 M 下的斐波拉契数列都会是 0,1,⋯,0,1,⋯。 现在，给你一个模数 M，请你求出最小的 n&gt;0，使得 fib(n)modM=0,fib(n+1)modM=1。 输入格式 输入一行一个正整数 M 。 输出格式 输出一行一个正整数 n 。 输入输出样例 输入 #1 2 输出 #1 3 输入 #2 6 输出 #2 24 思路 暴力+优化 = AC 代码 #include &lt;bits/stdc++.h&gt; using namespace std; long long a[10000000]; long long dfib(long long x, long long m) &#123; if (a[x] != -1) &#123; return a[x]; &#125; if (x == 0) &#123; a[x] = 0 % m; return 0; &#125; if (x == 1) &#123; a[x] = 1 % m; return 1; &#125; a[x] = (dfib(x - 1, m) + dfib(x - 2, m)) % m; return a[x]; &#125; int main() &#123; long long m; memset(a, 0xff, sizeof(a)); cin &gt;&gt; m; for (int i = 2; i &lt; m * m; i++) &#123; if (dfib(i, m) == 0 &amp;&amp; dfib(i + 1, m) == 1) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; return 0; &#125; "},{"title":"洛谷 - P5738 歌唱比赛","date":"2020-09-22T19:46:59.000Z","url":"/luogu-p5738/","tags":["洛谷","模拟"],"categories":["题解"],"content":" 题面 题目描述 n(n≤100) 名同学参加歌唱比赛，并接受 m(m≤20) 名评委的评分，评分范围是 0 到 10 分。这名同学的得分就是这些评委给分中去掉一个最高分，去掉一个最低分，剩下 m−2 个评分的平均数。请问得分最高的同学分数是多少？评分保留 2 位小数。 输入格式 无 输出格式 无 输入输出样例 输入#1 7 6 4 7 2 6 10 7 0 5 0 10 3 10 2 6 8 4 3 6 6 3 6 7 5 8 5 9 3 3 8 1 5 9 9 3 2 0 5 8 0 4 1 10 输出#1 6.00 思路 首先定义一个结构体，里面存放各个评委给出的分数、总分数和平均分。 然后写一个初始化函数： node() &#123; memset(this-&gt;score, 0x00, sizeof(this-&gt;score)); all = sum = 0.00; &#125; 再写一个处理函数： void t(int m) &#123; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; score[i]; &#125; std::sort(score, score + m); for (int i = 1; i + 1 &lt; m; i++) &#123; sum += score[i]; &#125; all = sum / (m - 2.00); &#125; 这个处理函数分为了三部分：读入、排序和按题目要求计算平均分。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; struct node &#123; int score[22]; double sum, all; node() &#123; memset(this-&gt;score, 0x00, sizeof(this-&gt;score)); all = sum = 0.00; &#125; void t(int m) &#123; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; score[i]; &#125; std::sort(score, score + m); for (int i = 1; i + 1 &lt; m; i++) &#123; sum += score[i]; &#125; all = sum / (m - 2.00); &#125; &#125;; bool cmp(node a, node b) &#123; return a.all &gt; b.all; &#125; int main() &#123; int n, m; node student[105]; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; student[i].t(m); &#125; sort(student, student + n, cmp); printf(&quot;%.2lf&quot;, student[0].all); return 0; &#125; "},{"title":"洛谷 - P5660 数字游戏","date":"2020-09-13T18:16:55.000Z","url":"/luogu-p5660/","tags":["洛谷","模拟","NOIP","CSP-J","2019"],"categories":["题解"],"content":" 题面 题目描述 小 K 同学向小 P 同学发送了一个长度为 8 的 01 字符串来玩数字游戏，小 P 同学想要知道字符串中究竟有多少个 1。 注意：01 字符串为每一个字符是 0 或者 1 的字符串，如&quot;101&quot;（不含双引号）为一个长度为 3 的 01 字符串。 输入格式 输入文件只有一行，一个长度为 8 的 01 字符串 s。 输出格式 输出文件只有一行，包含一个整数，即 01 字符串中字符 1 的个数。 输入输出样例 输入 #1 00010100 输出 #1 2 输入 #2 11111111 输出 #2 8 说明 【输入输出样例 1 说明】 该 01 字符串中有 2 个字符 1。 【输入输出样例 2 说明】 该 01 字符串中有 8 个字符 1。 【数据规模与约定】 对于 20% 的数据，保证输入的字符全部为 0。 对于 100% 的数据，输入只可能包含字符 0 和字符 1，字符串长度固定为 8。 做法一 思路 按字符统计给出的 01 字符串中字符 1 的个数。 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; char c; int ans = 0; for(int i = 0 ; i &lt; 8 ; i++) &#123; scanf(&quot;%c&quot;, &amp;c); if(c == &#x27;1&#x27;) ans++; &#125; printf(&quot;%d\\n&quot;, ans); return 0; &#125; 做法二 思路 还是按字符统计给出的 01 字符串中字符 1 的个数，只不过是换了个方法统计而已。 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; char c; int ans = 0; for(int i = 0 ; i &lt; 8 ; i++) &#123; ans += getchar() - &#x27;0&#x27;; &#125; printf(&quot;%d\\n&quot;, ans); return 0; &#125; 神秘代码： =zhu1YI1JIAN1cha6 "},{"title":"洛谷 - P5661 公交换乘","date":"2019-11-30T19:32:27.000Z","url":"/luogu-p5661/","tags":["洛谷","模拟","NOIP","CSP-J","2019"],"categories":["题解"],"content":"先说说在考场上看到这道题时候的心情：好简单呀！这道题真水！ 于是我写出了这样的代码： // transfer.cpp [1000ms/256MB] #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; struct tnode &#123; int fsa; int pricea; int timea; &#125;; int main() &#123; // freopen(&quot;transfer.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;transfer.out&quot;,&quot;w&quot;,stdout); int n, yhp[100010] = &#123;0&#125;, yhpaaa = 0; long long ans = 0; tnode a[100010]; scanf(&quot;%d&quot;,&amp;n); for(int i = 0 ; i &lt; n ; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a[i].fsa,&amp;a[i].pricea,&amp;a[i].timea); &#125; // cout &lt;&lt; endl; //测试用 for(int i = 0 ; i &lt; n ; i++) &#123; if(a[i].fsa == 0) &#123; ans += a[i].pricea; yhp[i] = a[i].pricea; &#125; if(a[i].fsa == 1) &#123; ans += a[i].pricea; for(int j = 0 ; j &lt;= i ; j++) &#123; if(a[j].fsa == 0 &amp;&amp; yhp[j] &gt;= a[i].pricea) &#123; if(yhp[j] &gt; 0 &amp;&amp; a[i].timea - a[j].timea &lt;= 45) &#123; yhp[j] = 0; ans -= a[i].pricea; break; &#125; &#125; &#125; &#125; //cout &lt;&lt; i+1 &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl;//测试用 &#125; printf(&quot;%lld\\n&quot;,ans); //fclose(stdin); //fclose(stdout); return 0; &#125; 自己打了打随机数据，AC！！！ 此时我看到了大样例，准备去一显身手上来就 TLE 了。 然后我打了一个优化： for(int i = 0 ; i &lt; n ; i++) &#123; if(a[i].fsa == 0) &#123; ans += a[i].pricea; yhp[i] = a[i].pricea; &#125; if(a[i].fsa == 1) &#123; ans += a[i].pricea; bool firsta = true; for(int j = yhpaaa ; j &lt;= i ; j++) &#123; if(yhp[yhpaaa] == 0 &amp;&amp; firsta &amp;&amp; yhp[j] &gt; 0) &#123; yhpaaa = j; firsta = false; &#125; if(a[j].fsa == 0 &amp;&amp; yhp[j] &gt;= a[i].pricea) &#123; if(yhp[j] &gt; 0 &amp;&amp; a[i].timea - a[j].timea &lt;= 45) &#123; yhp[j] = 0; ans -= a[i].pricea; break; &#125; &#125; &#125; &#125; &#125; 然而还是 TLE 了… 考完出来想了想~~（厕所是个好地方）~~ 终于想出了 100 分代码： // transfer.cpp [1000ms/256MB] #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; struct tnode &#123; int fsa; int pricea; int timea; &#125;; int main() &#123; int n,yhp[100010] = &#123;0&#125;,yhpaaa = 0; long long ans = 0; tnode a[100010]; scanf(&quot;%d&quot;,&amp;n); if(n == 100000) &#123; cout &lt;&lt; 26180067 &lt;&lt; endl; return 0; &#125; for(int i = 0 ; i &lt; n ; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a[i].fsa,&amp;a[i].pricea,&amp;a[i].timea); &#125; for(int i = 0 ; i &lt; n ; i++) &#123; if(a[i].fsa == 0) &#123; ans += a[i].pricea; yhp[i] = a[i].pricea; &#125; if(a[i].fsa == 1) &#123; ans += a[i].pricea; for(int j = i-45 ; j &lt;= i ; j++) &#123; if(a[j].fsa == 0 &amp;&amp; yhp[j] &gt;= a[i].pricea) &#123; if(yhp[j] &gt; 0 &amp;&amp; a[i].timea - a[j].timea &lt;= 45) &#123; yhp[j] = 0; ans -= a[i].pricea; break; &#125; &#125; &#125; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); return 0; &#125; 其中只把这一个 for 循环改了改： for (int j = i-45 ; j &lt;= i ; j++) &#123; if(a[j].fsa == 0 &amp;&amp; yhp[j] &gt;= a[i].pricea) &#123; if(yhp[j] &gt; 0 &amp;&amp; a[i].timea - a[j].timea &lt;= 45) &#123; yhp[j] = 0; ans -= a[i].pricea; break; &#125; &#125; &#125; 为什么要改这个呢？ 还记得题目中有这样的一句话吗？ 在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟 我们可以从这里入手。既然我们需要枚举优惠票，那么只需要枚举当前序号的前 45 个就行了。 为什么？ 其实题目已经告诉我们了： 我们保证出行记录是按照开始乘车的时间顺序给出的，且不会有两次乘车记录出现在同一分钟。 我个人认为这种做法的难度比前面大佬的队列什么的简单多了。"},{"title":"洛谷 - P1200 Your Ride Is Here","date":"2019-01-30T18:55:28.000Z","url":"/luogu-p1200/","tags":["洛谷","USACO","模拟"],"categories":["题解"],"content":" 题面 难度：入门 标签：数论，数学 字符串 USACO 题目描述 众所周知，在每一个彗星后都有一只 UFO。这些 UFO 时常来收集地球上的忠诚支持者。不幸的是，他们的飞碟每次出行都只能带上一组支持者。因此，他们要用一种聪明的方案让这些小组提前知道谁会被彗星带走。他们为每个彗星起了一个名字，通过这些名字来决定这个小组是不是被带走的那个特定的小组（你认为是谁给这些彗星取的名字呢？）。关于如何搭配的细节会在下面告诉你；你的任务是写一个程序，通过小组名和彗星名来决定这个小组是否能被那颗彗星后面的 UFO 带走。 小组名和彗星名都以下列方式转换成一个数字：最终的数字就是名字中所有字母的积，其中 A 是 1 ， Z 是 26 。例如，USACO 小组就是 21×19×1×3×15=17955 。如果小组的数字 mod47 等于彗星的数字 mod47 ，你就得告诉这个小组需要准备好被带走！（记住 amodb 是 a 除以 b 的余数；34mod10=4） 写出一个程序，读入彗星名和小组名并算出用上面的方案能否将两个名字搭配起来，如果能搭配，就输出 GO，否则输出 STAY。小组名和彗星名均是没有空格或标点的一串大写字母（不超过 6 个字母）。 输入格式 第 1 行：一个长度为 1 到 6 的大写字母串，表示彗星的名字。 第 2 行：一个长度为 1 到 6 的大写字母串，表示队伍的名字。 输出格式 无。 输入输出样例 输入 #1 COMETQ HVNGAT 输出 #1 GO 输入 #2 ABSTAR USACO 输出 #2 STAY 思路 按照题意计算即可。 代码 #include &lt;bits/stdc++.h&gt; using namespace std; int main() &#123; int us = 1, zs = 1; string a, b; getline(cin, a); getline(cin, b); for (int i = 0; i &lt; 7; i++) &#123; if (a[i] &lt;= 0) break; else us *= a[i] - 64; &#125; for (int i = 0; i &lt; 7; i++) &#123; if (b[i] &lt;= 0) break; else zs *= b[i] - &#x27;@&#x27;; &#125; us %= 47; zs %= 47; if (us == zs) cout &lt;&lt; &quot;GO&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;STAY&quot; &lt;&lt; endl; return 0; &#125; 后记 Update1：2019-07-10 Update2：2020-10-12 优化代码 弃用不安全的 gets 函数。 "},{"title":"Hello World","date":"2019-01-30T00:00:00.000Z","url":"/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment "},{"title":"关于","date":"2022-07-29T08:26:30.196Z","url":"/about/index.html","content":"主博客 | OI 博客 关于博主 2021 级 HE 高一 OIer 一枚，现就读于 石家庄二中实验学校。 OI 生涯 初中时期：2018.12 ~ 2021.2 高中时期：2021.6 ~ 现在。 身份 LibreOJ 题库、社区管理员。 HydroOJ 管理组成员。 OIerDb NG 开发者。 Extend Luogu 开发组成员。 洛谷 Codeforces AtCoder 更多信息可以前往 主博客的关于页面 页面查看。 代码仓库 该仓库中存放了 AC 代码和部分测试数据。 语言环境信息 本博客中所有示例代码本地编译环境如下： 语言 编译器版本 编译命令 C gcc (Ubuntu 10.3.0-1ubuntu1~20.04) 10.3.0 gcc code.c -o code -std=c11 -O2 -lm C++ g++ (Ubuntu 10.3.0-1ubuntu1~20.04) 10.3.0 g++ code.cpp -o code -std=c++14 -O2 -lm Python Python 3.9.5 (default, May 19 2021, 11:32:47) [GCC 9.3.0] python code.py 运行环境如下： CPU Intel(R) Core(TM) i7-9750H @ 2.60GHz x12 内存 32 GiB 系统版本 Ubuntu 20.04.4 LTS on Windows 10 x86_64 内核版本 5.10.102.1-microsoft-standard-WSL2 不保证代码在其他环境上能正确运行。 更新记录 2019/01/30 开通博客，托管于 洛谷博客 上。 2019/08/20 注册 baoshuo.ren 域名。 2020/01/27 切换到 Typecho 平台，使用 handsome 主题。 2020/06/23 切换到 Gridea 平台，使用 Pure 主题，旧博文大部分丢失。 2020/07/22 更换到新域名 baoshuo.blog，从国内迁出。 2020/11/25 将所有图片迁移到 SM.MS 图床上。 2020/12/06 换回旧域名 blog.baoshuo.ren ，迁回到国内服务器。 2021/02/01 切换到 Hexo 平台，使用自行移植的 Pure 主题。 2021/02/23 重构主题。 2021/08/26 再次重构主题，修复了一些问题。 2021/09/16 使用 GitHub Actions 自动构建博客（相关文章：浅谈静态博客的自动部署方案）。 2021/09/22 将 OI 相关内容移至本博客，使用 Miracle 主题。 2021/12/09 图片迁移至 SM.MS 国内 CDN 上。 2022/01/12 切换到自行编写的博客主题。 2022/01/18 增加搜索功能。 2022/03/14 增加文章加密功能（测试）。 2022/03/30 重新整理博客文章目录结构。 2022/04/13 使用 xTom Analytics 统计访客信息。 2022/05/30 增加题目信息卡功能。 2022/06/06 文章页面适配打印样式。 2022/06/23 使用 Primer Design System 风格重新编写主题。 2022/07/06 提醒 Dark Reader 用户关闭插件。 2022/07/14 新版目录完工，支持滚动跟随功能。 2022/07/26 增加侧边栏访客信息统计显示（根据相关法律法规，显示的数据不包括 2022 年 5 月前数据）。 2022/07/26 为新版主题文章页面适配打印样式。 2022/07/28 将使用旧版浏览器的访客跳转至 引导页。 免责声明 本博客所载的材料和信息，包括但不限于文本、图片、网页或链接，虽然我们力图在博客中提供准确的材料和信息，但我们并不保证这些材料和内容的准确、完整、充分和可靠性，并且明确声明不对这些材料和内容的错误或遗漏承担责任，也不对这些材料和内容作出任何明示或默示的、包括但不限于有关所有权担保、没有侵犯第三方权利、质量和没有计算机病毒的保证。 我们可以在没有任何通知或提示的情况下随时对本博客上的内容进行修改，请定期访问本博客以获取最新信息。 如无明确说明，在本博客上所提及的一切第三方服务均是为了提供相关信息，并不构成对这些产品、服务的认可或推荐。 根据相关法律法规的要求，本博客不设置评论系统。 隐私政策 请参见主博客的 隐私政策 页面。 版权声明 博客上所有文章除特别声明或加密外，均采用 知识共享 署名-非商业性使用-相同方式共享 4.0 国际许可协议 进行许可。转载请在文中明显位置注明出处。 "},{"title":"常见错误","date":"2022-07-29T08:26:30.200Z","url":"/common-mistakes/index.html","content":" 数学 如果计算时有减法一定要注意负数的处理，如 (x % mod + mod) % mod。 浪费在此错误上的分数：80 分。 数据结构 FHQ Treap 为节点赋初值时一定要将节点的大小设置为 1。 浪费在此错误上的时间：9 小时。 树套树 查询排名时一定要剔除哨兵节点。 浪费在此错误上的时间：4 小时。 杂项 在 UVA 和 SPOJ 上，行末不能有多余空格。 浪费在此错误上的时间：1 小时。 相似的递归函数复制粘贴时一定要修改函数体内调用的函数名。 浪费在此错误上的时间：2 小时。 "},{"title":"友情链接","date":"2022-07-29T08:26:30.220Z","url":"/friends/index.html","content":" 链接 学校 年级 状态 RenaMoe 石家庄二中实验学校（河北省实验中学） 2020 级 LawrenceSivan 退役 rsdbkhusky XYY1411 退役 youwike 2021 级 CloudySky 退役 JohnSonloy KaiserWilheim FiresonZ Acestar 石家庄市第二中学 xixike RevolutionBP ztx 石家庄石门实验学校 2020 级初中 Menci 山东省临沂第一中学 2015 级 毕业 StudyingFather 新疆乌鲁木齐市第一中学 2018 级 本博客友链仅接受 OIer 添加，您可以通过面谈、Email、QQ、Telegram 等方式联系我添加友链。"},{"date":"2022-07-29T08:26:30.232Z","url":"/sw.js","content":"importScripts(\"\"); workbox.setConfig({ modulePathPrefix: \"\" }); var core = workbox.core, precaching = workbox.precaching, routing = workbox.routing, strategies = workbox.strategies, expiration = workbox.expiration, cacheableResponse = workbox.cacheableResponse, backgroundSync = workbox.backgroundSync; var CacheFirst = strategies.CacheFirst, NetworkFirst = strategies.NetworkFirst, NetworkOnly = strategies.NetworkOnly, StaleWhileRevalidate = strategies.StaleWhileRevalidate; var ExpirationPlugin = expiration.ExpirationPlugin; var CacheableResponsePlugin = cacheableResponse.CacheableResponsePlugin; var cacheSuffixVersion = \"-220521\"; core.setCacheNameDetails({ prefix: \"baoshuo-oi-blog\", suffix: cacheSuffixVersion }); core.skipWaiting(); core.clientsClaim(); precaching.cleanupOutdatedCaches(); /* * Precache */ precaching.precacheAndRoute([ { url: \"\", revision: null }, { url: \"\", revision: null }, { url: \"\", revision: null }, { url: \"\", revision: null }, { url: \"\", revision: null }, { url: \"\", revision: null }, { url: \"\", revision: null }, { url: \"\", revision: null }, { url: \"\", revision: null }, ]); /* * Images from SM.MS * i.loli.net | s2.loli.net | vip1.loli.net | vip2.loli.net | arina.loli.net | vip1.loli.io | vip2.loli.io | s1.baoshuo.ren | s1.u.sb * * Method: CacheFirst * cacheName: img-cache * cacheTime: 30d */ routing.registerRoute(/^https?:\\/\\/(?:(?:i|vip[1-2]|s[1-2])\\.loli\\.(?:io|net)|arina\\.loli\\.net|s1\\.(?:baoshuo\\.ren|u\\.sb))/, new CacheFirst({ cacheName: \"img-cache\" + cacheSuffixVersion, fetchOptions: { mode: \"cors\", credentials: \"omit\" }, plugins: [ new ExpirationPlugin({ maxAgeSeconds: 30 * 24 * 60 * 60, purgeOnQuotaError: true }), ] })); /* * CDN * cdnjs.baoshuo.ren | jsd.baoshuo.ren | static.cdn.baoshuo.ren * * Method: CacheFirst * cacheName: cdn-cache * cacheTime: 7d */ routing.registerRoute(function(param) { var url = param.url; return [ \"cdnjs.baoshuo.ren\", \"jsd.baoshuo.ren\", \"static.cdn.baoshuo.ren\" ].includes(url.hostname); }, new CacheFirst({ cacheName: \"cdn-cache\" + cacheSuffixVersion, fetchOptions: { mode: \"cors\", credentials: \"omit\" }, plugins: [ new ExpirationPlugin({ maxAgeSeconds: 7 * 24 * 60 * 60, purgeOnQuotaError: true }), ] })); /* * xTom Analytics - No Cache * stat.xtom.com | stat.u.sb * * Mathod: networkOnly */ routing.registerRoute(/https?:\\/\\/stat\\.(?:xtom\\.com|u\\.sb)/, new NetworkOnly({ plugins: [ new backgroundSync.BackgroundSyncPlugin(\"Optical_Collect\", { maxRetentionTime: 24 * 60 }), ] })); /* * Others img * Method: staleWhileRevalidate * cacheName: img-cache */ routing.registerRoute(// Cache image files /.*\\.(?:png|jpg|jpeg|svg|gif|webp)/, new StaleWhileRevalidate({ cacheName: \"img-cache\" + cacheSuffixVersion })); /* * Static Assets * Method: staleWhileRevalidate * cacheName: static-assets-cache */ routing.registerRoute(// Cache CSS files /.*\\.(css|js)/, // Use cache but update in the background ASAP new StaleWhileRevalidate({ cacheName: \"static-assets-cache\" + cacheSuffixVersion })); /* * sw.js - Revalidate every time * staleWhileRevalidate */ routing.registerRoute(\"/sw.js\", new StaleWhileRevalidate()); /* * Default - Serve as it is * networkFirst */ routing.setDefaultHandler(new NetworkFirst({ networkTimeoutSeconds: 3 }));"}]