<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宝硕博客</title>
  <icon>https://cdn.jsdelivr.net/npm/bsi@0.0.7/favicon/192x192.png</icon>
  
  <link href="https://oi.baoshuo.ren/atom.xml" rel="self"/>
  
  <link href="https://oi.baoshuo.ren/"/>
  <updated>2022-04-18T10:12:34.000Z</updated>
  <id>https://oi.baoshuo.ren/</id>
  
  <author>
    <name>宝硕</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「省选联考 2022 Day1」预处理器</title>
    <link href="https://oi.baoshuo.ren/solutions/luogu-p8289/"/>
    <id>https://oi.baoshuo.ren/solutions/luogu-p8289/</id>
    <published>2022-04-17T21:44:39.000Z</published>
    <updated>2022-04-18T10:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题面-27">题面</h2><h3 id="题目描述-27">题目描述</h3><p>宏是 C/C++ 语言的一项特性，它根据预先定义的规则进行文本替换（也被称为 “宏展开”），能够实现定义常量、简化代码重复输入等功能。例如：</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span><span class="type">double</span> area = PI * r * r;</code></pre><p>以上代码经过宏展开后变为：</p><pre><code class="highlight cpp"><span class="type">double</span> area = <span class="number">3.14159</span> * r * r;</code></pre><p>其中，宏定义命令变成了空行，而其他行中的宏被展开成了规则定义的文本。</p><p>C/C++ 语言代码在编译时对宏的处理由<strong>预处理器</strong>完成。你的任务是实现一个简化版的预处理器，要求如下：</p><ul><li><p>代码由<strong>行</strong>组成，每行除行末的换行符外，均由可打印 ASCII 字符（ASCII 码范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>∼</mo><mn>126</mn></mrow><annotation encoding="application/x-tex">32\sim 126</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">126</span></span></span></span>）组成。每行要么是 <strong>预处理命令</strong>（以 <code>#</code> 开头），要么是 <strong>普通文本</strong>（其他情况）。</p></li><li><p>预处理器逐行处理代码，</p><ul><li>如果是预处理命令，执行该命令，并输出一个空行。</li><li>如果是普通文本，对其进行宏展开并输出结果。</li></ul></li><li><p>预处理命令有两种，分别是宏定义命令 <code>#define</code> 和取消宏定义命令 <code>#undef</code>。</p><ul><li>宏定义命令的格式为 <code>#define &lt;name&gt; &lt;content&gt;</code>，其中第一部分 <code>#define</code> 是命令名，第二部分 <code>&lt;name&gt;</code> 是要定义的宏的名字，第三部分 <code>&lt;content&gt;</code> 是要定义的宏的展开内容。</li><li>取消宏定义命令的格式为 <code>#undef &lt;name&gt;</code>，其中第一部分 <code>#undef</code> 是命令名，第二部分 <code>&lt;name&gt;</code> 是要取消的宏的名字。</li></ul><p>以上两种预处理命令中，相邻两部分之间都严格用一个空格分隔。<code>&lt;name&gt;</code> 是由大小写字母和数字以及下划线组成的<strong>标识符</strong>（一个或多个字符），<code>&lt;content&gt;</code> 可以包含任意可打印 ASCII 字符（零个或多个字符）。一个宏定义的<strong>有效范围</strong>是从它定义所在行开始到后续最近的宏名匹配的取消定义所在行为止（如果没有对应的取消定义，则有效范围一直覆盖到文件结束）。</p></li></ul><p>对普通文本进行宏展开时，将一行文本中每段<strong>连续极长</strong>的大小写字母和数字以及下划线视为标识符（而不是其中一部分），其余为<strong>其他字符</strong>。从左到右依次对文本中的标识符进行宏展开：</p><ol><li><p>如果该标识符是有效的宏名，则用对应的展开内容替换它，此时该宏名进入正在展开的状态，直到本流程结束；否则原样保留宏名。例如，若宏 <code>A</code> 定义为 <code>b</code>，则文本 <code>A</code> 展开结果为 <code>b</code>（发生替换），文本 <code>B</code> 展开结果仍然为 <code>B</code>（未定义，不替换），文本 <code>AA</code> 展开结果仍然为 <code>AA</code>（<code>AA</code> 是不同于 <code>A</code> 的另一个标识符，未定义），而文本 <code>A*B</code> 展开结果为 <code>b*B</code>。</p></li><li><p>替换发生后，如果展开内容中包含标识符，重复应用以上的展开操作，称为 “多次展开”。例如，若宏 <code>A</code> 定义为 <code>B</code>，宏 <code>B</code> 定义为 <code>c</code>，则文本 <code>A</code> 的展开结果为 <code>c</code>。</p></li><li><p>如果待展开的宏名与正在进行展开的某个宏名相同，称为 “递归展开”，此时该宏名不再展开。本规则用来防止无限递归展开。例如，若宏 <code>A</code> 定义为 <code>B+a</code>，宏 <code>B</code> 定义为 <code>A+b</code>，则文本 <code>A</code> 展开结果为 <code>A+b+a</code>，由于最初的 <code>A</code> 处于正在展开状态，因此 <code>A+b+a</code> 里的 <code>A</code> 不再展开。</p></li><li><p>其他字符原样保留。</p></li></ol><p>注意：出于简化的目的，本题的要求与 C/C++ 语言标准里的描述不完全一致，请以上面的要求为准。最明显的区别是本题只有标识符和其他字符两类词法单元，没有数值、字符串、注释等。</p><h3 id="输入格式-27">输入格式</h3><p>输入的第一行包含一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，表示要处理的代码行数。</p><p>接下来的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行是要处理的代码。</p><h3 id="输出格式-27">输出格式</h3><p>输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，为输入逐行预处理后的结果。</p><h3 id="输入输出样例-22">输入输出样例</h3><p><strong>输入样例 #1</strong></p><pre><code class="highlight cpp"><span class="number">5</span><span class="meta">#<span class="keyword">define</span> BEGIN {</span><span class="meta">#<span class="keyword">define</span> END }</span><span class="meta">#<span class="keyword">define</span> INTEGER int</span><span class="keyword">class</span> <span class="title class_">C</span> BEGIN INTEGER x; END;<span class="function">INTEGER <span class="title">main</span><span class="params">()</span> BEGIN C c</span>; END</code></pre><p><strong>样例输出 #1</strong></p><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">C</span> { <span class="type">int</span> x; };<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{ C c; }</code></pre><p><strong>样例输入 #2</strong></p><p>见附件中的 <code>preprocessor/preprocessor2.in</code>。</p><p><strong>样例输入 #2</strong></p><p>见附件中的 <code>preprocessor/preprocessor2.ans</code>。</p><p><strong>样例输入 #3</strong></p><p>见附件中的 <code>preprocessor/preprocessor3.in</code>。</p><p><strong>样例输入 #3</strong></p><p>见附件中的 <code>preprocessor/preprocessor3.ans</code>。</p><h3 id="数据范围与约定-11">数据范围与约定</h3><p><strong>【数据范围】</strong></p><p>对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">20%</span></span></span></span> 的数据，不会出现宏定义命令 <code>#define</code> 和宏取消定义命令 <code>#undef</code>。</p><p>对另外 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">20%</span></span></span></span> 的数据，不会出现多次展开的情况，且不会出现宏取消定义命令 <code>#undef</code>。</p><p>对另外 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">20%</span></span></span></span> 的数据，不会出现多次展开的情况。</p><p>对另外 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">20%</span></span></span></span> 的数据，不会出现递归展开的情况。</p><p>对其余数据，无特殊限制。</p><p>对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n \leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span>，输入的每行字符数都不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span>，且保证输出的每行字符数都不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>（字符数均不计行末换行符）。保证输入数据中的预处理命令都是合法的，包含但不限于：</p><ul><li><code>#</code> 字符只会出现在预处理命令所在行的第一个字符的位置，其他任何位置（包括预处理命令和普通文本）都不会出现 <code>#</code> 字符。</li><li>宏定义和取消定义命令的格式是正确的，严格遵循题面所描述的格式。</li><li>同一个宏在取消定义之前不会被再次定义。</li><li>要取消定义的宏在之前被定义过且还没有被取消过。</li></ul><p>也就是说，<strong>你不需要做任何语法和语义的错误检查</strong>。</p><p><strong>【提示】</strong></p><p>本题进行输入时建议使用 C++ 语言的按行读入字符串功能，示例如下：</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;string line;<span class="comment">// 从 cin 读入一行，放入 line 中（换行符被舍弃）</span><span class="built_in">getline</span>(cin, line);</code></pre><p>也可以使用 C 语言提供的 <code>fgets</code> 函数，示例如下：</p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span><span class="meta">#<span class="keyword">define</span> MAX_LEN 200</span><span class="type">char</span> line[MAX_LEN];<span class="comment">// 从 stdin 读入一行，放入 line 中（包含换行符）</span><span class="built_in">fgets</span>(line, MAX_LEN, stdin);</code></pre><p><strong>注意</strong>：在读取行数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 之后可能需要额外读取一行以忽略其后的换行符。</p><h3 id="附加文件">附加文件</h3><ul><li><a href="https://1drv.ms/u/s!ArZFopRN1XYMpthQfe1qgllS5xPXzg?e=OWjgrd">样例文件</a><small>（1.7 KB）</small></li><li><a href="https://1drv.ms/u/s!ArZFopRN1XYMpthRiHrug-cxclUzrg?e=vWUYO8">民间数据</a><small>（洛谷，10.7 KB）</small></li></ul><h2 id="思路-30">思路</h2><p>这是一道不大不小的模拟题，有一些注意事项：</p><ol><li>判断有效的宏名（正则：<code>[A-Za-z0-9_]+</code>）比判断分隔符要容易实现。</li><li>题目有要求不能展开无限递归的宏，需要打标记记录一下。</li><li>STL 是个好东西。</li></ol><p>题外话：我在省选前不久碰见了一个短小精悍的 C 语言编译器，而里面正好有预处理相关的代码：<a href="https://github.com/rui314/chibicc/blob/90d1f7f199cc55b13c7fdb5839d1409806633fdb/preprocess.c"><code>preprocess.c</code> at rui314/chibicc@<code>90d1f7f</code></a>。可惜的是，这么长的代码我记不住，而且过于工程化，没有必要在考场上写这种东西。不过这个编译器和我曾经用到的 <a href="https://github.com/FullHuman/purgecss">PurgeCSS</a> 库为我提供了一些思路和实现上的点拨，使得我能在考场上切掉这道题，写出来的代码也不至于特别冗长。</p><h3 id="stl-相关">STL 相关</h3><p>一个非常好用的 C++ 参考手册（中文）：<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">zh.cppreference.com</a>。</p><p>在考场上如果不知道怎么用 STL 可以去翻头文件中的注释（英文），里面有简单的说明。</p><h4 id="std-string-入门"><code>std::string</code> 入门</h4><p>声明一个 <code>std::string</code> 类型的变量 <code>s</code>：</p><pre><code class="highlight cpp">std::string s = <span class="string">"abcdef"</span>;</code></pre><p>获取字符串长度：</p><pre><code class="highlight cpp">s.<span class="built_in">size</span>();<span class="comment">// 6</span></code></pre><p>判空：</p><pre><code class="highlight cpp">s.<span class="built_in">empty</span>();<span class="comment">// false</span></code></pre><p>截取子串：</p><pre><code class="highlight cpp">s.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// s 中从 1 开始长度为 3 的子串</span><span class="comment">// "bcd"</span></code></pre><p>查找字串：</p><pre><code class="highlight cpp">s.<span class="built_in">find</span>(<span class="string">"cde"</span>, <span class="number">1</span>);  <span class="comment">// s 中从下标为 1 的位置开始查找字串 "cde"</span><span class="comment">// 2</span></code></pre><p>同样地，也可以查找某个字符出现的位置：</p><pre><code class="highlight cpp">s.<span class="built_in">find</span>(<span class="string">'c'</span>);  <span class="comment">// s 中第一次出现的 'c'</span><span class="comment">// 2</span></code></pre><p>STL 也提供了其他查找函数：</p><ul><li><code>find_first_of</code>：查找字符串中第一个包含指定字符的位置。</li><li><code>find_last_of</code>：查找字符串中最后一个包含指定字符的位置。</li><li><code>find_first_not_of</code>：查找字符串中第一个不包含指定字符的位置。</li><li><code>find_last_not_of</code>：查找字符串中最后一个不包含指定字符的位置。</li></ul><p>使用方法与上面的 <code>find</code> 函数类似，不再过多赘述。</p><p>清空字符串：</p><pre><code class="highlight cpp">s.<span class="built_in">clear</span>();</code></pre><h4 id="std-unordered-map-入门"><code>std::unordered_map</code> 入门</h4><p><code>std::unordered_map</code> 在 C++11 中被引入，由于其基于哈希的实现导致了在大多数情况下 <code>std::unordered_map</code> 比 <code>std::map</code> 要快。</p><p>声明一个 <code>std::unordered_map&lt;std::string, int&gt;</code> 类型的变量 <code>map</code>：</p><pre><code class="highlight cpp">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</code></pre><p>插入元素：</p><pre><code class="highlight cpp">map[<span class="string">"a"</span>] = <span class="number">1</span>;map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">"b"</span>, <span class="number">2</span>));  <span class="comment">// pair 的 first 键值为 key，second 键值为 value</span>map[<span class="string">"c"</span>] = <span class="number">-1</span>;</code></pre><p>查找元素：</p><pre><code class="highlight cpp">map.<span class="built_in">find</span>(<span class="string">"c"</span>);  <span class="comment">// 返回迭代器</span>map.<span class="built_in">count</span>(<span class="string">"c"</span>); <span class="comment">// 返回元素个数（1 或 0）</span></code></pre><p>删除迭代器 <code>it</code> 指向的元素：</p><pre><code class="highlight cpp"><span class="keyword">auto</span> it = map.<span class="built_in">find</span>(<span class="string">"c"</span>);map.<span class="built_in">erase</span>(it);</code></pre><p>删除键为 <code>c</code> 的元素：</p><pre><code class="highlight cpp">map.<span class="built_in">erase</span>(<span class="string">"c"</span>);</code></pre><p>获取元素个数：</p><pre><code class="highlight cpp">map.<span class="built_in">size</span>();<span class="comment">// 2</span></code></pre><p>判空：</p><pre><code class="highlight cpp">map.<span class="built_in">empty</span>();<span class="comment">// false</span></code></pre><p>访问元素：</p><pre><code class="highlight cpp">map[<span class="string">"a"</span>];<span class="comment">// 1</span></code></pre><p>使用下标访问时如果元素不存在会自动新建，所以建议访问前先使用 <code>map.count()</code> 判断是否存在该元素。</p><p>清空整个容器：</p><pre><code class="highlight cpp">map.<span class="built_in">clear</span>();</code></pre><h2 id="代码-30">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="type">const</span> <span class="type">char</span> endl = <span class="string">'\n'</span>;<span class="comment">// 题目限制</span><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;<span class="comment">// 代码行数</span><span class="type">int</span> n;<span class="comment">// 原始字符串</span>std::string s[N];<span class="comment">// 宏列表：        &lt;宏名,                 &lt;内容,     正在展开&gt;&gt;</span>std::unordered_map&lt;std::string, std::pair&lt;std::string, <span class="type">bool</span>&gt;&gt; def;<span class="comment">/**</span><span class="comment"> * 递归展开</span><span class="comment"> * @param s 原始字符串</span><span class="comment"> * @return 展开后的字符串</span><span class="comment"> */</span><span class="function">std::string <span class="title">dfs</span><span class="params">(std::string s)</span> </span>{    std::string r;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j; i &lt; s.<span class="built_in">size</span>(); i += j) {        <span class="keyword">for</span> (j = <span class="number">0</span>; i + j &lt; s.<span class="built_in">size</span>() &amp;&amp;                     <span class="comment">// 防止越界</span>                    (<span class="string">'0'</span> &lt;= s[i + j] &amp;&amp; s[i + j] &lt;= <span class="string">'9'</span> ||  <span class="comment">// 数字</span>                     <span class="string">'a'</span> &lt;= s[i + j] &amp;&amp; s[i + j] &lt;= <span class="string">'z'</span> ||  <span class="comment">// 小写字母</span>                     <span class="string">'A'</span> &lt;= s[i + j] &amp;&amp; s[i + j] &lt;= <span class="string">'Z'</span> ||  <span class="comment">// 大写字母</span>                     s[i + j] == <span class="string">'_'</span>);                      <span class="comment">// 下划线</span>             j++)            ;  <span class="comment">// 匹配合法宏名</span>        <span class="keyword">if</span> (j) {            std::string tmp = s.<span class="built_in">substr</span>(i, j);  <span class="comment">// 截取从 i 开始的 j 个字符</span>            <span class="keyword">if</span> (def.<span class="built_in">count</span>(tmp) &amp;&amp; !def[tmp].second) {  <span class="comment">// 该宏存在且未处在展开状态</span>                def[tmp].second = <span class="literal">true</span>;                <span class="comment">// 将该宏标记为正在展开</span>                r += <span class="built_in">dfs</span>(def[tmp].first);              <span class="comment">// 递归展开</span>                def[tmp].second = <span class="literal">false</span>;               <span class="comment">// 取消标记</span>            } <span class="keyword">else</span> {                r += tmp;  <span class="comment">// 不存在直接按原样加入到结果中</span>            }        } <span class="keyword">else</span> {            r += s[i++];  <span class="comment">// 不合法，直接略过，加入到结果中</span>        }    }    <span class="keyword">return</span> r;}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    cin &gt;&gt; n;    <span class="comment">// 第 0 行读入 n 后尾随的换行符</span>    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) {        std::<span class="built_in">getline</span>(cin, s[i]);    }    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        <span class="keyword">if</span> (s[i][<span class="number">0</span>] == <span class="string">'#'</span>) {  <span class="comment">// 预处理命令</span>            <span class="keyword">if</span> (s[i].<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">6</span>) == <span class="string">"define"</span>) {                <span class="type">int</span> p = s[i].<span class="built_in">find_first_of</span>(<span class="string">' '</span>, <span class="number">8</span>);  <span class="comment">// 宏名后的空格位置</span>                std::string name = s[i].<span class="built_in">substr</span>(<span class="number">8</span>, p - <span class="number">8</span>),                            content = s[i].<span class="built_in">substr</span>(p + <span class="number">1</span>);                <span class="comment">// 插入内容</span>                def[name] = std::<span class="built_in">make_pair</span>(content, <span class="literal">false</span>);            } <span class="keyword">else</span> {  <span class="comment">// s[i].substr(1, 6) == "undef"</span>                std::string name = s[i].<span class="built_in">substr</span>(<span class="number">7</span>);                def.<span class="built_in">erase</span>(name);            }            cout &lt;&lt; endl;        } <span class="keyword">else</span> {  <span class="comment">// 普通文本</span>            cout &lt;&lt; <span class="built_in">dfs</span>(s[i]) &lt;&lt; endl;        }    }    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题面-27&quot;&gt;题面&lt;/h2&gt;
&lt;h3 id=&quot;题目描述-27&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;宏是 C/C++ 语言的一项特性，它根据预先定义的规则进行文本替换（也被称为 “宏展开”），能够实现定义常量、简化代码重复输</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="模拟" scheme="https://oi.baoshuo.ren/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="省选" scheme="https://oi.baoshuo.ren/tags/%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 - P1541 [NOIP2010 提高组] 乌龟棋</title>
    <link href="https://oi.baoshuo.ren/solutions/luogu-p1541/"/>
    <id>https://oi.baoshuo.ren/solutions/luogu-p1541/</id>
    <published>2022-03-29T21:16:32.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题面-13">题面</h2><h3 id="题目背景-3">题目背景</h3><p>小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。</p><h3 id="题目描述-13">题目描述</h3><p>乌龟棋的棋盘是一行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个格子，每个格子上一个分数（非负整数）。棋盘第 1 格是唯一的起点，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</p><p>乌龟棋中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 张爬行卡片，分成 4 种不同的类型（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 张卡片中不一定包含所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 种类型的卡片，见样例），每种类型的卡片上分别标有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">1, 2, 3, 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span></span></span></span> 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</p><p>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</p><p>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。</p><p>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</p><h3 id="输入格式-13">输入格式</h3><p>每行中两个数之间用一个空格隔开。</p><p>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N, M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，分别表示棋盘格子数和爬行卡片数。</p><p>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个非负整数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">a_1, a_2, \ldots, a_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示棋盘第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个格子上的分数。</p><p>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个整数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>b</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">b_1, b_2, \ldots, b_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 张爬行卡片上的数字。</p><p>输入数据保证到达终点时刚好用光 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 张爬行卡片。</p><h3 id="输出格式-13">输出格式</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个整数，表示小明最多能得到的分数。</p><h3 id="输入输出样例-9">输入输出样例</h3><p><strong>输入样例 #1</strong></p><pre><code class="highlight text">9 56 10 14 2 8 8 18 5 171 3 1 2 1</code></pre><p><strong>输出样例 #1</strong></p><pre><code class="highlight text">73</code></pre><p><strong>样例解释 #1</strong></p><h2 id="思路-14">思路</h2><p>多维 DP 经典题。</p><p>可以考虑设置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 个维度，每个维度分别记录 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">1, 2, 3, 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span></span></span></span> 号卡片的状态，而当前所在的格就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn><mi>j</mi><mo>+</mo><mn>3</mn><mi>k</mi><mo>+</mo><mn>4</mn><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i + 2j + 3k + 4l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">3</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>得转移方程如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn><mi>j</mi><mo>+</mo><mn>3</mn><mi>k</mi><mo>+</mo><mn>4</mn><mi>l</mi></mrow></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn><mi>j</mi><mo>+</mo><mn>3</mn><mi>k</mi><mo>+</mo><mn>4</mn><mi>l</mi></mrow></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>j</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn><mi>j</mi><mo>+</mo><mn>3</mn><mi>k</mi><mo>+</mo><mn>4</mn><mi>l</mi></mrow></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn><mi>j</mi><mo>+</mo><mn>3</mn><mi>k</mi><mo>+</mo><mn>4</mn><mi>l</mi></mrow></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>l</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}&amp; f_{i, j, k, l} = \max(f_{i, j, k, l}, f_{i - 1, j, k, l}) + a_{i + 2j + 3k + 4l} &amp; (i &gt; 0) \\&amp; f_{i, j, k, l} = \max(f_{i, j, k, l}, f_{i, j - 1, k, l}) + a_{i + 2j + 3k + 4l} &amp; (j &gt; 0) \\&amp; f_{i, j, k, l} = \max(f_{i, j, k, l}, f_{i, j, k - 1, l}) + a_{i + 2j + 3k + 4l} &amp; (k &gt; 0) \\&amp; f_{i, j, k, l} = \max(f_{i, j, k, l}, f_{i, j, k, l - 1}) + a_{i + 2j + 3k + 4l} &amp; (l &gt; 0) \\\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-0.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">3</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">3</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">3</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">3</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>b</mi><mn>3</mn></msub><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>l</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>b</mi><mn>4</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in [0, b_1], j \in [0, b_2], k \in [0, b_3], l \in [0, b_4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>。</p><h2 id="代码-14">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="type">const</span> <span class="type">char</span> endl = <span class="string">'\n'</span>;<span class="type">const</span> <span class="type">int</span> N = <span class="number">355</span>,          M = <span class="number">125</span>;<span class="type">int</span> n, m, a[N], b[<span class="number">5</span>], f[M][M][M][M];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    cin &gt;&gt; n &gt;&gt; m;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        cin &gt;&gt; a[i];    }    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= m; i++) {        cin &gt;&gt; x;        b[x]++;    }    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>];    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= b[<span class="number">1</span>]; i++) {        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= b[<span class="number">2</span>]; j++) {            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= b[<span class="number">3</span>]; k++) {                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt;= b[<span class="number">4</span>]; l++) {                    f[i][j][k][l] = std::<span class="built_in">max</span>({i ? f[i - <span class="number">1</span>][j][k][l] : <span class="number">0</span>,                                              j ? f[i][j - <span class="number">1</span>][k][l] : <span class="number">0</span>,                                              k ? f[i][j][k - <span class="number">1</span>][l] : <span class="number">0</span>,                                              l ? f[i][j][k][l - <span class="number">1</span>] : <span class="number">0</span>}) +                                    a[<span class="number">1</span> + i + j * <span class="number">2</span> + k * <span class="number">3</span> + l * <span class="number">4</span>];                }            }        }    }    cout &lt;&lt; f[b[<span class="number">1</span>]][b[<span class="number">2</span>]][b[<span class="number">3</span>]][b[<span class="number">4</span>]] &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题面-13&quot;&gt;题面&lt;/h2&gt;
&lt;h3 id=&quot;题目背景-3&quot;&gt;题目背景&lt;/h3&gt;
&lt;p&gt;小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。&lt;/p&gt;
&lt;h3 id=&quot;题目描述-13&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;乌龟棋的</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="https://oi.baoshuo.ren/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="洛谷" scheme="https://oi.baoshuo.ren/tags/%E6%B4%9B%E8%B0%B7/"/>
    
    <category term="线性 DP" scheme="https://oi.baoshuo.ren/tags/%E7%BA%BF%E6%80%A7-DP/"/>
    
    <category term="多维 DP" scheme="https://oi.baoshuo.ren/tags/%E5%A4%9A%E7%BB%B4-DP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 - P2389 电脑班的裁员</title>
    <link href="https://oi.baoshuo.ren/solutions/luogu-p2389/"/>
    <id>https://oi.baoshuo.ren/solutions/luogu-p2389/</id>
    <published>2022-03-23T17:06:06.000Z</published>
    <updated>2022-04-03T08:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题面-18">题面</h2><h3 id="题目背景-4">题目背景</h3><p>隔壁的新初一电脑班刚考过一场试，又到了 BlingBling 的裁员时间，老师把这项工作交给了 ZZY 来进行。而 ZZY 最近忙着刷题，就把这重要的任务交（tui）给了你。</p><h3 id="题目描述-18">题目描述</h3><p>ZZY 有独特的裁员技巧：每个同学都有一个考试得分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个同学中选出不大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 段相邻的同学留下，裁掉未被选中的同学，使剩下同学的得分和最大。要特别注意的是，这次考试答错要扣分，所以得分有可能为负。</p><h3 id="输入格式-18">输入格式</h3><p>第一行为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n, k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，第二行为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 位同学的得分。</p><h3 id="输出格式-18">输出格式</h3><p>一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>，为最大得分和。</p><h3 id="输入输出样例-14">输入输出样例</h3><p><strong>输入样例 #1</strong></p><pre><code class="highlight text">5 31 -1 1 -1 1</code></pre><p><strong>输出样例 #1</strong></p><pre><code class="highlight text">3</code></pre><h3 id="数据范围与约定-8">数据范围与约定</h3><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">k \leq n \leq 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">500</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">|a_i| \leq 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>。</p><h2 id="思路-19">思路</h2><p>动态规划，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 表示前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 段的最大价值。</p><ul><li>若不选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i, j} = f_{i - 1, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>；</li><li>若选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 则需要枚举最后一段的起始位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msubsup><mo>∑</mo><mrow><mi>p</mi><mo>=</mo><mi>l</mi></mrow><mi>i</mi></msubsup><msub><mi>a</mi><mi>p</mi></msub><mo stretchy="false">(</mo><mi>l</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_{i, j} = f_{l, j - 1} + \sum_{p = l}^{i} a_p (l \in [j - 1, i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4004em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9646em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span>。</li></ul><p>整理得转移方程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">{</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>p</mi><mo>=</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></munderover><msub><mi>a</mi><mi>p</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f_{i, j} = \max\{f_{i, j}, f_{i - 1, j}, f_{l, j - 1} + \sum_{p = l + 1}^{i} a_p\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop">max</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.2499em;vertical-align:-1.4382em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4382em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span></p><h2 id="代码-19">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="type">const</span> <span class="type">char</span> endl = <span class="string">'\n'</span>;<span class="type">const</span> <span class="type">int</span> N = <span class="number">505</span>;<span class="type">int</span> n, k, sum[N], f[N][N];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    cin &gt;&gt; n &gt;&gt; k;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        <span class="type">int</span> x;        cin &gt;&gt; x;        sum[i] = sum[i - <span class="number">1</span>] + x;    }    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) {            <span class="keyword">for</span> (<span class="type">int</span> l = j - <span class="number">1</span>; l &lt;= i; l++) {                f[i][j] = std::<span class="built_in">max</span>({f[i][j], f[i - <span class="number">1</span>][j], f[l][j - <span class="number">1</span>] + (sum[i] - sum[l])});            }        }    }    cout &lt;&lt; f[n][k] &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题面-18&quot;&gt;题面&lt;/h2&gt;
&lt;h3 id=&quot;题目背景-4&quot;&gt;题目背景&lt;/h3&gt;
&lt;p&gt;隔壁的新初一电脑班刚考过一场试，又到了 BlingBling 的裁员时间，老师把这项工作交给了 ZZY 来进行。而 ZZY 最</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="https://oi.baoshuo.ren/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="洛谷" scheme="https://oi.baoshuo.ren/tags/%E6%B4%9B%E8%B0%B7/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 - P2045 方格取数加强版</title>
    <link href="https://oi.baoshuo.ren/solutions/luogu-p2045/"/>
    <id>https://oi.baoshuo.ren/solutions/luogu-p2045/</id>
    <published>2022-03-22T13:27:06.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题面-15">题面</h2><h3 id="题目描述-15">题目描述</h3><p>给出一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的矩阵，每一格有一个非负整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 现在从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 出发，可以往右或者往下走，最后到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。每到达一格，把该格的数取出并将原位置归 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，这样一共走 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次，请你求出走 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次所达到的方格的数的和的最大值。</p><h3 id="输入格式-15">输入格式</h3><p>第一行两个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n, k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数，分别表示矩阵上的每个格子中的数。</p><h3 id="输出格式-15">输出格式</h3><p>走 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次所达到的方格的数的和的最大值。</p><h3 id="输入输出样例-11">输入输出样例</h3><p><strong>输入样例 #1</strong></p><pre><code class="highlight text">3 11 2 30 2 11 4 2</code></pre><p><strong>输出样例 #1</strong></p><pre><code class="highlight text">11</code></pre><h3 id="数据范围与约定-7">数据范围与约定</h3><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">1 \leq n \leq 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">0 \leq k \leq 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 \leq A_{i, j} \leq 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>。</p><h2 id="思路-16">思路</h2><p>按照网格建立网络，将每个点拆成入点和出点两个点，入点向出点连两条边：一条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>w</mi></mrow><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><mo>=</mo><mo>−</mo><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow></mrow><annotation encoding="application/x-tex">\mathit{flow} = 1, \mathit{cost} = -\mathit{val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathit">flow</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathit">cost</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathit">val</span></span></span></span></span> 表示第一次经过（负数是为了把最大费用最大流转化为最小费用最大流），另一条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>w</mi></mrow><mo>=</mo><mi>inf</mi><mo>⁡</mo><mo separator="true">,</mo><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathit{flow} = \inf, \mathit{cost} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathit">flow</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">in<span style="margin-right:0.07778em;">f</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathit">cost</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 供后几次经过使用。每个点的出点向右方和下方连 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>w</mi></mrow><mo>=</mo><mi>inf</mi><mo>⁡</mo><mo separator="true">,</mo><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathit{flow} = \inf, \mathit{cost} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathit">flow</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">in<span style="margin-right:0.07778em;">f</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathit">cost</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的边。之后将从超级源点向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>、从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 向超级汇点分别连两条 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>w</mi></mrow><mo>=</mo><mi>k</mi><mo separator="true">,</mo><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathit{flow} = k, \mathit{cost} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathit">flow</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathit">cost</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的边，再求出最小费用最大流即可。</p><p>最后输出答案时别忘了将负数再转回正数。</p><h2 id="代码-16">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="type">const</span> <span class="type">char</span> endl = <span class="string">'\n'</span>;<span class="type">const</span> <span class="type">int</span> N = <span class="number">5005</span>,          M = <span class="number">100005</span>,          INF = <span class="number">0x3f3f3f3f</span>;<span class="type">int</span> n, k, s, t, ans;<span class="comment">// Graph</span><span class="type">int</span> idx, head[N], ver[M &lt;&lt; <span class="number">1</span>], next[M &lt;&lt; <span class="number">1</span>];std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; edge[M &lt;&lt; <span class="number">1</span>];<span class="comment">//      &lt;flow, cost&gt;</span><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> flow, <span class="type">int</span> cost)</span> </span>{    next[idx] = head[u];    ver[idx] = v;    edge[idx] = std::<span class="built_in">make_pair</span>(flow, cost);    head[u] = idx++;}<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k = <span class="number">0</span>)</span> </span>{    <span class="keyword">return</span> (i - <span class="number">1</span>) * n + j + k * n * n;}<span class="comment">// Dinic</span><span class="type">int</span> dist[N];<span class="type">bool</span> vis[N];<span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>{    <span class="built_in">memset</span>(vis, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(vis));    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));    std::queue&lt;<span class="type">int</span>&gt; q;    q.<span class="built_in">push</span>(s);    dist[s] = <span class="number">0</span>;    vis[s] = <span class="literal">true</span>;    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {        <span class="type">int</span> u = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        vis[u] = <span class="literal">false</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = next[i]) {            <span class="type">int</span> v = ver[i],                c = edge[i].first,                w = edge[i].second;            <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; dist[v] &gt; dist[u] + w) {                dist[v] = dist[u] + w;                <span class="keyword">if</span> (!vis[v]) {                    q.<span class="built_in">push</span>(v);                    vis[v] = <span class="literal">true</span>;                }            }        }    }    <span class="keyword">return</span> dist[t] != INF;}<span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>{    <span class="keyword">if</span> (u == t) <span class="keyword">return</span> limit;    <span class="type">int</span> flow = <span class="number">0</span>;    vis[u] = <span class="literal">true</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i &amp;&amp; flow &lt; limit; i = next[i]) {        <span class="type">int</span> v = ver[i],            c = edge[i].first,            w = edge[i].second;        <span class="keyword">if</span> (dist[v] == dist[u] + w &amp;&amp; c &amp;&amp; !vis[v]) {            <span class="type">int</span> k = <span class="built_in">dinic</span>(v, std::<span class="built_in">min</span>(c, limit - flow));            <span class="keyword">if</span> (!k) dist[v] = INF;            edge[i].first -= k;            edge[i ^ <span class="number">1</span>].first += k;            flow += k;            ans += k * w;        }    }    vis[u] = <span class="literal">false</span>;    <span class="keyword">return</span> flow;}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(head));    cin &gt;&gt; n &gt;&gt; k;    s = <span class="number">0</span>;    <span class="built_in">add</span>(s, <span class="built_in">id</span>(<span class="number">1</span>, <span class="number">1</span>), k, <span class="number">0</span>);    <span class="built_in">add</span>(<span class="built_in">id</span>(<span class="number">1</span>, <span class="number">1</span>), s, <span class="number">0</span>, <span class="number">0</span>);    t = <span class="built_in">id</span>(n, n, <span class="number">1</span>) + <span class="number">1</span>;    <span class="built_in">add</span>(<span class="built_in">id</span>(n, n, <span class="number">1</span>), t, k, <span class="number">0</span>);    <span class="built_in">add</span>(t, <span class="built_in">id</span>(n, n, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {            <span class="type">int</span> w;            cin &gt;&gt; w;            <span class="built_in">add</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i, j, <span class="number">1</span>), <span class="number">1</span>, -w);            <span class="built_in">add</span>(<span class="built_in">id</span>(i, j, <span class="number">1</span>), <span class="built_in">id</span>(i, j), <span class="number">0</span>, w);            <span class="built_in">add</span>(<span class="built_in">id</span>(i, j), <span class="built_in">id</span>(i, j, <span class="number">1</span>), INF, <span class="number">0</span>);            <span class="built_in">add</span>(<span class="built_in">id</span>(i, j, <span class="number">1</span>), <span class="built_in">id</span>(i, j), <span class="number">0</span>, <span class="number">0</span>);            <span class="keyword">if</span> (i &lt; n) {                <span class="built_in">add</span>(<span class="built_in">id</span>(i, j, <span class="number">1</span>), <span class="built_in">id</span>(i + <span class="number">1</span>, j), INF, <span class="number">0</span>);                <span class="built_in">add</span>(<span class="built_in">id</span>(i + <span class="number">1</span>, j), <span class="built_in">id</span>(i, j, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>);            }            <span class="keyword">if</span> (j &lt; n) {                <span class="built_in">add</span>(<span class="built_in">id</span>(i, j, <span class="number">1</span>), <span class="built_in">id</span>(i, j + <span class="number">1</span>), INF, <span class="number">0</span>);                <span class="built_in">add</span>(<span class="built_in">id</span>(i, j + <span class="number">1</span>), <span class="built_in">id</span>(i, j, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>);            }        }    }    <span class="keyword">while</span> (<span class="built_in">spfa</span>()) <span class="built_in">dinic</span>(s, INF);    cout &lt;&lt; -ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题面-15&quot;&gt;题面&lt;/h2&gt;
&lt;h3 id=&quot;题目描述-15&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给出一个 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmln</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="洛谷" scheme="https://oi.baoshuo.ren/tags/%E6%B4%9B%E8%B0%B7/"/>
    
    <category term="网络流" scheme="https://oi.baoshuo.ren/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="https://oi.baoshuo.ren/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 - P2774 方格取数问题</title>
    <link href="https://oi.baoshuo.ren/solutions/luogu-p2774/"/>
    <id>https://oi.baoshuo.ren/solutions/luogu-p2774/</id>
    <published>2022-03-21T21:31:01.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本题有多个提交渠道：</p><ul><li><a href="https://www.luogu.com.cn/problem/P2774">洛谷 P2774</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/f96c5fed7de1123841901921bc4fe709dd04dba3"><code>f96c5fe</code></a>)</small></li><li><a href="https://loj.ac/p/6007">LibreOJ #6007</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/2d4425838122c90bd96a7b60c5390d54f6a47298"><code>2d44258</code></a>)</small></li><li><a href="https://hydro.ac/d/bzoj/p/1475">BZOJ 1475 (on Hydro)</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/43622a230eed458b9738826c2abdf40a27186e94"><code>43622a2</code></a>)</small></li></ul><hr><h2 id="题面-19">题面</h2><h3 id="题目描述-19">题目描述</h3><p>有一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。</p><h3 id="输入格式-19">输入格式</h3><p>第一行是两个用空格隔开的整数，分别代表方格图的行数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 和列数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(m + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 行的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个整数代表方格图第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 列的的方格中的数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</p><h3 id="输出格式-19">输出格式</h3><p>输出一行一个整数，代表和最大是多少。</p><h3 id="样例输入输出">样例输入输出</h3><p><strong>样例输入 #1</strong></p><pre><code class="highlight text">3 31 2 33 2 32 3 1</code></pre><p><strong>样例输出 #1</strong></p><pre><code class="highlight text">11</code></pre><h3 id="数据规模与约定-2">数据规模与约定</h3><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1 \leq n, m \leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq a_{i, j} \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9221em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><h2 id="思路-21">思路</h2><p>可以对整个方格图进行黑白染色，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>2</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(x + y) \bmod 2 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的点设为黑点，如下图所示：</p><table style="margin: 2rem auto;"><tbody>  <tr>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #fff"></td>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #000"></td>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #fff"></td>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #000"></td>  </tr>  <tr>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #000"></td>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #fff"></td>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #000"></td>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #fff"></td>  </tr>  <tr>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #fff"></td>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #000"></td>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #fff"></td>    <td style="height: 2.5em; width: 2.5em; padding: 0; background: #000"></td>  </tr></tbody></table><p>可以发现，若取一个黑格的点，受到影响的就是周围的白点。然后可以建一个二分图，这道题就可以用最小割求解了。</p><p>新建一个超级源点，将所有黑点连到这个超级源点上，容量为点权；<br>再新建一个超级汇点，将所有白点连接到这个超级汇点上，容量为点权；<br>最后将每一个黑点连接到会被这个点影响到的白点上，容量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">+ \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span>。</p><p>答案为方格图中所有点的点权和再减去最小割。</p><h2 id="代码-21">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="type">const</span> <span class="type">char</span> endl = <span class="string">'\n'</span>;<span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>,          M = <span class="number">100005</span>;<span class="type">const</span> <span class="type">int</span> to[<span class="number">4</span>][<span class="number">2</span>] = {{<span class="number">0</span>, <span class="number">1</span>}, {<span class="number">0</span>, <span class="number">-1</span>}, {<span class="number">1</span>, <span class="number">0</span>}, {<span class="number">-1</span>, <span class="number">0</span>}};<span class="type">int</span> m, n, u, s, t, flow, ans, sum;<span class="comment">// Graph</span><span class="type">int</span> idx, head[N], edge[M &lt;&lt; <span class="number">1</span>], ver[M &lt;&lt; <span class="number">1</span>], next[M &lt;&lt; <span class="number">1</span>];<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>{    next[idx] = head[u];    ver[idx] = v;    edge[idx] = w;    head[u] = idx++;}<span class="comment">// Dinic</span><span class="type">int</span> d[N], cur[N];<span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>{    <span class="built_in">memset</span>(d, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(d));    std::queue&lt;<span class="type">int</span>&gt; q;    d[s] = <span class="number">1</span>;    q.<span class="built_in">push</span>(s);    cur[s] = head[s];    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {        <span class="type">int</span> u = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = next[i]) {            <span class="type">int</span> v = ver[i],                w = edge[i];            <span class="keyword">if</span> (w &amp;&amp; !d[v]) {                d[v] = d[u] + <span class="number">1</span>;                cur[v] = head[v];                <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;                q.<span class="built_in">push</span>(v);            }        }    }    <span class="keyword">return</span> <span class="literal">false</span>;}<span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>{    <span class="keyword">if</span> (u == t) <span class="keyword">return</span> limit;    <span class="type">int</span> flow = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = next[i]) {        <span class="type">int</span> v = ver[i],            w = edge[i];        <span class="keyword">if</span> (w &amp;&amp; d[v] == d[u] + <span class="number">1</span>) {            <span class="type">int</span> k = <span class="built_in">dinic</span>(v, std::<span class="built_in">min</span>(limit - flow, w));            <span class="keyword">if</span> (!k) d[v] = <span class="number">0</span>;            edge[i] -= k;            edge[i ^ <span class="number">1</span>] += k;            flow += k;        }    }    <span class="keyword">return</span> flow;}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(head));    cin &gt;&gt; n &gt;&gt; m;    s = <span class="number">0</span>, t = n * m + <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {            <span class="type">int</span> w, u = (i - <span class="number">1</span>) * m + j;            cin &gt;&gt; w;            sum += w;            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) {                <span class="built_in">add</span>(s, u, w);                <span class="built_in">add</span>(u, s, <span class="number">0</span>);                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) {                    <span class="type">int</span> xx = i + to[k][<span class="number">0</span>],                        yy = j + to[k][<span class="number">1</span>];                    <span class="keyword">if</span> (<span class="number">1</span> &lt;= xx &amp;&amp; xx &lt;= n &amp;&amp; <span class="number">1</span> &lt;= yy &amp;&amp; yy &lt;= m) {                        <span class="type">int</span> v = (xx - <span class="number">1</span>) * m + yy;                        <span class="built_in">add</span>(u, v, std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>());                        <span class="built_in">add</span>(v, u, <span class="number">0</span>);                    }                }            } <span class="keyword">else</span> {                <span class="built_in">add</span>(u, t, w);                <span class="built_in">add</span>(t, u, <span class="number">0</span>);            }        }    }    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) {        <span class="keyword">while</span> (flow = <span class="built_in">dinic</span>(s, std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>())) ans += flow;    }    cout &lt;&lt; sum - ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本题有多个提交渠道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2774&quot;&gt;洛谷 P2774&lt;/a&gt; &lt;small&gt;(&lt;a href=&quot;https://g</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="LibreOJ" scheme="https://oi.baoshuo.ren/tags/LibreOJ/"/>
    
    <category term="洛谷" scheme="https://oi.baoshuo.ren/tags/%E6%B4%9B%E8%B0%B7/"/>
    
    <category term="网络流" scheme="https://oi.baoshuo.ren/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="BZOJ" scheme="https://oi.baoshuo.ren/tags/BZOJ/"/>
    
    <category term="Hydro" scheme="https://oi.baoshuo.ren/tags/Hydro/"/>
    
    <category term="最大流" scheme="https://oi.baoshuo.ren/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
    <category term="网络流 24 题" scheme="https://oi.baoshuo.ren/tags/%E7%BD%91%E7%BB%9C%E6%B5%81-24-%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>P2891 [USACO07OPEN] Dining G</title>
    <link href="https://oi.baoshuo.ren/solutions/luogu-p2891/"/>
    <id>https://oi.baoshuo.ren/solutions/luogu-p2891/</id>
    <published>2022-03-19T21:45:11.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题面-20">题面</h2><p><em>本文中所给出的题面为原题面的中文翻译，并非原始题面。翻译如有错误之处，请联系指出。</em></p><h3 id="题目描述-20">题目描述</h3><p>奶牛就是这么挑食。每头奶牛都有自己喜欢的食物和饮料，她不会吃她不喜欢的食物和或者喝她不喜欢的饮料。</p><p>农夫约翰为他的奶牛做了美味的饭菜，但他忘记根据她们的喜好检查他的菜单。虽然他可能无法让每头奶牛都吃饱，但他想让尽可能多的奶牛吃一顿符合她们喜好的饭。</p><p>农夫约翰烹制了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 种食物并准备了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> 种饮料。他的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 头奶牛中的每一头都给出了她喜欢吃的食物种类和饮料种类。农夫约翰必须为每头奶牛分配一种食物类型和一种饮料类型，以最大限度地增加同时获得这两种食物的奶牛数量。</p><p>每道菜或饮料只能由一头牛食用（即一旦将种类编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的食物分配给一头牛，就不能再将这种食物分配给其他牛）。</p><h3 id="输入格式-20">输入格式</h3><p>第一行包含三个以空格分隔的整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">N, F, D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>。</p><p>接下来有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行数据。第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行以两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F_i, D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 开头，即奶牛喜欢吃的食物种类的数量和喜欢喝的饮料种类的数量。之后有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个整数给出了第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 头奶牛喜欢吃的菜的编号，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个整数给出了第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 头奶牛喜欢喝的饮料种类的编号。</p><h3 id="输出格式-20">输出格式</h3><p>一行一个整数，表示可以享受到自己喜欢的食物和饮料的奶牛的最大数量。</p><h3 id="输入输出样例-15">输入输出样例</h3><p><strong>输入样例 #1</strong></p><pre><code class="highlight text">4 3 32 2 1 2 3 12 2 2 3 1 22 2 1 3 1 22 1 1 3 3</code></pre><p><strong>输出样例 #1</strong></p><pre><code class="highlight text">3</code></pre><h3 id="数据范围与提示">数据范围与提示</h3><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mi>F</mi><mo separator="true">,</mo><mi>D</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1 \leq N, F, D \leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span>。</p><h2 id="思路-22">思路</h2><p>本题的难点主要在于建图。</p><p>一种很容易想到的做法是建立一个超级源点连接食物，食物连牛，牛连饮料，饮料连接超级汇点，然后再跑一遍最大流。但这个算法是错误的，它可能会重复选择同一只奶牛。</p><details><summary>Hack 数据</summary><p><strong>输入数据</strong></p><pre><code class="highlight text">1 2 22 2 1 2 1 2</code></pre><p><strong>错误答案</strong></p><pre><code class="highlight text">2</code></pre><p><strong>正确答案</strong></p><pre><code class="highlight text">1</code></pre></details><p>那么可以运用拆点的思想，将一只奶牛拆成两个点，食物连入点，出点连饮料，就避免了重复选择的问题。</p><p>之后再跑网络流求出答案即可。</p><h2 id="代码-22">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="type">const</span> <span class="type">char</span> endl = <span class="string">'\n'</span>;<span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>,          M = <span class="number">10005</span>;<span class="type">int</span> n, f, d, flow, ans;<span class="comment">// Graph</span><span class="type">int</span> idx, head[N], edge[M &lt;&lt; <span class="number">1</span>], ver[M &lt;&lt; <span class="number">1</span>], next[M &lt;&lt; <span class="number">1</span>];<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>{    next[idx] = head[u];    ver[idx] = v;    edge[idx] = w;    head[u] = idx++;}<span class="comment">// Dinic</span><span class="type">int</span> dist[N], cur[N];<span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>{    <span class="built_in">memset</span>(dist, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(dist));    std::queue&lt;<span class="type">int</span>&gt; q;    q.<span class="built_in">push</span>(<span class="number">0</span>);    dist[<span class="number">0</span>] = <span class="number">1</span>;    cur[<span class="number">0</span>] = head[<span class="number">0</span>];    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {        <span class="type">int</span> u = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = next[i]) {            <span class="type">int</span> v = ver[i],                w = edge[i];            <span class="keyword">if</span> (w &amp;&amp; !dist[v]) {                dist[v] = dist[u] + <span class="number">1</span>;                cur[v] = head[v];                <span class="keyword">if</span> (v == n) <span class="keyword">return</span> <span class="literal">true</span>;                q.<span class="built_in">push</span>(v);            }        }    }    <span class="keyword">return</span> <span class="literal">false</span>;}<span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>{    <span class="keyword">if</span> (u == n) <span class="keyword">return</span> limit;    <span class="type">int</span> flow = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = next[i]) {        <span class="type">int</span> v = ver[i],            w = edge[i];        <span class="keyword">if</span> (dist[v] == dist[u] + <span class="number">1</span> &amp;&amp; w) {            <span class="type">int</span> k = <span class="built_in">dinic</span>(v, std::<span class="built_in">min</span>(w, limit - flow));            <span class="keyword">if</span> (!k) dist[v] = <span class="number">0</span>;            edge[i] -= k;            edge[i ^ <span class="number">1</span>] += k;            flow += k;        }    }    <span class="keyword">return</span> flow;}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(head));    cin &gt;&gt; n &gt;&gt; f &gt;&gt; d;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= f; i++) {        <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">1</span>);        <span class="built_in">add</span>(i, <span class="number">0</span>, <span class="number">0</span>);    }    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        <span class="type">int</span> ff, dd;        cin &gt;&gt; ff &gt;&gt; dd;        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ff; j++) {            <span class="type">int</span> x;            cin &gt;&gt; x;            <span class="built_in">add</span>(x, f + d + i, <span class="number">1</span>);            <span class="built_in">add</span>(f + d + i, x, <span class="number">0</span>);        }        <span class="built_in">add</span>(f + d + i, f + d + n + i, <span class="number">1</span>);        <span class="built_in">add</span>(f + d + n + i, f + d + i, <span class="number">0</span>);        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= dd; j++) {            <span class="type">int</span> x;            cin &gt;&gt; x;            <span class="built_in">add</span>(f + d + n + i, f + x, <span class="number">1</span>);            <span class="built_in">add</span>(f + x, f + d + n + i, <span class="number">0</span>);        }    }    n = f + d + n * <span class="number">2</span> + <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= d; i++) {        <span class="built_in">add</span>(f + i, n, <span class="number">1</span>);    }    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) {        <span class="keyword">while</span> (flow = <span class="built_in">dinic</span>(<span class="number">0</span>, <span class="number">0x3f3f3f3f</span>)) ans += flow;    }    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题面-20&quot;&gt;题面&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;本文中所给出的题面为原题面的中文翻译，并非原始题面。翻译如有错误之处，请联系指出。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目描述-20&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;奶牛就是</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="洛谷" scheme="https://oi.baoshuo.ren/tags/%E6%B4%9B%E8%B0%B7/"/>
    
    <category term="图论" scheme="https://oi.baoshuo.ren/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="https://oi.baoshuo.ren/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="最大流" scheme="https://oi.baoshuo.ren/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>最大流学习笔记</title>
    <link href="https://oi.baoshuo.ren/notes/graph/max-flow/"/>
    <id>https://oi.baoshuo.ren/notes/graph/max-flow/</id>
    <published>2022-03-13T21:11:26.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>最大流问题是求解图上从源点流向汇点的最大流量的问题。</p><span id="more"></span><p>求解最大流问题主要有两种算法：Edmonds-Karp 动能算法（EK 算法）和 Dinic 算法，其中后者在算法竞赛中更为常用。</p><h2 id="基本概念-2">基本概念</h2><h3 id="流网络">流网络</h3><p>流网络 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V, E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>（Flow Network） 是一个有向图，图中每条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(u, v) \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 有一个非负的 <strong>容量值</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c (u, v) \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。而且，如果边集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 包含一条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>，则图中不存在反方向的边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v, u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span>。为了方便起见，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo mathvariant="normal">∉</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(u, v) \notin E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>，则定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c(u, v) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p>在流网络的所有节点中，有两个特殊的点：源点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 和汇点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo mathvariant="normal">≠</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s \ne t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>。</p><h3 id="流">流</h3><p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 定义在二元组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo>∈</mo><mi>V</mi><mo separator="true">,</mo><mi>v</mi><mo>∈</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u \in V, v \in V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span> 上的实数函数且满足</p><ol><li><strong>容量限制</strong>（Capacity Constraints）：对于每条边，流经该边的流量不得超过该边的容量，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>∈</mo><mi>V</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>c</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall u, v \in V, f(u, v) \leq c(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>；</li><li><strong>流量守恒</strong>（Flow Conservation）：从源点流出的流量等于汇点流入的流量，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mo stretchy="false">{</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><msub><mo>∑</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall x \in V - \{s, t\}, \sum_{(u, x) \in E} f(u, x) = \sum_{(x, v) \in E} f(x, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2247em;vertical-align:-0.4747em;"></span><span class="mopen">{</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2253em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4747em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2247em;vertical-align:-0.4747em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2253em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4747em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>；</li></ol><p>那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 称为网络 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 的流函数。</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(u, v) \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 称为边的 <strong>流量</strong>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(u, v) - f(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 称为边的 <strong>剩余容量</strong>（Residual Capacity），可以记作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c_f(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>。整个网络的流量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{(s, v) \in E} f(s, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2247em;vertical-align:-0.4747em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2253em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4747em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>，即从源点发出的所有流量之和。为了方便起见，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo mathvariant="normal">∉</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(u, v) \notin E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>，则定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(u, v) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p>一般而言也可以把网络流理解为整个图的流量。而这个流量必满足上述两个性质。</p><p>流函数的完整定义如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo mathvariant="normal">∉</mo><mi>E</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo mathvariant="normal">∉</mo><mi>E</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(u, v) = \left\{    \begin{aligned}        &amp; f(u, v),  &amp; (u, v) \in E \\        &amp; -f(v, u), &amp; (v, u) \in E \\        &amp; 0,        &amp; (u, v) \notin E, (v, u) \notin E \\    \end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.5em;vertical-align:-2em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"></path></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"></path></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-3em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-1.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord">0</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="残量网络">残量网络</h3><p>对于流函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>，残量网络 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">G_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>（Residual Network）是网络 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 中所有节点和剩余容量大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的边构成的子图，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>G</mi><mi>f</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mi>f</mi></msub><mo>=</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>E</mi><mi>f</mi></msub><mo>=</mo><mrow><mo fence="true">{</mo><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi><mo separator="true">,</mo><msub><mi>c</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn><mo fence="true">}</mo></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_f = (V_f = V, E_f = \left \{(u, v) \in E , c_f(u, v) &gt; 0 \right\})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mclose">)</span></span></span></span></span></p><p>注意，剩余容量大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的边可能不在原图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 中（根据容量、剩余容量的定义以及流函数的斜对称性得到）。可以理解为，残量网络中包括了那些还剩了流量空间的边构成的图，也包括虚边（即反向边）。</p><h3 id="增广路">增广路</h3><p>在原图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 中若存在一条从源点到汇点的路径上所有边的剩余容量都大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则这条路径被称为增广路（Augmenting Path）。</p><h2 id="edmonds-karp-算法">Edmonds-Karp 算法</h2><p>Edmonds-Karp 算法的基本思路很简单：不断地使用 BFS 去寻找增广路，直到网络上不存在增广路为止。</p><p>在每轮寻找增广路的过程中，Edmonds-Karp 算法只考虑所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c_f(u, v) \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的边，用 BFS 找到任意一条从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 的路径，同时计算出路径上各边的剩余容量的最小值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">\mathit{minf}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathit">minf</span></span></span></span></span>，则网络的流量就可以增加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">\mathit{minf}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathit">minf</span></span></span></span></span>。</p><p>需要注意的是，当一条边的流量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(u, v) &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时，根据斜对称性质，它的反向边流量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(v, u) &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，此时必定有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>c</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(v, u) &lt; c(v, u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span>。故 Edmonds-Karp 算法在 BFS 时除了原图的边集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 外，还应该考虑遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 中每条边的反向边。</p><p>在实现时，只需要维护残量网络即可。当一条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 流过大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> 的流时，令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> 的剩余容量减小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v, u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span> 的剩余流量增大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> 即可。</p><p>Edmonds-Karp 算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><msup><mi>E</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(VE^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。然而在实际运用中远远达不到这个上界，效率较高，可以处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mo>∼</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^3 \sim 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 规模的网络。</p><blockquote><p>来自 GitHub Copilot 的补全（未验证）：然而在实际应用中，这个算法的时间复杂度可以降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(VE)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，因为在每轮 BFS 时，只需要更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 中的边的剩余容量，而不需要更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 中的节点。</p></blockquote><h3 id="代码-57">代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="type">const</span> <span class="type">char</span> endl = <span class="string">'\n'</span>;<span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>,          M = <span class="number">10005</span>;<span class="type">int</span> n, m, s, t, ans;<span class="comment">// Graph</span><span class="type">int</span> idx, head[N], ver[M &lt;&lt; <span class="number">1</span>], edge[M &lt;&lt; <span class="number">1</span>], next[M &lt;&lt; <span class="number">1</span>];<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>{    next[idx] = head[u];    ver[idx] = v;    edge[idx] = w;    head[u] = idx++;}<span class="comment">// Edmonds-Karp</span><span class="type">int</span> d[N], pre[N];<span class="type">bool</span> vis[N];<span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>{    <span class="built_in">memset</span>(vis, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(vis));    std::queue&lt;<span class="type">int</span>&gt; q;    q.<span class="built_in">push</span>(s);    vis[s] = <span class="literal">true</span>;    d[s] = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {        <span class="type">int</span> x = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; ~i; i = next[i]) {            <span class="keyword">if</span> (edge[i]) {                <span class="type">int</span> y = ver[i];                <span class="keyword">if</span> (vis[y]) <span class="keyword">continue</span>;                d[y] = std::<span class="built_in">min</span>(d[x], edge[i]);                pre[y] = i;  <span class="comment">// 记录前驱</span>                q.<span class="built_in">push</span>(y);                vis[y] = <span class="literal">true</span>;                <span class="keyword">if</span> (y == t) <span class="keyword">return</span> <span class="literal">true</span>;            }        }    }    <span class="keyword">return</span> <span class="literal">false</span>;}<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>{  <span class="comment">// 更新增广路及其反向边的剩余容量</span>    <span class="type">int</span> x = t;    <span class="keyword">while</span> (x != s) {        <span class="type">int</span> i = pre[x];        edge[i] -= d[t];        edge[i ^ <span class="number">1</span>] += d[t];        x = ver[i ^ <span class="number">1</span>];    }    ans += d[t];}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(head));    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {        <span class="type">int</span> u, v, w;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        <span class="built_in">add</span>(u, v, w);        <span class="built_in">add</span>(v, u, <span class="number">0</span>);    }    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="built_in">update</span>();    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre><h2 id="dinic-算法">Dinic 算法</h2><p>Edmonds-Karp 算法每轮可能会遍历整个残量网络，但只找出一条增广路，还有进一步优化的空间。</p><p>Dinic 算法不断重复以下步骤，直到在残量网络中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 不能到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>：</p><ol><li>在残量网络上 BFS 求出节点的层次，构造分层图。</li><li>在分层图上 DFS 求出增广路，在回溯时实时更新剩余容量。另外，每个点可以流向多条出边，同时还加入了若干剪枝（参考程序注释）。</li></ol><p>Dinic 算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>。但在实际中远远达不到这个上界，一般能够处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>∼</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^4 \sim 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 规模的网络，特别地，在求解稠密图上的最大流问题是效率要比前文提到的 Edmonds-Karp 算法更高。</p><hr><p>Dinic 算法中的两个优化：</p><ol><li><strong>多路增广</strong>：每找到一条增广路时，若还有残余流量存在，那么可以再找出其他的增广路来利用这些残余流量。这样就可以在一次 DFS 中找出多条增广路，大大提高了算法的效率。</li><li><strong>当前弧优化</strong>：如果一条边已经被增广过，那么该边就没有可能被增广第二次。那么，当下一次进行增广的时候，就可以不必再走那些已经被增广过的边。</li></ol><h3 id="代码-58">代码</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="type">const</span> <span class="type">char</span> endl = <span class="string">'\n'</span>;<span class="type">const</span> <span class="type">int</span> N = <span class="number">205</span>,          M = <span class="number">5005</span>;<span class="type">int</span> n, m, s, t, flow;<span class="type">long</span> <span class="type">long</span> ans;<span class="comment">// Graph</span><span class="type">int</span> idx, head[N], edge[M &lt;&lt; <span class="number">1</span>], ver[M &lt;&lt; <span class="number">1</span>], next[M &lt;&lt; <span class="number">1</span>];<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>{    next[idx] = head[u];    edge[idx] = w;    ver[idx] = v;    head[u] = idx++;}<span class="comment">// Dinic</span><span class="type">int</span> d[N], cur[N];<span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>{    <span class="built_in">memset</span>(d, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(d));    std::queue&lt;<span class="type">int</span>&gt; q;    d[s] = <span class="number">1</span>;    q.<span class="built_in">push</span>(s);    cur[s] = head[s];    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {        <span class="type">int</span> u = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = next[i]) {            <span class="type">int</span> v = ver[i],                w = edge[i];            <span class="keyword">if</span> (w &amp;&amp; !d[v]) {                d[v] = d[u] + <span class="number">1</span>;                cur[v] = head[v];                <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;                q.<span class="built_in">push</span>(v);            }        }    }    <span class="keyword">return</span> <span class="literal">false</span>;}<span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>{    <span class="keyword">if</span> (u == t) <span class="keyword">return</span> limit;    <span class="type">int</span> flow = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = next[i]) {        cur[u] = i;            <span class="comment">// 当前弧优化</span>        <span class="type">int</span> v = ver[i],            w = edge[i];        <span class="keyword">if</span> (w &amp;&amp; d[v] == d[u] + <span class="number">1</span>) {            <span class="type">int</span> k = <span class="built_in">dinic</span>(v, std::<span class="built_in">min</span>(edge[i], limit - flow));            <span class="keyword">if</span> (!k) d[v] = <span class="number">0</span>;  <span class="comment">// 剪枝：去掉增广完毕的点</span>            edge[i] -= k;            edge[i ^ <span class="number">1</span>] += k;            flow += k;        }    }    <span class="keyword">return</span> flow;}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(head));    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {        <span class="type">int</span> u, v, w;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        <span class="built_in">add</span>(u, v, w);        <span class="built_in">add</span>(v, u, <span class="number">0</span>);    }    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) {        <span class="keyword">while</span> (flow = <span class="built_in">dinic</span>(s, <span class="number">0x3f3f3f3f</span>)) ans += flow;    }    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre><h2 id="参考资料-8">参考资料</h2><ol><li>0x6A 网络流初步，《算法竞赛进阶指南》（ISBN 978-7-893-88198-5，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。</li><li>第 26 章 最大流，《算法导论》中译本（ISBN 978-7-111-40701-0，机械工业出版社），2013 年 1 月第三版。</li><li>1.1.1 网络流的基本概念，AcWing 算法进阶课，闫学灿，2020 年 7 月 25 日。</li><li>1.1.2 最大流，AcWing 算法进阶课，闫学灿，2020 年 7 月 31 日 ~ 2020 年 8 月 8 日。</li><li><a href="https://oi-wiki.org/graph/flow/">网络流简介</a>，图论，OI Wiki，2021 年 7 月 11 日。</li></ol></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;最大流问题是求解图上从源点流向汇点的最大流量的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://oi.baoshuo.ren/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="图论" scheme="https://oi.baoshuo.ren/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="https://oi.baoshuo.ren/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="最大流" scheme="https://oi.baoshuo.ren/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>学考自救指北 —— SQL 篇</title>
    <link href="https://oi.baoshuo.ren/xuekao-sql/"/>
    <id>https://oi.baoshuo.ren/xuekao-sql/</id>
    <published>2022-03-11T20:35:28.000Z</published>
    <updated>2022-03-11T12:37:56.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>SQL（Structured Query Language，结构化查询语言）是一种具有数据操纵和数据定义等多种功能的数据库语言。</p><h2 id="基本概念">基本概念</h2><p>这些可以不用会，但最好了解一下。</p><ul><li><strong>数据库</strong>（database）：保存有组织的数据的容器（通常是一个文件或一组文件）。</li><li><strong>数据表</strong>（table）：某种特定类型数据的结构化清单。</li><li><strong>模式</strong>（schema）：关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li><li><strong>列</strong>（column）：表中的一个字段。所有表都是由一个或多个列组成的。</li><li><strong>行</strong>（row）：表中的一个记录。</li><li><strong>主键</strong>（primary key）：一列（或一组列），其值能够唯一标识表中每一行。</li></ul><h2 id="sql-语法">SQL 语法</h2><ol><li>SQL 语句不区分大小写（数据库表名、列名和值是否区分大小写，依赖于具体的 DBMS 以及配置）。<br>例如：<code>SELECT</code> 与 <code>select</code>、<code>Select</code> 是相同的。</li><li>多条 SQL 语句必须以半角分号（<code>;</code>）分隔，部分数据库系统要求在每条 SQL 语句后都添加分号。</li><li>处理 SQL 语句时，所有空格都被忽略。SQL 语句可以写成一行，也可以分写为多行。</li></ol><p>SQL 中的注释有两种形式：</p><ul><li>单行注释：<code>--</code> 后面跟着任意字符串，包括空格。</li><li>多行注释：以 <code>/*</code> 开始，<code>*/</code> 结束。</li></ul><p>部分引擎还支持以 <code>#</code> 号开头的注释，在此不做过多叙述。</p><h2 id="基本操作">基本操作</h2><h3 id="创建表">创建表</h3><p>下方的 SQL 语句创建了一个名为 <code>students</code> 的数据表，表中包含了学生的编号、姓名、出生日期、班级，其中编号每次插入新行都会自动加一、班级（class）默认为「高一年级 A16 班」，并将学生编号设置为了数据表的主键（<code>PRIMARY KEY (`id`)</code> 子句），还设置了这些字段不能为空值（<code>NOT NULL</code>）。</p><pre><code class="highlight sql"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `students` (  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,  `name` <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `birthdate` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  `class` <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'高一年级A16班'</span>,  <span class="keyword">PRIMARY</span> KEY (`id`))</code></pre><details open=""><summary>常用数据类型</summary><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>INTEGER</code> (简写 <code>int</code>)</td><td>整数型</td></tr><tr><td><code>NUMERIC(全长, 小数位数)</code></td><td>数值型</td></tr><tr><td><code>CHAR</code></td><td>定长字符串</td></tr><tr><td><code>VARCHAR</code></td><td>可变长字符串</td></tr><tr><td><code>DATE</code></td><td>日期型</td></tr></tbody></table><p>示例：<code>NUMERIC(7, 2)</code> 表示数值型，有 5 位整数，2 位小数，全长 7 位。</p></details><details open=""><summary>关于主键</summary><p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</p></details><h3 id="删除表">删除表</h3><p>下方的 SQL 语句删除了一个名为 <code>students</code> 的数据表。</p><pre><code class="highlight sql"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `students`;</code></pre><h3 id="更新表定义">更新表定义</h3><p>更新表定义可以使用 <code>ALTER</code> 子句。</p><h4 id="增加列">增加列</h4><p>下方的语句可以为 <code>students</code> 数据表在 <code>class</code> 列后再增加一个新的列，新列的名称为 <code>address</code>，数据类型为 <code>varchar(100)</code>。</p><pre><code class="highlight sql"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `students` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `address` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AFTER `class`;</code></pre><p>如果不写 <code>AFTER</code> 子句，则新列会被添加到数据表的最后面。也可以使用 <code>FIRST</code> 替代这个子句，这样新列会被添加到数据表的开头。</p><h4 id="删除列">删除列</h4><p>下方的语句可以删除 <code>students</code> 表中名为 <code>address</code> 的列。</p><pre><code class="highlight sql"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `students` <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> `address`;</code></pre><h4 id="更改表名">更改表名</h4><p>下方的语句可以将名为 <code>students</code> 的表更名为 <code>student</code>。</p><pre><code class="highlight sql"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `students` RENAME <span class="keyword">TO</span> `student`;</code></pre><h3 id="数据检索">数据检索</h3><p>基本格式：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> `name` <span class="keyword">FROM</span> `students`;</code></pre><p>这个语句的意思是从名为 <code>students</code> 的表中查询 <code>name</code> 列（字段）的值，即获取所有学生的名字。</p><p>字段名可以使用通配符代替，这样可以获取所有字段的值，例如：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `students`;</code></pre><h3 id="数据删除">数据删除</h3><p>可以使用 <code>DELETE</code> 语句来删除数据。</p><pre><code class="highlight sql"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `students` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">1</span>;</code></pre><p>这个语句可以删除编号为 <code>1</code> 的学生。</p><h3 id="数据更新">数据更新</h3><p>可以使用 <code>UPDATE</code> 语句来更新数据。</p><pre><code class="highlight sql"><span class="keyword">UPDATE</span> `students` <span class="keyword">SET</span> `name` <span class="operator">=</span> <span class="string">'李四'</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">1</span>;</code></pre><p>这个语句可以将编号为 <code>1</code> 的学生的姓名改为 <code>李四</code>。</p><p>当然，将名字为「张三」的学生改名为「李四」也不是不可以：</p><pre><code class="highlight sql"><span class="keyword">UPDATE</span> `students` <span class="keyword">SET</span> `name` <span class="operator">=</span> <span class="string">'李四'</span> <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'张三'</span>;</code></pre><h2 id="数据过滤">数据过滤</h2><p>SQL 中的数据过滤可以使用 <code>WHERE</code> 子句和一些辅助函数来完成。</p><h3 id="单条件筛选">单条件筛选</h3><p>下方的语句可以从 <code>students</code> 表中选择出所有名为「张三」的学生（即 <code>name</code> 的值为 <code>张三</code> 的所有行）并输出该行的所有信息。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `students` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'张三'</span>;</code></pre><h3 id="多条件筛选">多条件筛选</h3><p>下方的语句可以从 <code>students</code> 表中选择出「高一年级 A16 班」中所有名为「张三」的学生（即 <code>name</code> 字段的值为 <code>张三</code> 且 <code>class</code> 字段的值为 <code>高一年级A16班</code>），并输出这些学生的生日。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> birthdate <span class="keyword">FROM</span> `students` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'张三'</span> <span class="keyword">AND</span> `class` <span class="operator">=</span> <span class="string">'高一年级A16班'</span>;</code></pre><p>如果只需要满足这两个条件之中的某一个可以使用 <code>OR</code> 代替 <code>AND</code>。</p><p>下方的语句可以从 <code>exams</code> 表中选择出「2021 - 2022 学年第一学期期中考试」中总成绩大于 300 分的所有学生。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `exams` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'2021-2022学年第一学期期中考试'</span> <span class="keyword">AND</span> `score` <span class="operator">&gt;</span> <span class="number">300</span>;</code></pre><h3 id="in-操作符">IN 操作符</h3><p>下方的语句可以从 <code>students</code> 表中选择出所有在「高一年级 A15 班」和「高一年级 A16 班」的学生。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `students` <span class="keyword">WHERE</span> `class` <span class="keyword">IN</span> (<span class="string">'高一年级A15班'</span>, <span class="string">'高一年级A16班'</span>);</code></pre><p>也可以这样写，不过不太简洁：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `students` <span class="keyword">WHERE</span> `class` <span class="operator">=</span> <span class="string">'高一年级A15班'</span> <span class="keyword">OR</span> `class` <span class="operator">=</span> <span class="string">'高一年级A16班'</span>;</code></pre><h3 id="not-操作符">NOT 操作符</h3><p>下方的语句可以从 <code>students</code> 表中选择出所有 <strong>不在</strong>「高一年级 A15 班」和「高一年级 A16 班」的学生。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `students` <span class="keyword">WHERE</span> `class` <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">'高一年级A15班'</span>, <span class="string">'高一年级A16班'</span>);</code></pre><h3 id="通配符匹配">通配符匹配</h3><p>使用 LIKE 子句可以实现通配符匹配，例如：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `students` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">'张%'</span>;</code></pre><p>这个语句可以选择出所有名字以 <code>张</code> 开头的学生。</p><p>而使用 <code>_</code> 可以匹配任意一个字符，例如：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `students` <span class="keyword">WHERE</span> `name` <span class="keyword">LIKE</span> <span class="string">'马_国'</span>;</code></pre><p>这个语句可以选择出所有名字有三个字的，且名字以 <code>马</code> 开头、以 <code>国</code> 结尾的学生。</p><h2 id="数据处理">数据处理</h2><h3 id="排序">排序</h3><p>排序可以使用 <code>ORDER BY</code> 子句来完成，例如：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `exams` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'2021-2022学年第一学期期中考试'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `score`;</code></pre><p>这个语句可以选择出所有名为 <code>2021-2022学年第一学期期中考试</code> 的考试，并按照 <code>score</code> 字段进行排序。</p><p>如果需要降序排序，那么为 <code>ORDER BY</code> 子句添加 <code>DESC</code> 即可：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `exams` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'2021-2022学年第一学期期中考试'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `score` <span class="keyword">DESC</span>;</code></pre><h3 id="limit-子句">LIMIT 子句</h3><p>可以使用这个子句来限制输出数量，比如下面这个语句就可以输出考试中成绩前十名的学生：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `exams` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'2021-2022学年第一学期期中考试'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `score` <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</code></pre><h3 id="内建函数">内建函数</h3><p>SQL 中常用的内建函数有 5 个，分别是 <code>count</code> <code>sum</code> <code>avg</code> <code>max</code> <code>min</code>。</p><h4 id="count-函数">COUNT 函数</h4><p>下面的语句返回指定列的值的数目（未去重）：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(`name`) <span class="keyword">FROM</span> `exams`;</code></pre><p>如果需要对数据进行去重，可以使用 <code>DISTINCT</code> 子句：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> `name`) <span class="keyword">FROM</span> `exams`;</code></pre><p>也可以统计表中数据的行数，使用 <code>COUNT(*)</code> 子句：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> `exams`;</code></pre><h4 id="sum-函数">SUM 函数</h4><p>下面的语句可以返回指定列中的所有值的总和：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(`score`) <span class="keyword">FROM</span> `exams` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'2021-2022学年第一学期期中考试'</span>;</code></pre><p>这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试中所有同学们获得的总分之和。</p><h4 id="avg-函数">AVG 函数</h4><p>下面的语句可以返回指定列中的所有值的平均值：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(`score`) <span class="keyword">FROM</span> `exams` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'2021-2022学年第一学期期中考试'</span>;</code></pre><p>这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试的平均分。</p><h4 id="min-函数">MIN 函数</h4><p>下面的语句可以返回指定列中的所有值的最小值：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(`score`) <span class="keyword">FROM</span> `exams` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'2021-2022学年第一学期期中考试'</span>;</code></pre><p>这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试中的最低分。</p><h4 id="max-函数">MAX 函数</h4><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(`score`) <span class="keyword">FROM</span> `exams` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">'2021-2022学年第一学期期中考试'</span>;</code></pre><p>这个语句可以返回名为「2021-2022 学年第一学期期中考试」的考试中的最高分。</p><h2 id="参考资料">参考资料</h2><ol><li><a href="https://www.runoob.com/sql/sql-tutorial.html">SQL 教程</a>，菜鸟教程。</li><li><a href="https://docs.microsoft.com/zh-cn/sql/t-sql/language-reference?view=sql-server-ver15">Transact-SQL 参考</a>，Microsoft SQL Server 中文文档。</li><li><a href="https://docs.oracle.com/cd/E17952_01/mysql-8.0-en/index.html">MySQL 8.0 Reference Manual</a>，Oracle Docs。</li></ol><p>本文是在 GitHub Copilot 的辅助之下编写的，版权共有。如有错误请及时指正。</p></body></html>]]></content>
    
    
    <summary type="html">本文讲述了一些 SQL 的基础知识，希望能帮助大家在学考中获得更好的成绩。
</summary>
    
    
    
    <category term="笔记" scheme="https://oi.baoshuo.ren/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学考" scheme="https://oi.baoshuo.ren/tags/%E5%AD%A6%E8%80%83/"/>
    
    <category term="SQL" scheme="https://oi.baoshuo.ren/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 - P1486 [NOI2004] 郁闷的出纳员</title>
    <link href="https://oi.baoshuo.ren/solutions/luogu-p1486/"/>
    <id>https://oi.baoshuo.ren/solutions/luogu-p1486/</id>
    <published>2022-03-07T20:16:40.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题面-12">题面</h2><h3 id="题目描述-12">题目描述</h3><p>OIER 公司是一家大型专业化软件公司，有着数以万计的员工。作为一名出纳员，我的任务之一便是统计每位员工的工资。这本来是一份不错的工作，但是令人郁闷的是，我们的老板反复无常，经常调整员工的工资。如果他心情好，就可能把每位员工的工资加上一个相同的量。反之，如果心情不好，就可能把当前在公司的所有员工的工资扣除一个相同的量。我真不知道除了调工资他还做什么其它事情。</p><p>工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。</p><p>老板经常到我这边来询问工资情况，他并不问具体某位员工的工资情况，而是问现在工资第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 多的员工拿多少工资。每当这时，我就不得不对数万个员工进行一次漫长的排序，然后告诉他答案。</p><p>好了，现在你已经对我的工作了解不少了。正如你猜的那样，我想请你编一个工资统计程序。怎么样，不是很困难吧？</p><p>如果某个员工的初始工资低于最低工资标准，那么将不计入最后的答案内。</p><h3 id="输入格式-12">输入格式</h3><p>第一行有两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mop">min</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 表示下面有多少条命令，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mop">min</span></span></span></span> 表示工资下界。</p><p>接下来的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行一个字符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 和一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，表示一条命令。命令可以是以下四种之一：</p><ul><li><code>I k</code> 新建一个工资档案，初始工资为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。如果某员工的初始工资低于工资下界，他将立刻离开公司。</li><li><code>A k</code> 把每位员工的工资加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</li><li><code>S k</code> 把每位员工的工资扣除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</li><li><code>F k</code> 查询第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 多的工资。</li></ul><p>在初始时，可以认为公司里一个员工也没有。</p><h3 id="输出格式-12">输出格式</h3><p>对于每条 <code>F</code> 命令，你的程序要输出一行，仅包含一个整数，为当前工资第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 多的员工所拿的工资数，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 大于目前员工的数目，则输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><p>输出的最后一行包含一个整数，为离开公司的员工的总数。</p><p>请注意，初始工资低于工资下界的员工不算做离开公司的员工。</p><h3 id="数据规模与约定">数据规模与约定</h3><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，保证：</p><ul><li><code>I</code> 命令的条数不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；</li><li><code>A</code> 和 <code>S</code> 命令的总条数不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span>；</li><li><code>F</code> 命令的条数不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；</li><li>每次工资调整的调整量不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>；</li><li>新员工的工资不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq n \leq 3 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mtext>min</mtext><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq \text{min} \leq 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8038em;vertical-align:-0.136em;"></span><span class="mord text"><span class="mord">min</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，输入的所有数字均在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> 位带符号整形范围内。</li></ul><h2 id="思路-13">思路</h2><p>可以使用一个全局变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span> 来记录工资的变化。</p><p>每次添加员工的时候，若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>&lt;</mo><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mrow><annotation encoding="application/x-tex">k &lt; \mathit{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6554em;"></span><span class="mord"><span class="mord mathit">min</span></span></span></span></span> 则不添加，否则添加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">k - \Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span> 即可。</p><p>每次调整的时候只需要在调整后删除掉工资小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><mo>−</mo><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\mathit{min} - \Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7387em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathit">min</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span> 的员工即可。</p><div data-group=""><div data-title="STL"><p>可以使用 <code>std::vector</code> 来存储员工工资数据。</p><p>在插入的时候使用 <code>std::lower_bound</code> 来查找插入位置，确保容器内部元素有序。</p><p>在降工资时删除所有小于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><mo>−</mo><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\mathit{min} - \Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7387em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathit">min</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span> 的员工的数据，并记录删除人数。</p></div><div data-title="FHQ Treap"><p>FHQ Treap 板子活用一下就行了。</p><p>在降工资时将整颗 Treap 分裂为两个子树，左子树是工资小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><mo>−</mo><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\mathit{min} - \Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7387em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathit">min</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span> 的员工，记录元素数量并删除该子树即可。</p><p>此处求第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 大可以直接转化成求第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - k + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 小的元素。</p></div></div><!-- TODO --><h2 id="代码-13">代码</h2><div data-group=""><div data-title="STL"><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="type">const</span> <span class="type">char</span> endl = <span class="string">'\n'</span>;<span class="type">int</span> n, min, k, c, cnt;<span class="type">char</span> op;std::vector&lt;<span class="type">int</span>&gt; a;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    cin &gt;&gt; n &gt;&gt; min;    <span class="keyword">while</span> (n--) {        cin &gt;&gt; op &gt;&gt; k;        <span class="keyword">if</span> (op == <span class="string">'I'</span>) {            <span class="keyword">if</span> (k &gt;= min) {                a.<span class="built_in">insert</span>(std::<span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), k - c), k - c);            }        } <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'A'</span>) {            c += k;        } <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'S'</span>) {            c -= k;            <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), min - c);            cnt += it - a.<span class="built_in">begin</span>();            a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>(), std::<span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), min - c));        } <span class="keyword">else</span> {  <span class="comment">// op == 'F'</span>            cout &lt;&lt; (a.<span class="built_in">size</span>() &lt; k ? <span class="number">-1</span> : *(a.<span class="built_in">end</span>() - k) + c) &lt;&lt; endl;        }    }    cout &lt;&lt; cnt &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></div><div data-title="FHQ Treap"><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="type">const</span> <span class="type">char</span> endl = <span class="string">'\n'</span>;<span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;<span class="type">int</span> n, min, k, c, ans;<span class="type">char</span> op;<span class="comment">// Treap</span><span class="type">int</span> root, cnt;<span class="keyword">struct</span> <span class="title class_">node</span> {    <span class="type">int</span> l, r, s, v, k;    <span class="built_in">node</span>()        : <span class="built_in">l</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>), <span class="built_in">s</span>(<span class="number">0</span>), <span class="built_in">v</span>(<span class="number">0</span>), <span class="built_in">k</span>(<span class="built_in">rand</span>()) {}    <span class="built_in">node</span>(<span class="type">int</span> _v)        : <span class="built_in">l</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>), <span class="built_in">s</span>(<span class="number">1</span>), <span class="built_in">v</span>(_v), <span class="built_in">k</span>(<span class="built_in">rand</span>()) {}} tr[N];<span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>{    tr[u].s = tr[tr[u].l].s + <span class="number">1</span> + tr[tr[u].r].s;}<span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span> </span>{    <span class="keyword">if</span> (!p) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);    <span class="keyword">if</span> (k &lt;= tr[tr[p].l].s) {        <span class="keyword">auto</span> o = <span class="built_in">split</span>(tr[p].l, k);        tr[p].l = o.second;        <span class="built_in">pushup</span>(p);        o.second = p;        <span class="keyword">return</span> o;    }    <span class="keyword">auto</span> o = <span class="built_in">split</span>(tr[p].r, k - tr[tr[p].l].s - <span class="number">1</span>);    tr[p].r = o.first;    <span class="built_in">pushup</span>(p);    o.first = p;    <span class="keyword">return</span> o;}<span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">splitByValue</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>{    <span class="keyword">if</span> (!p) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);    <span class="keyword">if</span> (v &lt;= tr[p].v) {        <span class="keyword">auto</span> o = <span class="built_in">splitByValue</span>(tr[p].l, v);        tr[p].l = o.second;        <span class="built_in">pushup</span>(p);        o.second = p;        <span class="keyword">return</span> o;    }    <span class="keyword">auto</span> o = <span class="built_in">splitByValue</span>(tr[p].r, v);    tr[p].r = o.first;    <span class="built_in">pushup</span>(p);    o.first = p;    <span class="keyword">return</span> o;}<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>{    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;    <span class="keyword">if</span> (tr[x].k &gt; tr[y].k) {        tr[x].r = <span class="built_in">merge</span>(tr[x].r, y);        <span class="built_in">pushup</span>(x);        <span class="keyword">return</span> x;    }    tr[y].l = <span class="built_in">merge</span>(x, tr[y].l);    <span class="built_in">pushup</span>(y);    <span class="keyword">return</span> y;}<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v)</span> </span>{    <span class="keyword">auto</span> o = <span class="built_in">splitByValue</span>(root, v);    <span class="type">int</span> p = ++cnt;    tr[p] = <span class="built_in">node</span>(v);    root = <span class="built_in">merge</span>(o.first, <span class="built_in">merge</span>(p, o.second));}<span class="function"><span class="type">int</span> <span class="title">getKth</span><span class="params">(<span class="type">int</span> k)</span> </span>{    <span class="keyword">auto</span> x = <span class="built_in">split</span>(root, k - <span class="number">1</span>);    <span class="keyword">auto</span> y = <span class="built_in">split</span>(x.second, <span class="number">1</span>);    <span class="type">int</span> r = y.first;    root = <span class="built_in">merge</span>(x.first, <span class="built_in">merge</span>(y.first, y.second));    <span class="keyword">return</span> tr[r].v;}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    cin &gt;&gt; n &gt;&gt; min;    <span class="keyword">while</span> (n--) {        cin &gt;&gt; op &gt;&gt; k;        <span class="keyword">if</span> (op == <span class="string">'I'</span>) {            <span class="keyword">if</span> (k &gt;= min) {                <span class="built_in">insert</span>(k - c);            }        } <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'A'</span>) {            c += k;        } <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'S'</span>) {            c -= k;            <span class="keyword">auto</span> o = <span class="built_in">splitByValue</span>(root, min - c);            root = o.second;            ans += tr[o.first].s;        } <span class="keyword">else</span> {  <span class="comment">// op == 'F'</span>            cout &lt;&lt; (tr[root].s &lt; k ? <span class="number">-1</span> : <span class="built_in">getKth</span>(tr[root].s - k + <span class="number">1</span>) + c) &lt;&lt; endl;        }    }    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></div></div></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题面-12&quot;&gt;题面&lt;/h2&gt;
&lt;h3 id=&quot;题目描述-12&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;OIER 公司是一家大型专业化软件公司，有着数以万计的员工。作为一名出纳员，我的任务之一便是统计每位员工的工资。这本来是一份</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数据结构" scheme="https://oi.baoshuo.ren/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="洛谷" scheme="https://oi.baoshuo.ren/tags/%E6%B4%9B%E8%B0%B7/"/>
    
    <category term="Treap" scheme="https://oi.baoshuo.ren/tags/Treap/"/>
    
    <category term="STL" scheme="https://oi.baoshuo.ren/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 - P3391 【模板】文艺平衡树</title>
    <link href="https://oi.baoshuo.ren/solutions/luogu-p3391/"/>
    <id>https://oi.baoshuo.ren/solutions/luogu-p3391/</id>
    <published>2022-03-02T20:55:32.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本题有多个提交渠道：</p><ul><li><a href="https://loj.ac/p/105">LibreOJ 105</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/36b130864d52c4e9defd12c913dac0939e957efe"><code>36b1308</code></a>)</small></li><li><a href="https://www.luogu.com.cn/problem/P3391">洛谷 P3391</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/7f27706ba1c6e5e02e4b7c7493a5794928a1ce1b"><code>7f27706</code></a>)</small></li><li><a href="https://www.acwing.com/problem/content/description/2439/">AcWing 2437</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/4fcf1d3c1f060f89f22d5ae53d90fb8ae24e0d70"><code>4fcf1d3</code></a>)</small></li><li><a href="https://sjzezoj.com/problem/100">S2OJ 100</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/f11abf84e2a355ad51283c866d817d45b570ffc0"><code>f11abf8</code></a>)</small></li></ul><hr><h2 id="题面-21">题面</h2><h3 id="题目描述-21">题目描述</h3><p>您需要写一种数据结构（可参考题目标题），来维护一个有序数列。</p><p>其中需要提供以下操作：翻转一个区间，例如原有序序列是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mtext>&nbsp;</mtext><mn>4</mn><mtext>&nbsp;</mtext><mn>3</mn><mtext>&nbsp;</mtext><mn>2</mn><mtext>&nbsp;</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">5\ 4\ 3\ 2\ 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span><span class="mspace">&nbsp;</span><span class="mord">4</span><span class="mspace">&nbsp;</span><span class="mord">3</span><span class="mspace">&nbsp;</span><span class="mord">2</span><span class="mspace">&nbsp;</span><span class="mord">1</span></span></span></span>，翻转区间是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 的话，结果是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mtext>&nbsp;</mtext><mn>2</mn><mtext>&nbsp;</mtext><mn>3</mn><mtext>&nbsp;</mtext><mn>4</mn><mtext>&nbsp;</mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">5\ 2\ 3\ 4\ 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span><span class="mspace">&nbsp;</span><span class="mord">2</span><span class="mspace">&nbsp;</span><span class="mord">3</span><span class="mspace">&nbsp;</span><span class="mord">4</span><span class="mspace">&nbsp;</span><span class="mord">1</span></span></span></span>。</p><h3 id="输入格式-21">输入格式</h3><p>第一行两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n, m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span></span></span></span>，表示序列长度与操作个数。序列中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 项初始为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>。<br>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l, r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，表示翻转的区间。</p><h3 id="输出格式-21">输出格式</h3><p>输出一行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个正整数，表示原始序列经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 次变换后的结果。</p><h3 id="输入输出样例-16">输入输出样例</h3><p><strong>样例输入 #1</strong></p><pre><code class="highlight text">5 31 31 31 4</code></pre><p><strong>样例输出 #1</strong></p><pre><code class="highlight text">4 3 2 1 5</code></pre><h3 id="数据范围与约定-9">数据范围与约定</h3><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le n, m \leq 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le l \le r \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><h2 id="思路-23">思路</h2><p>前置知识：<a href="#">Post not found: fhq-treap</a>。</p><p>当翻转 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间时，先分裂出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[r + 1, \mathit{size}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathit">size</span></span><span class="mclose">]</span></span></span></span> 两个区间，再从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 中分裂出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, l - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 两个区间。将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间打标记后再合并即可。</p><p>最后按照中序遍历输出即为答案。</p><h2 id="代码-23">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="meta">#<span class="keyword">define</span> endl <span class="string">'\n'</span></span><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;<span class="type">int</span> n, m, l, r, root, cnt;<span class="keyword">struct</span> <span class="title class_">node</span> {    <span class="type">int</span> l, r, s, v, k;    <span class="type">bool</span> d;    <span class="built_in">node</span>()        : <span class="built_in">l</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>), <span class="built_in">s</span>(<span class="number">0</span>), <span class="built_in">v</span>(<span class="number">0</span>), <span class="built_in">d</span>(<span class="literal">false</span>), <span class="built_in">k</span>(<span class="built_in">rand</span>()) {}    <span class="built_in">node</span>(<span class="type">int</span> _v)        : <span class="built_in">l</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>), <span class="built_in">s</span>(<span class="number">1</span>), <span class="built_in">v</span>(_v), <span class="built_in">d</span>(<span class="literal">false</span>), <span class="built_in">k</span>(<span class="built_in">rand</span>()) {}} tr[N];<span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>{    tr[u].s = tr[tr[u].l].s + tr[tr[u].r].s + <span class="number">1</span>;}<span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span> </span>{    <span class="keyword">if</span> (tr[u].d) {        tr[u].d = <span class="literal">false</span>;        tr[tr[u].l].d ^= <span class="number">1</span>;        tr[tr[u].r].d ^= <span class="number">1</span>;        std::<span class="built_in">swap</span>(tr[u].l, tr[u].r);    }}<span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    <span class="type">int</span> p = ++cnt;    tr[p] = <span class="built_in">node</span>(mid - <span class="number">1</span>);    tr[p].l = <span class="built_in">build</span>(l, mid - <span class="number">1</span>);    tr[p].r = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);    <span class="built_in">pushup</span>(p);    <span class="keyword">return</span> p;}<span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span> </span>{    <span class="keyword">if</span> (!p) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);    <span class="built_in">pushdown</span>(p);    <span class="keyword">if</span> (k &lt;= tr[tr[p].l].s) {        <span class="keyword">auto</span> o = <span class="built_in">split</span>(tr[p].l, k);        tr[p].l = o.second;        <span class="built_in">pushup</span>(p);        o.second = p;        <span class="keyword">return</span> o;    }    <span class="keyword">auto</span> o = <span class="built_in">split</span>(tr[p].r, k - tr[tr[p].l].s - <span class="number">1</span>);    tr[p].r = o.first;    <span class="built_in">pushup</span>(p);    o.first = p;    <span class="keyword">return</span> o;}<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>{    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x | y;    <span class="built_in">pushdown</span>(x);    <span class="built_in">pushdown</span>(y);    <span class="keyword">if</span> (tr[x].k &gt; tr[y].k) {        tr[x].r = <span class="built_in">merge</span>(tr[x].r, y);        <span class="built_in">pushup</span>(x);        <span class="keyword">return</span> x;    }    tr[y].l = <span class="built_in">merge</span>(x, tr[y].l);    <span class="built_in">pushup</span>(y);    <span class="keyword">return</span> y;}<span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{    <span class="keyword">auto</span> x = <span class="built_in">split</span>(root, r + <span class="number">1</span>);    <span class="keyword">auto</span> y = <span class="built_in">split</span>(x.first, l);    tr[y.second].d ^= <span class="number">1</span>;    root = <span class="built_in">merge</span>(<span class="built_in">merge</span>(y.first, y.second), x.second);}<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> p)</span> </span>{    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;    <span class="built_in">pushdown</span>(p);    <span class="built_in">print</span>(tr[p].l);    <span class="keyword">if</span> (<span class="number">1</span> &lt;= tr[p].v &amp;&amp; tr[p].v &lt;= n) {        cout &lt;&lt; tr[p].v &lt;&lt; <span class="string">' '</span>;    }    <span class="built_in">print</span>(tr[p].r);}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    cin &gt;&gt; n &gt;&gt; m;    root = <span class="built_in">build</span>(<span class="number">1</span>, n + <span class="number">2</span>);    <span class="keyword">while</span> (m--) {        cin &gt;&gt; l &gt;&gt; r;        <span class="built_in">reserve</span>(l, r);    }    <span class="built_in">print</span>(root);    cout &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本题有多个提交渠道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://loj.ac/p/105&quot;&gt;LibreOJ 105&lt;/a&gt; &lt;small&gt;(&lt;a href=&quot;https://github.com/renba</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="LibreOJ" scheme="https://oi.baoshuo.ren/tags/LibreOJ/"/>
    
    <category term="洛谷" scheme="https://oi.baoshuo.ren/tags/%E6%B4%9B%E8%B0%B7/"/>
    
    <category term="AcWing" scheme="https://oi.baoshuo.ren/tags/AcWing/"/>
    
    <category term="S2OJ" scheme="https://oi.baoshuo.ren/tags/S2OJ/"/>
    
    <category term="Treap" scheme="https://oi.baoshuo.ren/tags/Treap/"/>
    
    <category term="平衡树" scheme="https://oi.baoshuo.ren/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>无旋 Treap 学习笔记</title>
    <link href="https://oi.baoshuo.ren/notes/ds/fhq-treap/"/>
    <id>https://oi.baoshuo.ren/notes/ds/fhq-treap/</id>
    <published>2022-02-18T15:27:40.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>无旋 Treap，又名 FHQ-Treap。无旋 Treap 仅有两种核心操作 —— 分裂与合并，它依靠这两种操作来维护树的平衡，从而省去了旋转操作。这种操作方式使得它天生支持维护序列、可持久化等特性。</p><span id="more"></span><p>本文提供使用原生指针和数组模拟指针两种方法实现的代码，可以点击代码块上方的切换按钮查看两种不同版本的代码。</p><h2 id="前言">前言</h2><p>Treap 是一种弱平衡的二叉搜索树。它的数据结构由二叉树和二叉堆组合形成，名字也因此为 tree 和 heap 的组合。</p><p>Treap 的每个结点上除了按照二叉搜索树排序的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>key</mtext></mrow><annotation encoding="application/x-tex">\text{key}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">key</span></span></span></span></span> 值外要额外储存一个叫 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>priority</mtext></mrow><annotation encoding="application/x-tex">\text{priority}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">priority</span></span></span></span></span> 的值。它由每个结点建立时随机生成，并按照最大堆性质排序。因此 Treap 除了要满足二叉搜索树的性质之外，还需满足父节点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>priority</mtext></mrow><annotation encoding="application/x-tex">\text{priority}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">priority</span></span></span></span></span> 大于等于两个子节点的值。所以它是期望平衡的。搜索，插入和删除操作的期望时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h2 id="主要操作">主要操作</h2><h3 id="分裂">分裂</h3><p>本节所介绍的分裂操作会按照排名将一棵树分裂为两棵子树，左子树包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个元素，右子树包含剩余元素。</p><p>分割时，如果左子树中元素个数不足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个，就从右子树中分割 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mtext>size</mtext><mo stretchy="false">(</mo><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k - \text{size}(\mathit{left}) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">size</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit">left</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个元素放置到左子树中，反之则从左子树中划分出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>size</mtext><mo stretchy="false">(</mo><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><mo stretchy="false">)</mo><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\text{size}(\mathit{left}) - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">size</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit">left</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个元素放置到右子树中。</p><p>不要忘记 pushup。</p><div data-group=""><div data-title="指针"><pre><code class="highlight cpp"><span class="function">std::pair&lt;Treap::node *, Treap::node *&gt; <span class="title">Treap::split</span><span class="params">(Treap::node *p, <span class="type">int</span> k)</span> </span>{    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);    std::pair&lt;Treap::node *, Treap::node *&gt; o;    <span class="keyword">if</span> (k &lt;= <span class="keyword">this</span>-&gt;<span class="built_in">getNodeSize</span>(p-&gt;left)) {        o = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(p-&gt;left, k);        p-&gt;left = o.second;        p-&gt;<span class="built_in">pushup</span>();        o.second = p;    } <span class="keyword">else</span> {        o = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(p-&gt;right, k - <span class="keyword">this</span>-&gt;<span class="built_in">getNodeSize</span>(p-&gt;left) - <span class="number">1</span>);        p-&gt;right = o.first;        p-&gt;<span class="built_in">pushup</span>();        o.first = p;    }    <span class="keyword">return</span> o;}</code></pre></div><div data-title="数组"><pre><code class="highlight cpp"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">Treap::split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span> </span>{    <span class="keyword">if</span> (!p) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);    <span class="keyword">if</span> (k &lt;= <span class="keyword">this</span>-&gt;tr[<span class="keyword">this</span>-&gt;tr[p].l].s) {        <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(<span class="keyword">this</span>-&gt;tr[p].l, k);        <span class="keyword">this</span>-&gt;tr[p].l = o.second;        <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(p);        o.second = p;        <span class="keyword">return</span> o;    }    <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(<span class="keyword">this</span>-&gt;tr[p].r, k - <span class="keyword">this</span>-&gt;tr[<span class="keyword">this</span>-&gt;tr[p].l].s - <span class="number">1</span>);    <span class="keyword">this</span>-&gt;tr[p].r = o.first;    <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(p);    o.first = p;    <span class="keyword">return</span> o;}</code></pre></div></div><h3 id="按值分裂">按值分裂</h3><p>本节介绍的分裂操作将会按照元素值的大小将一棵树分裂为两棵子树，左子树中的元素均不大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">\mathit{val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathit">val</span></span></span></span></span>，右子树中的元素均大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">\mathit{val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathit">val</span></span></span></span></span>。</p><div data-group=""><div data-title="指针"><pre><code class="highlight cpp"><span class="function">std::pair&lt;Treap::node *, Treap::node *&gt; <span class="title">Treap::splitByValue</span><span class="params">(Treap::node *p, <span class="type">int</span> val)</span> </span>{    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);    std::pair&lt;Treap::node *, Treap::node *&gt; o;    <span class="keyword">if</span> (p-&gt;val &lt; val) {        o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(p-&gt;right, val);        p-&gt;right = o.first;        p-&gt;<span class="built_in">pushup</span>();        o.first = p;    } <span class="keyword">else</span> {        o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(p-&gt;left, val);        p-&gt;left = o.second;        p-&gt;<span class="built_in">pushup</span>();        o.second = p;    }    <span class="keyword">return</span> o;}</code></pre></div><div data-title="数组"><pre><code class="highlight cpp"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">Treap::splitByValue</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>{    <span class="keyword">if</span> (!p) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tr[p].v &lt; v) {        <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(tr[p].r, v);        <span class="keyword">this</span>-&gt;tr[p].r = o.first;        <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(p);        o.first = p;        <span class="keyword">return</span> o;    }    <span class="keyword">auto</span> o = <span class="built_in">splitByValue</span>(<span class="keyword">this</span>-&gt;tr[p].l, v);    <span class="keyword">this</span>-&gt;tr[p].l = o.second;    <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(p);    o.second = p;    <span class="keyword">return</span> o;}</code></pre></div></div><h3 id="合并">合并</h3><p>合并操作也就是将两棵 Treap 合并成一棵 Treap，其中一颗 Treap 的所有点的权值均小于或大于另一颗 Treap 任意点的权值。</p><div data-group=""><div data-title="指针"><pre><code class="highlight cpp"><span class="function">Treap::node *<span class="title">Treap::merge</span><span class="params">(Treap::node *x, Treap::node *y)</span> </span>{    <span class="keyword">if</span> (x == <span class="literal">nullptr</span>) <span class="keyword">return</span> y;    <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) <span class="keyword">return</span> x;    <span class="keyword">if</span> (x-&gt;key &gt; y-&gt;key) {        x-&gt;right = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(x-&gt;right, y);        x-&gt;<span class="built_in">pushup</span>();        <span class="keyword">return</span> x;    }    y-&gt;left = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(x, y-&gt;left);    y-&gt;<span class="built_in">pushup</span>();    <span class="keyword">return</span> y;}</code></pre></div><div data-title="数组"><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">Treap::merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>{    <span class="keyword">if</span> (!x) <span class="keyword">return</span> y;    <span class="keyword">if</span> (!y) <span class="keyword">return</span> x;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tr[x].k &gt; <span class="keyword">this</span>-&gt;tr[y].k) {        <span class="keyword">this</span>-&gt;tr[x].r = <span class="built_in">merge</span>(<span class="keyword">this</span>-&gt;tr[x].r, y);        <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(x);        <span class="keyword">return</span> x;    }    <span class="keyword">this</span>-&gt;tr[y].l = <span class="built_in">merge</span>(x, <span class="keyword">this</span>-&gt;tr[y].l);    <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(y);    <span class="keyword">return</span> y;}</code></pre></div></div><h2 id="内部工具库">内部工具库</h2><h3 id="获取子树大小">获取子树大小</h3><p>判断子树是否为空，若空返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，非空返回子树大小。</p><pre><code class="highlight cpp"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Treap::getNodeSize</span><span class="params">(Treap::node *node)</span> </span>{    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">0</span> : node-&gt;size;}</code></pre><h3 id="查找元素-find">查找元素 (find)</h3><p>递归查找值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">\mathit{val}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathit">val</span></span></span></span></span> 的元素，根据 BST 的性质即可进行。</p><p>递归到某个节点时，先判断当前节点的元素值大小，若查询值小于当前节点的元素值时则向左子树递归，反之则向右子树递归。时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><div data-group=""><div data-title="指针"><pre><code class="highlight cpp"><span class="function">Treap::node *<span class="title">Treap::find</span><span class="params">(Treap::node *p, <span class="type">int</span> val)</span> </span>{    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;    <span class="keyword">if</span> (p-&gt;val == val) <span class="keyword">return</span> p;    <span class="keyword">if</span> (p-&gt;val &gt; val) <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(p-&gt;left, val);    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(p-&gt;right, val);}</code></pre></div><div data-title="数组"><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">Treap::find</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>{    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tr[p].v == v) <span class="keyword">return</span> p;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tr[p].v &gt; v) <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(<span class="keyword">this</span>-&gt;tr[p].l, v);    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(<span class="keyword">this</span>-&gt;tr[p].r, v);}</code></pre></div></div><h2 id="封装函数">封装函数</h2><h3 id="插入">插入</h3><p>先将整个 Treap 按照给定的值分割成两个子树，再在这两个子树的中间插入新值即可。</p><div data-group=""><div data-title="指针"><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">Treap::insert</span><span class="params">(<span class="type">int</span> val)</span> </span>{    <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(<span class="keyword">this</span>-&gt;root, val);    o.first = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(o.first, <span class="keyword">new</span> Treap::<span class="built_in">node</span>(val));    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(o.first, o.second);}</code></pre></div><div data-title="数组"><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v)</span> </span>{    <span class="keyword">auto</span> o = <span class="built_in">splitByValue</span>(root, v);    <span class="type">int</span> p = ++cnt;    tr[p] = <span class="built_in">node</span>(v);    o.first = <span class="built_in">merge</span>(o.first, p);    root = <span class="built_in">merge</span>(o.first, o.second);}</code></pre></div></div><h3 id="删除">删除</h3><p>本删除操作在遇到多个相同的数时只会删除一个。具体操作与插入类似，不再过多叙述。</p><div data-group=""><div data-title="指针"><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">Treap::erase</span><span class="params">(<span class="type">int</span> val)</span> </span>{    <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(<span class="keyword">this</span>-&gt;root, val);    <span class="keyword">auto</span> t = o;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(o.second, val) != <span class="literal">nullptr</span>) {        t = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(o.second, <span class="number">1</span>);        <span class="keyword">delete</span> t.first;    }    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(o.first, t.second);}</code></pre></div><div data-title="数组"><pre><code class="highlight cpp"><span class="function"><span class="type">void</span> <span class="title">Treap::erase</span><span class="params">(<span class="type">int</span> v)</span> </span>{    <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(root, v);    <span class="keyword">auto</span> t = o;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(o.second, v)) {        t = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(o.second, <span class="number">1</span>);    }    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(o.first, t.second);}</code></pre></div></div><h3 id="排名">排名</h3><p>将整棵树按值分裂，左子树的大小再加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 即为该数的排名。</p><div data-group=""><div data-title="指针"><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">Treap::getRank</span><span class="params">(<span class="type">int</span> val)</span> </span>{    <span class="keyword">auto</span> x = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(<span class="keyword">this</span>-&gt;root, val);    <span class="type">int</span> r = <span class="keyword">this</span>-&gt;<span class="built_in">getNodeSize</span>(x.first) + <span class="number">1</span>;    <span class="keyword">this</span>-&gt;root = <span class="built_in">merge</span>(x.first, x.second);    <span class="keyword">return</span> r;}</code></pre></div><div data-title="数组"><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">Treap::getRank</span><span class="params">(<span class="type">int</span> v)</span> </span>{    <span class="keyword">auto</span> x = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(<span class="keyword">this</span>-&gt;root, v);    <span class="type">int</span> r = <span class="keyword">this</span>-&gt;tr[x.first].s;    <span class="keyword">this</span>-&gt;root = <span class="built_in">merge</span>(x.first, x.second);    <span class="keyword">return</span> ++r;}</code></pre></div></div><h3 id="第-k-大元素">第 k 大元素</h3><p>将整棵树分裂为由前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个元素和其余节点组成的两棵子树，则右子树的第一个元素即为所求。</p><div data-group=""><div data-title="指针"><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">Treap::getKth</span><span class="params">(<span class="type">int</span> k)</span> </span>{    <span class="keyword">auto</span> x = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(<span class="keyword">this</span>-&gt;root, k - <span class="number">1</span>);    <span class="keyword">auto</span> y = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(x.second, <span class="number">1</span>);    Treap::node *o = y.first;    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(x.first, <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(y.first, y.second));    <span class="keyword">return</span> o == <span class="literal">nullptr</span> ? <span class="number">0</span> : o-&gt;val;}</code></pre></div><div data-title="数组"><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">Treap::getKth</span><span class="params">(<span class="type">int</span> k)</span> </span>{    <span class="keyword">auto</span> x = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(<span class="keyword">this</span>-&gt;root, k - <span class="number">1</span>);    <span class="keyword">auto</span> y = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(x.second, <span class="number">1</span>);    <span class="type">int</span> o = y.first;    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(x.first, <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(y.first, y.second));    <span class="keyword">return</span> tr[o].v;}</code></pre></div></div><h2 id="代码-55">代码</h2><p>需要的外部函数：<a href="https://zh.cppreference.com/w/cpp/numeric/random/rand"><code>rand</code></a>（定义于头文件 <a href="https://zh.cppreference.com/w/cpp/header/cstdlib"><code>&lt;cstdlib&gt;</code></a>）。</p><p>指针版和数组版的 <code>Treap</code> 类暴露出的接口是一样的。</p><div data-group=""><div data-title="指针"><pre><code class="highlight cpp"><span class="comment">// Definition</span><span class="keyword">class</span> <span class="title class_">Treap</span> {  <span class="keyword">private</span>:    <span class="keyword">struct</span> <span class="title class_">node</span> {        node *left, *right;        <span class="type">int</span> size, val, key;        <span class="built_in">node</span>();        <span class="built_in">node</span>(<span class="type">int</span>);        ~<span class="built_in">node</span>();        <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">()</span></span>;    } * root;    <span class="function"><span class="type">int</span> <span class="title">getNodeSize</span><span class="params">(node *)</span></span>;    <span class="function">node *<span class="title">find</span><span class="params">(node *, <span class="type">int</span>)</span></span>;    <span class="function">std::pair&lt;node *, node *&gt; <span class="title">split</span><span class="params">(node *, <span class="type">int</span>)</span></span>;    <span class="function">std::pair&lt;node *, node *&gt; <span class="title">splitByValue</span><span class="params">(node *, <span class="type">int</span>)</span></span>;    <span class="function">node *<span class="title">merge</span><span class="params">(node *, node *)</span></span>;  <span class="keyword">public</span>:    <span class="built_in">Treap</span>();    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>)</span></span>;    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span>)</span></span>;    <span class="function"><span class="type">int</span> <span class="title">getRank</span><span class="params">(<span class="type">int</span>)</span></span>;    <span class="function"><span class="type">int</span> <span class="title">getKth</span><span class="params">(<span class="type">int</span>)</span></span>;} tree;<span class="comment">// === Treap ===</span><span class="comment">// struct Treap::node</span>Treap::node::<span class="built_in">node</span>()    : <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">key</span>(<span class="built_in">rand</span>()) {}Treap::node::<span class="built_in">node</span>(<span class="type">int</span> _val)    : <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">size</span>(<span class="number">1</span>), <span class="built_in">val</span>(_val), <span class="built_in">key</span>(<span class="built_in">rand</span>()) {}Treap::node::~<span class="built_in">node</span>() {    <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;left, <span class="keyword">this</span>-&gt;right;}<span class="keyword">inline</span> <span class="type">void</span> Treap::node::<span class="built_in">pushup</span>() {    <span class="keyword">this</span>-&gt;size = <span class="number">1</span>;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;left != <span class="literal">nullptr</span>) <span class="keyword">this</span>-&gt;size += <span class="keyword">this</span>-&gt;left-&gt;size;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;right != <span class="literal">nullptr</span>) <span class="keyword">this</span>-&gt;size += <span class="keyword">this</span>-&gt;right-&gt;size;}<span class="comment">// class Treap</span>Treap::<span class="built_in">Treap</span>()    : <span class="built_in">root</span>(<span class="literal">nullptr</span>) {}<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Treap::getNodeSize</span><span class="params">(Treap::node *node)</span> </span>{    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">0</span> : node-&gt;size;}<span class="function">std::pair&lt;Treap::node *, Treap::node *&gt; <span class="title">Treap::split</span><span class="params">(Treap::node *p, <span class="type">int</span> k)</span> </span>{    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);    std::pair&lt;Treap::node *, Treap::node *&gt; o;    <span class="keyword">if</span> (k &lt;= <span class="keyword">this</span>-&gt;<span class="built_in">getNodeSize</span>(p-&gt;left)) {        o = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(p-&gt;left, k);        p-&gt;left = o.second;        p-&gt;<span class="built_in">pushup</span>();        o.second = p;    } <span class="keyword">else</span> {        o = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(p-&gt;right, k - <span class="keyword">this</span>-&gt;<span class="built_in">getNodeSize</span>(p-&gt;left) - <span class="number">1</span>);        p-&gt;right = o.first;        p-&gt;<span class="built_in">pushup</span>();        o.first = p;    }    <span class="keyword">return</span> o;}<span class="function">std::pair&lt;Treap::node *, Treap::node *&gt; <span class="title">Treap::splitByValue</span><span class="params">(Treap::node *p, <span class="type">int</span> val)</span> </span>{    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);    std::pair&lt;Treap::node *, Treap::node *&gt; o;    <span class="keyword">if</span> (p-&gt;val &lt; val) {        o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(p-&gt;right, val);        p-&gt;right = o.first;        p-&gt;<span class="built_in">pushup</span>();        o.first = p;    } <span class="keyword">else</span> {        o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(p-&gt;left, val);        p-&gt;left = o.second;        p-&gt;<span class="built_in">pushup</span>();        o.second = p;    }    <span class="keyword">return</span> o;}<span class="function">Treap::node *<span class="title">Treap::merge</span><span class="params">(Treap::node *x, Treap::node *y)</span> </span>{    <span class="keyword">if</span> (x == <span class="literal">nullptr</span>) <span class="keyword">return</span> y;    <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) <span class="keyword">return</span> x;    <span class="keyword">if</span> (x-&gt;key &gt; y-&gt;key) {        x-&gt;right = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(x-&gt;right, y);        x-&gt;<span class="built_in">pushup</span>();        <span class="keyword">return</span> x;    }    y-&gt;left = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(x, y-&gt;left);    y-&gt;<span class="built_in">pushup</span>();    <span class="keyword">return</span> y;}<span class="function">Treap::node *<span class="title">Treap::find</span><span class="params">(Treap::node *p, <span class="type">int</span> val)</span> </span>{    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;    <span class="keyword">if</span> (p-&gt;val == val) <span class="keyword">return</span> p;    <span class="keyword">if</span> (p-&gt;val &gt; val) <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(p-&gt;left, val);    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(p-&gt;right, val);}<span class="function"><span class="type">void</span> <span class="title">Treap::insert</span><span class="params">(<span class="type">int</span> val)</span> </span>{    <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(<span class="keyword">this</span>-&gt;root, val);    o.first = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(o.first, <span class="keyword">new</span> Treap::<span class="built_in">node</span>(val));    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(o.first, o.second);}<span class="function"><span class="type">void</span> <span class="title">Treap::erase</span><span class="params">(<span class="type">int</span> val)</span> </span>{    <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(<span class="keyword">this</span>-&gt;root, val);    <span class="keyword">auto</span> t = o;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(o.second, val) != <span class="literal">nullptr</span>) {        t = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(o.second, <span class="number">1</span>);        <span class="keyword">delete</span> t.first;    }    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(o.first, t.second);}<span class="function"><span class="type">int</span> <span class="title">Treap::getRank</span><span class="params">(<span class="type">int</span> val)</span> </span>{    <span class="keyword">auto</span> x = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(<span class="keyword">this</span>-&gt;root, val);    <span class="type">int</span> r = <span class="keyword">this</span>-&gt;<span class="built_in">getNodeSize</span>(x.first) + <span class="number">1</span>;    <span class="keyword">this</span>-&gt;root = <span class="built_in">merge</span>(x.first, x.second);    <span class="keyword">return</span> r;}<span class="function"><span class="type">int</span> <span class="title">Treap::getKth</span><span class="params">(<span class="type">int</span> k)</span> </span>{    <span class="keyword">auto</span> x = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(<span class="keyword">this</span>-&gt;root, k - <span class="number">1</span>);    <span class="keyword">auto</span> y = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(x.second, <span class="number">1</span>);    Treap::node *o = y.first;    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(x.first, <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(y.first, y.second));    <span class="keyword">return</span> o == <span class="literal">nullptr</span> ? <span class="number">0</span> : o-&gt;val;}</code></pre></div><div data-title="数组"><pre><code class="highlight cpp"><span class="comment">// Definition</span><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;<span class="keyword">class</span> <span class="title class_">Treap</span> {  <span class="keyword">private</span>:    <span class="type">int</span> root, cnt;    <span class="keyword">struct</span> <span class="title class_">node</span> {        <span class="type">int</span> l, r, s, v, k;        <span class="built_in">node</span>();        <span class="built_in">node</span>(<span class="type">int</span>);    } tr[N];    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span>)</span></span>;    <span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">split</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;    <span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">splitByValue</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="keyword">public</span>:    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>)</span></span>;    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span>)</span></span>;    <span class="function"><span class="type">int</span> <span class="title">getRank</span><span class="params">(<span class="type">int</span>)</span></span>;    <span class="function"><span class="type">int</span> <span class="title">getKth</span><span class="params">(<span class="type">int</span>)</span></span>;} tree;<span class="comment">// === Treap ===</span><span class="comment">// struct Treap::node</span>Treap::node::<span class="built_in">node</span>()    : <span class="built_in">l</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>), <span class="built_in">s</span>(<span class="number">0</span>), <span class="built_in">v</span>(<span class="number">0</span>), <span class="built_in">k</span>(<span class="built_in">rand</span>()) {}Treap::node::<span class="built_in">node</span>(<span class="type">int</span> _v)    : <span class="built_in">l</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>), <span class="built_in">s</span>(<span class="number">1</span>), <span class="built_in">v</span>(_v), <span class="built_in">k</span>(<span class="built_in">rand</span>()) {}<span class="comment">// class Treap</span><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Treap::pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>{    <span class="keyword">this</span>-&gt;tr[u].s = <span class="keyword">this</span>-&gt;tr[<span class="keyword">this</span>-&gt;tr[u].l].s + <span class="keyword">this</span>-&gt;tr[<span class="keyword">this</span>-&gt;tr[u].r].s + <span class="number">1</span>;}<span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">Treap::split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span> </span>{    <span class="keyword">if</span> (!p) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);    <span class="keyword">if</span> (k &lt;= <span class="keyword">this</span>-&gt;tr[<span class="keyword">this</span>-&gt;tr[p].l].s) {        <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(<span class="keyword">this</span>-&gt;tr[p].l, k);        <span class="keyword">this</span>-&gt;tr[p].l = o.second;        <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(p);        o.second = p;        <span class="keyword">return</span> o;    }    <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(<span class="keyword">this</span>-&gt;tr[p].r, k - <span class="keyword">this</span>-&gt;tr[<span class="keyword">this</span>-&gt;tr[p].l].s - <span class="number">1</span>);    <span class="keyword">this</span>-&gt;tr[p].r = o.first;    <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(p);    o.first = p;    <span class="keyword">return</span> o;}<span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">Treap::splitByValue</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>{    <span class="keyword">if</span> (!p) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tr[p].v &lt; v) {        <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(tr[p].r, v);        <span class="keyword">this</span>-&gt;tr[p].r = o.first;        <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(p);        o.first = p;        <span class="keyword">return</span> o;    }    <span class="keyword">auto</span> o = <span class="built_in">splitByValue</span>(<span class="keyword">this</span>-&gt;tr[p].l, v);    <span class="keyword">this</span>-&gt;tr[p].l = o.second;    <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(p);    o.second = p;    <span class="keyword">return</span> o;}<span class="function"><span class="type">int</span> <span class="title">Treap::merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>{    <span class="keyword">if</span> (!x) <span class="keyword">return</span> y;    <span class="keyword">if</span> (!y) <span class="keyword">return</span> x;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tr[x].k &gt; <span class="keyword">this</span>-&gt;tr[y].k) {        <span class="keyword">this</span>-&gt;tr[x].r = <span class="built_in">merge</span>(<span class="keyword">this</span>-&gt;tr[x].r, y);        <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(x);        <span class="keyword">return</span> x;    }    <span class="keyword">this</span>-&gt;tr[y].l = <span class="built_in">merge</span>(x, <span class="keyword">this</span>-&gt;tr[y].l);    <span class="keyword">this</span>-&gt;<span class="built_in">pushup</span>(y);    <span class="keyword">return</span> y;}<span class="function"><span class="type">int</span> <span class="title">Treap::find</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>{    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tr[p].v == v) <span class="keyword">return</span> p;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tr[p].v &gt; v) <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(<span class="keyword">this</span>-&gt;tr[p].l, v);    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">find</span>(<span class="keyword">this</span>-&gt;tr[p].r, v);}<span class="function"><span class="type">void</span> <span class="title">Treap::insert</span><span class="params">(<span class="type">int</span> v)</span> </span>{    <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(root, v);    <span class="type">int</span> p = ++<span class="keyword">this</span>-&gt;cnt;    <span class="keyword">this</span>-&gt;tr[p] = Treap::<span class="built_in">node</span>(v);    o.first = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(o.first, p);    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(o.first, o.second);}<span class="function"><span class="type">void</span> <span class="title">Treap::erase</span><span class="params">(<span class="type">int</span> v)</span> </span>{    <span class="keyword">auto</span> o = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(root, v);    <span class="keyword">auto</span> t = o;    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">find</span>(o.second, v)) {        t = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(o.second, <span class="number">1</span>);    }    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(o.first, t.second);}<span class="function"><span class="type">int</span> <span class="title">Treap::getRank</span><span class="params">(<span class="type">int</span> v)</span> </span>{    <span class="keyword">auto</span> x = <span class="keyword">this</span>-&gt;<span class="built_in">splitByValue</span>(<span class="keyword">this</span>-&gt;root, v);    <span class="type">int</span> r = <span class="keyword">this</span>-&gt;tr[x.first].s;    <span class="keyword">this</span>-&gt;root = <span class="built_in">merge</span>(x.first, x.second);    <span class="keyword">return</span> ++r;}<span class="function"><span class="type">int</span> <span class="title">Treap::getKth</span><span class="params">(<span class="type">int</span> k)</span> </span>{    <span class="keyword">auto</span> x = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(<span class="keyword">this</span>-&gt;root, k - <span class="number">1</span>);    <span class="keyword">auto</span> y = <span class="keyword">this</span>-&gt;<span class="built_in">split</span>(x.second, <span class="number">1</span>);    <span class="type">int</span> o = y.first;    <span class="keyword">this</span>-&gt;root = <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(x.first, <span class="keyword">this</span>-&gt;<span class="built_in">merge</span>(y.first, y.second));    <span class="keyword">return</span> tr[o].v;}</code></pre></div></div><h2 id="技巧">技巧</h2><p><strong>求数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的前驱</strong></p><pre><code class="highlight cpp"><span class="comment">// Treap tree;</span><span class="type">int</span> prev = tree.<span class="built_in">getKth</span>(tree.<span class="built_in">getRank</span>(x) - <span class="number">1</span>);</code></pre><p><strong>求数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的后继</strong></p><pre><code class="highlight cpp"><span class="comment">// Treap tree;</span><span class="type">int</span> next = tree.<span class="built_in">getKth</span>(tree.<span class="built_in">getRank</span>(x + <span class="number">1</span>));</code></pre><h2 id="参考资料-6">参考资料</h2><ol><li><a href="https://1drv.ms/b/s!ArZFopRN1XYMpsNLFo4SuiDDJ8WznA?e=eIdYUG">谈谈各种数据结构</a><sup>（<a href="https://archive.org/details/wc-2012-fhq-ds">文件存档备份</a>）</sup>，范浩强，WC2012。</li><li><a href="https://oi-wiki.org/ds/treap/">Treap</a>，OI Wiki，2022 年 2 月 7 日。</li><li><a href="https://zhuanlan.zhihu.com/p/342676067">某科学的无旋 Treap（FHQ-Treap）</a>，星夜，2021 年 1 月 25 日。</li></ol></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;无旋 Treap，又名 FHQ-Treap。无旋 Treap 仅有两种核心操作 —— 分裂与合并，它依靠这两种操作来维护树的平衡，从而省去了旋转操作。这种操作方式使得它天生支持维护序列、可持久化等特性。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://oi.baoshuo.ren/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="https://oi.baoshuo.ren/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Treap" scheme="https://oi.baoshuo.ren/tags/Treap/"/>
    
    <category term="平衡树" scheme="https://oi.baoshuo.ren/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>S2OJ - 1256. 【常中20180915T1】（第一套）牧场</title>
    <link href="https://oi.baoshuo.ren/solutions/s2oj-1256/"/>
    <id>https://oi.baoshuo.ren/solutions/s2oj-1256/</id>
    <published>2022-02-13T11:24:09.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题面-38">题面</h2><h3 id="题目描述-39">题目描述</h3><p>小 L 准备建一个牧场在里面放羊。他指定了一些他想围住的矩形草坪。他想知道把这些草坪围起来需要多长的栏杆。</p><p>例如，选取图一的草坪，栏杆将围成图二的样子。</p><p><img src="https://s1.baoshuo.ren/2022/02/13/wEfMzuq4n632e9Z.png" alt="" loading="lazy"></p><p>▲ 图 1</p><p><img src="https://s1.baoshuo.ren/2022/02/13/iaPWwA73kbn2hFR.png" alt="" loading="lazy"></p><p>▲ 图 2</p><h3 id="输入格式-34">输入格式</h3><p>输入文件的第一行是一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，表示有多少个矩形。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行给出了每一个矩形左下角坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">s_x,s_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 和右上角坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">t_x,t_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</p><h3 id="输出格式-34">输出格式</h3><p>一个正整数，表示所有矩形的周长</p><h3 id="输入输出样例-27">输入输出样例</h3><p><strong>样例输入 #1</strong></p><pre><code class="highlight text">7-15 0 5 10-5 8 20 2515 -4 24 140 -6 16 42 15 10 2230 10 36 2034 0 40 16</code></pre><p><strong>样例输出 #1</strong></p><pre><code class="highlight text">228</code></pre><h3 id="数据范围与约定-12">数据范围与约定</h3><table><thead><tr><th style="text-align:center">数据点</th><th style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></th><th style="text-align:center">特殊性质</th><th style="text-align:center">时间限制</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">= 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></td><td style="text-align:center" rowspan="3">无</td><td style="text-align:center" rowspan="7">1s</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">= 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\leq 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></td><td style="text-align:center" rowspan="2"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mstyle mathsize="0.9em"><mtext>所有坐标</mtext></mstyle><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 \leq \text{\small{所有坐标}} \leq 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord text"><span class="mord sizing reset-size6 size5"><span class="mord cjk_fallback">所有坐标</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center" rowspan="2"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">\leq 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2000</span></span></span></span></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center" rowspan="2">无</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">\leq 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5000</span></span></span></span></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center" rowspan="2"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>50000</mn></mrow><annotation encoding="application/x-tex">\leq 50000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50000</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mstyle mathsize="0.9em"><mtext>所有坐标</mtext></mstyle><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 \leq \text{\small{所有坐标}} \leq 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord text"><span class="mord sizing reset-size6 size5"><span class="mord cjk_fallback">所有坐标</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></td><td style="text-align:center" rowspan="3">1.5s</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center" rowspan="2">无</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>200000</mn></mrow><annotation encoding="application/x-tex">\leq 200000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">200000</span></span></span></span></td></tr></tbody></table><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo><mtext>&nbsp;</mtext><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>≤</mo><msub><mi>s</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 2 \times 10^5, ~ -10^5 \leq s_x, s_y, t_x, t_y \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace nobreak">&nbsp;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9221em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><h2 id="思路-44">思路</h2><p>很容易想到可以在横向和纵向上各使用一次扫描线来计算周长。</p><p>可以发现增加一条边后会引起总和改变，总和的改变量就是新增的边长，而没改变的部分则是被已存在图形覆盖掉的，无需统计。</p><p>最后将横向上的边长和与纵向上的边长和相加即为图形总周长。</p><h2 id="代码-45">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">"Ofast"</span>)</span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;<span class="type">int</span> n;<span class="type">long</span> <span class="type">long</span> ans;std::vector&lt;<span class="type">int</span>&gt; ys;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>{    <span class="type">int</span> f = <span class="number">1</span>;    <span class="type">char</span> ch = <span class="built_in">getchar</span>();    x = <span class="number">0</span>;    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) {        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;        ch = <span class="built_in">getchar</span>();    }    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) {        x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;        ch = <span class="built_in">getchar</span>();    }    x *= f;}<span class="keyword">struct</span> <span class="title class_">segment</span> {    <span class="type">int</span> x, y1, y2, k;    <span class="built_in">segment</span>()        : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y1</span>(<span class="number">0</span>), <span class="built_in">y2</span>(<span class="number">0</span>), <span class="built_in">k</span>(<span class="number">0</span>) {}    <span class="built_in">segment</span>(<span class="type">int</span> _x, <span class="type">int</span> _y1, <span class="type">int</span> _y2, <span class="type">int</span> _k)        : <span class="built_in">x</span>(_x), <span class="built_in">y1</span>(_y1), <span class="built_in">y2</span>(_y2), <span class="built_in">k</span>(_k) {}    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> segment&amp; b) <span class="type">const</span> {        <span class="keyword">return</span> x == b.x ? k &gt; b.k : x &lt; b.x;    }} seg[N &lt;&lt; <span class="number">1</span>];<span class="keyword">struct</span> <span class="title class_">rectangle</span> {    <span class="type">int</span> x1, y1, x2, y2;} q[N];<span class="keyword">struct</span> <span class="title class_">node</span> {    <span class="type">int</span> l, r;    <span class="type">long</span> <span class="type">long</span> cnt, len;    <span class="built_in">node</span>()        : <span class="built_in">l</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>), <span class="built_in">cnt</span>(<span class="number">0</span>), <span class="built_in">len</span>(<span class="number">0</span>) {}    <span class="built_in">node</span>(<span class="type">int</span> _l, <span class="type">int</span> _r)        : <span class="built_in">l</span>(_l), <span class="built_in">r</span>(_r), <span class="built_in">cnt</span>(<span class="number">0</span>), <span class="built_in">len</span>(<span class="number">0</span>) {}} tr[N &lt;&lt; <span class="number">3</span>];<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> y)</span> </span>{    <span class="keyword">return</span> std::<span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), y) - ys.<span class="built_in">begin</span>();}<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>{    <span class="keyword">if</span> (tr[u].cnt) {        tr[u].len = ys[tr[u].r + <span class="number">1</span>] - ys[tr[u].l];    } <span class="keyword">else</span> <span class="keyword">if</span> (tr[u].l != tr[u].r) {        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;    } <span class="keyword">else</span> {        tr[u].len = <span class="number">0</span>;    }}<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{    tr[u] = <span class="built_in">node</span>(l, r);    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);}<span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>{    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) {        tr[u].cnt += x;    } <span class="keyword">else</span> {        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, x);        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, x);    }    <span class="built_in">pushup</span>(u);}<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>{    std::<span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>());    std::<span class="built_in">sort</span>(seg, seg + n * <span class="number">2</span>);    ys.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>()), ys.<span class="built_in">end</span>());    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, ys.<span class="built_in">size</span>() - <span class="number">2</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i++) {        <span class="type">int</span> last = tr[<span class="number">1</span>].len;        <span class="keyword">if</span> (seg[i].y1 == seg[i].y2) <span class="keyword">continue</span>;        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].k);        ans += <span class="built_in">abs</span>(tr[<span class="number">1</span>].len - last);    }    ys.<span class="built_in">clear</span>();}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    <span class="built_in">read</span>(n);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {        <span class="built_in">read</span>(q[i].x1), <span class="built_in">read</span>(q[i].y1), <span class="built_in">read</span>(q[i].x2), <span class="built_in">read</span>(q[i].y2);    }    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) {        seg[j++] = <span class="built_in">segment</span>(q[i].x1, q[i].y1, q[i].y2, <span class="number">1</span>);        seg[j++] = <span class="built_in">segment</span>(q[i].x2, q[i].y1, q[i].y2, <span class="number">-1</span>);        ys.<span class="built_in">push_back</span>(q[i].y1);        ys.<span class="built_in">push_back</span>(q[i].y2);    }    <span class="built_in">solve</span>();    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) {        seg[j++] = <span class="built_in">segment</span>(q[i].y1, q[i].x1, q[i].x2, <span class="number">1</span>);        seg[j++] = <span class="built_in">segment</span>(q[i].y2, q[i].x1, q[i].x2, <span class="number">-1</span>);        ys.<span class="built_in">push_back</span>(q[i].x1);        ys.<span class="built_in">push_back</span>(q[i].x2);    }    <span class="built_in">solve</span>();    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题面-38&quot;&gt;题面&lt;/h2&gt;
&lt;h3 id=&quot;题目描述-39&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;小 L 准备建一个牧场在里面放羊。他指定了一些他想围住的矩形草坪。他想知道把这些草坪围起来需要多长的栏杆。&lt;/p&gt;
&lt;p&gt;例</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="https://oi.baoshuo.ren/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="S2OJ" scheme="https://oi.baoshuo.ren/tags/S2OJ/"/>
    
    <category term="扫描线" scheme="https://oi.baoshuo.ren/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>S2OJ - 1238. Simple</title>
    <link href="https://oi.baoshuo.ren/solutions/s2oj-1238/"/>
    <id>https://oi.baoshuo.ren/solutions/s2oj-1238/</id>
    <published>2022-02-11T01:00:23.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题面-37">题面</h2><h3 id="题目描述-38">题目描述</h3><p>对于给定正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n, m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span></span></span></span>，我们称正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 为好的，当且仅当存在非负整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>x</mi><mo>+</mo><mi>m</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">nx + my = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>。</p><p>现在给出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 组数据，对于每组数据，给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n, m, q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, q]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">]</span></span></span></span> 内有多少个正整数不是好的。</p><h3 id="输入格式-33">输入格式</h3><p>第一行，一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 表示数据组数。</p><p>接下来每行三个数，分别表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n, m, q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，即一组询问。</p><h3 id="输出格式-33">输出格式</h3><p>对于每组数据，输出一行表示答案。</p><h3 id="输入输出样例-26">输入输出样例</h3><p><strong>输入样例 #1</strong></p><pre><code class="highlight text">278 100 470 3 34</code></pre><p><strong>输出样例 #1</strong></p><pre><code class="highlight text">423</code></pre><h3 id="数据范围及约定-2">数据范围及约定</h3><ul><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">30%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n, m, q \leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">60\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">60%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n, m, q \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup><mo separator="true">,</mo><mi>T</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">n \leq 10^5, m \leq 10^9, q \leq 10^{18}, T \leq 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>。</li></ul><h2 id="思路-43">思路</h2><p>先考虑将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>x</mi><mo>+</mo><mi>m</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">nx + my = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 单独提出来，得到下面两个式子：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><mi>c</mi><mo>−</mo><mi>m</mi><mi>y</mi></mrow><mi>n</mi></mfrac></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">x = \frac{c - my}{n} \tag{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.9463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height:1.9463em;vertical-align:-0.686em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>y</mi><mo>=</mo><mfrac><mrow><mi>c</mi><mo>−</mo><mi>n</mi><mi>x</mi></mrow><mi>m</mi></mfrac></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">y = \frac{c - nx}{m} \tag{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.9463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="tag"><span class="strut" style="height:1.9463em;vertical-align:-0.686em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p><p>可以考虑枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 之中的任意一个数，根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 式或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 式计算出对应 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo separator="true">,</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y, x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span></span></span></span> 的值。</p><p>通过数据范围可以发现，当使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 式计算时会超时。</p><p>再通过暴力打表（程序见文末）可以发现一个规律：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> 在到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>lcm</mtext><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{lcm}(n, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 时会重复，那么只需枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>lcm</mtext><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">\min(\text{lcm}(n, m), q) / m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord text"><span class="mord">lcm</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">m</span></span></span></span> 即可。</p><p>最后输出时需要去掉 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = 0, y = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的情况，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ans - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 即可。</p><h2 id="代码-44">代码</h2><details open=""><summary>AC 代码</summary><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="meta">#<span class="keyword">define</span> endl <span class="string">'\n'</span></span><span class="type">int</span> t, n, m;<span class="type">long</span> <span class="type">long</span> q;<span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{    <span class="keyword">return</span> <span class="number">1ll</span> * a * b / std::__gcd(a, b);}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    cin &gt;&gt; t;    <span class="keyword">while</span> (t--) {        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;        cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;        <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> y = <span class="number">0</span>; y &lt;= std::<span class="built_in">min</span>(<span class="built_in">lcm</span>(n, m) - <span class="number">1</span>, q) / m; y++) {            ans += (q - y * m) / n + <span class="number">1</span>;        }        cout &lt;&lt; q - ans + <span class="number">1</span> &lt;&lt; endl;    }    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></details><details><summary>暴力（60 分）</summary><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="meta">#<span class="keyword">define</span> endl <span class="string">'\n'</span></span><span class="type">int</span> t, n, m, q;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    cin &gt;&gt; t;    <span class="keyword">while</span> (t--) {        <span class="type">int</span> ans = <span class="number">0</span>;        std::set&lt;<span class="type">int</span>&gt; set;        cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i * n &lt;= q; i++) {            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i * n + j * m &lt;= q; j++) {                <span class="keyword">if</span> (i * n + j * m &lt;= q) {                    set.<span class="built_in">insert</span>(i * n + j * m);                }            }        }        cout &lt;&lt; q - set.<span class="built_in">size</span>() + <span class="number">1</span> &lt;&lt; endl;    }    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></details></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题面-37&quot;&gt;题面&lt;/h2&gt;
&lt;h3 id=&quot;题目描述-38&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;对于给定正整数 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math x</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数学" scheme="https://oi.baoshuo.ren/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="S2OJ" scheme="https://oi.baoshuo.ren/tags/S2OJ/"/>
    
  </entry>
  
  <entry>
    <title>S2OJ - 1230. 小奇的数列</title>
    <link href="https://oi.baoshuo.ren/solutions/s2oj-1230/"/>
    <id>https://oi.baoshuo.ren/solutions/s2oj-1230/</id>
    <published>2022-01-21T09:05:39.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="题面-36">题面</h2><h3 id="题目描述-37">题目描述</h3><p>小奇总是在数学课上思考奇怪的问题。</p><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的数列，以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 次询问，每次给出三个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>，询问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><msup><mi>l</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo>+</mo><msub><mi>a</mi><mrow><msup><mi>l</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msub><mo stretchy="false">)</mo><mspace></mspace><mspace width="0.4444em"></mspace><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"></mspace><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_{l'} + a_{l' + 1} + \dots + a_{r'}) \pmod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span> 的最小值（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>≤</mo><msup><mi>l</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>≤</mo><msup><mi>r</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>≤</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l \leq l' \leq r' \leq r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8879em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8879em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>）。</p><p>即模意义下的区间子串和最小值。</p><h3 id="输入格式-32">输入格式</h3><p>第一行包含两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，表示数列的长度和询问的个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1, \dots, a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行三个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>，代表一次询问。</p><h3 id="输出格式-32">输出格式</h3><p>对于每次询问，输出一行一个整数表示要求的结果。</p><h3 id="输入输出样例-25">输入输出样例</h3><p><strong>输入样例 #1</strong></p><pre><code class="highlight text">4 28 15 9 91 3 101 4 17</code></pre><p><strong>输出样例 #1</strong></p><pre><code class="highlight text">21</code></pre><h3 id="数据范围及约定">数据范围及约定</h3><ul><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">20%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>100</mn><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100</mn><mo separator="true">,</mo><mi>p</mi><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">n \leq 100, m \leq 100, p \leq 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">200</span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">40\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">40%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>200</mn><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1000</mn><mo separator="true">,</mo><mi>p</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">n \leq 200, m \leq 1000, p \leq 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">200</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">500</span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">70%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>100000</mn><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>10000</mn><mo separator="true">,</mo><mi>p</mi><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">n \leq 100000, m \leq 10000, p \leq 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">100000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">10000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">200</span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>500000</mn><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>10000</mn><mo separator="true">,</mo><mi>p</mi><mo>≤</mo><mn>500</mn><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">n \leq 500000, m \leq 10000, p \leq 500, 1 \leq a_i \leq 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">500000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">10000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">500</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</li></ul><h2 id="思路-42">思路</h2><p><strong>20 分</strong></p><p>对于每个询问，在区间内暴力枚举子串求和、取模即可。复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p><strong>40 分</strong></p><p>考虑在 20 分做法的基础上优化。不难发现，区间求和可以使用前缀和优化。复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p><strong>70 分</strong></p><p>通过 <a href="https://oi-wiki.org/math/combinatorics/drawer-principle/">抽屉原理</a> 可知，当询问的区间长度大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 时（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>−</mo><mi>l</mi><mo>≥</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">r - l \geq p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 时），一定有两个前缀和相减等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，此时直接输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 即可。</p><p>再考虑枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，可知当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">\mathit{sum}_{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathit">sum</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的前驱时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><mi>r</mi></msub><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\mathit{sum}_{r} - k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathit">sum</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 最小。时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><msup><mi>p</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mp^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p><strong>100 分</strong></p><p>使用 <code>std::set</code> 维护前驱即可。时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>p</mi><mi>log</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mp \log p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>。</p><h2 id="代码-43">代码</h2><details><summary>40 分</summary><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;<span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;<span class="type">int</span> n, m, l, r, p, a[N];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    cin &gt;&gt; n &gt;&gt; m;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        cin &gt;&gt; a[i];    }    <span class="keyword">while</span> (m--) {        cin &gt;&gt; l &gt;&gt; r &gt;&gt; p;        <span class="type">int</span> ans = p;        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) {            <span class="type">int</span> sum = <span class="number">0</span>;            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= r; j++) {                sum = (sum + a[j]) % p;                ans = std::<span class="built_in">min</span>(ans, sum);            }        }        cout &lt;&lt; ans &lt;&lt; endl;    }    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></details><details><summary>70 分</summary><p>OJ 上的数据比较水，所以这样也能 A 掉。</p><p>提交记录：<a href="https://github.com/renbaoshuo/OI-codes/commit/0616685fc99831dbd3d0e68c66fcec8b4d3373ec"><code>0616685</code></a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;<span class="type">const</span> <span class="type">int</span> N = <span class="number">500005</span>;<span class="type">const</span> <span class="type">int</span> P = <span class="number">505</span>;<span class="type">int</span> n, m, l, r, p, a[N];<span class="type">long</span> <span class="type">long</span> sum[N];<span class="type">bool</span> vis[P];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    cin &gt;&gt; n &gt;&gt; m;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        cin &gt;&gt; a[i];    }    <span class="keyword">while</span> (m--) {        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0x3f3f3f3f</span>;        <span class="built_in">memset</span>(vis, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(vis));        vis[<span class="number">0</span>] = <span class="literal">true</span>;        cin &gt;&gt; l &gt;&gt; r &gt;&gt; p;        <span class="keyword">if</span> (r - l &gt;= p) {            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;            <span class="keyword">continue</span>;        }        sum[l - <span class="number">1</span>] = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) {            sum[i] = (sum[i - <span class="number">1</span>] + a[i]) % p;            <span class="keyword">for</span> (<span class="type">int</span> j = sum[i]; j &gt;= <span class="number">0</span>; j--) {                <span class="keyword">if</span> (vis[j]) {                    ans = std::<span class="built_in">min</span>(ans, sum[i] - j);                }            }            vis[sum[i]] = <span class="literal">true</span>;        }        cout &lt;&lt; ans &lt;&lt; endl;    }    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></details><details open=""><summary>100 分</summary><p>提交记录：<a href="https://github.com/renbaoshuo/OI-codes/commit/d5b8f54a8a0e9005b1eaecd70ffde9d11c5f0d4b"><code>d5b8f54</code></a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;<span class="type">const</span> <span class="type">int</span> N = <span class="number">500005</span>;<span class="type">int</span> n, m, l, r, p, a[N];<span class="type">long</span> <span class="type">long</span> sum[N];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    cin &gt;&gt; n &gt;&gt; m;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        cin &gt;&gt; a[i];    }    <span class="keyword">while</span> (m--) {        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0x3f3f3f3f</span>;        cin &gt;&gt; l &gt;&gt; r &gt;&gt; p;        <span class="keyword">if</span> (r - l &gt;= p) {            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;            <span class="keyword">continue</span>;        }        std::set&lt;<span class="type">long</span> <span class="type">long</span>&gt; s;        s.<span class="built_in">insert</span>(<span class="number">0</span>);        sum[l - <span class="number">1</span>] = <span class="number">0</span>;        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) {            sum[i] = (sum[i - <span class="number">1</span>] + a[i]) % p;            ans = std::<span class="built_in">min</span>(ans, sum[i] - *(--s.<span class="built_in">upper_bound</span>(sum[i])));            s.<span class="built_in">insert</span>(sum[i]);        }        cout &lt;&lt; ans &lt;&lt; endl;    }    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></details></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;题面-36&quot;&gt;题面&lt;/h2&gt;
&lt;h3 id=&quot;题目描述-37&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;小奇总是在数学课上思考奇怪的问题。&lt;/p&gt;
&lt;p&gt;给定一个长度为 &lt;span class=&quot;katex&quot;&gt;&lt;span cla</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数学" scheme="https://oi.baoshuo.ren/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="S2OJ" scheme="https://oi.baoshuo.ren/tags/S2OJ/"/>
    
  </entry>
  
  <entry>
    <title>LibreOJ - 2759. 「JOI 2014 Final」飞天鼠</title>
    <link href="https://oi.baoshuo.ren/solutions/libreoj-2759/"/>
    <id>https://oi.baoshuo.ren/solutions/libreoj-2759/</id>
    <published>2022-01-16T19:57:47.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本题有多个提交渠道：</p><ul><li><a href="https://loj.ac/p/2759">LibreOJ #2759</a> (<a href="https://github.com/renbaoshuo/OI-codes/commit/ff4a803b1718ab95919dea013525fbffd3398eaa"><code>ff4a803</code></a>)</li><li><a href="https://sjzezoj.com/problem/1266">S2OJ #1266</a> (<a href="https://github.com/renbaoshuo/OI-codes/commit/5ddfd923267ade42a6178e589b1682fcc872d704"><code>5ddfd92</code></a>)</li></ul><hr><h2 id="题面-9">题面</h2><h3 id="题目描述-9">题目描述</h3><p><strong>译自 <a href="https://www.ioi-jp.org/joi/2013/2014-ho/index.html">JOI 2014 Final</a> T4「<a href="https://www.ioi-jp.org/joi/2013/2014-ho/2014-ho.pdf">フクロモモンガ</a>」</strong></p><p>飞天鼠 JOI 君住着的森林里长着编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 棵桉树。第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 棵树的高度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 米。</p><p>JOI 君能在其中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 对桉树之间直接飞行，在各对树木之间飞行所需的时间是固定的。当 JOI 君在树木之间飞行的时候，他离地面的高度会每秒下降 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 米。也就是说，如果 JOI 君现在离地高度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 米，在树木之间飞行需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 秒，那么飞行之后的离地高度就会变成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>−</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">h-t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 米。当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>−</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">h-t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 或大于目标树木的高度时则不能飞行。</p><p>JOI 君还能沿着树的侧面上下移动，使得他的离地高度在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到当前所在树木高度的范围内变化。JOI 君每使自己的离地高度增加或减少 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 米都需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 秒的时间。</p><p>JOI 君要从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 号树木上高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 米的位置出发，到树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的顶端（高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">H_{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 米的位置）去。他想知道为了达成这个目标所需时间的最小值。</p><p>给出各棵树木的高度、JOI 君能直接飞行的树木对和 JOI 君最初所在位置的高度，请求出到达树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 顶端所需时间的最小值。</p><h3 id="输入格式-9">输入格式</h3><p>第一行包含三个以空格分开的整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N, M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，意义分别与题目描述中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N, M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 相同。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行中，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(1\le i\le N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 行有一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示树木<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>的高度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 米。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行中，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j(1\le j\le M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> 行有三个以空格分开的整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">A_{j},B_{j},T_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><msub><mi>A</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mi>j</mi></msub><mo>≤</mo><mi>N</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">(1\le A_{j}, B_{j}\le N,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>j</mi></msub><mo mathvariant="normal">≠</mo><msub><mi>B</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A_{j}\ne B_{j})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，表示 IOI 君能花 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">T_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 秒的时间从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">A_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 飞到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 或从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 飞到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">A_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>对于任意 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>k</mi><mo>≤</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">1\le j &lt; k\le M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mo stretchy="false">(</mo><msub><mi>A</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A_{j},B_{j})\neq (A_{k},B_{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mo stretchy="false">(</mo><msub><mi>B</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>A</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A_{j},B_{j})\neq (B_{k},A_{k})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h3 id="输出格式-9">输出格式</h3><p>输出到标准输出，仅一行一个整数，表示从树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 上高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 米处移动到树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 顶端所需时间的最小值（单位：秒）。如果不能到达目的地则输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><h3 id="输入输出样例-6">输入输出样例</h3><p><strong>样例输入 #1</strong></p><pre><code class="highlight text">5 5 0501002530101 2 102 5 502 4 204 3 15 4 20</code></pre><p><strong>样例输出 #1</strong></p><pre><code class="highlight text">110</code></pre><p><strong>样例解释 #1</strong></p><p>下列是其中一种最优解：</p><ol><li>沿着树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 向上爬 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50</span></span></span></span> 米。</li><li>从树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 飞到树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>。</li><li>从树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 飞到树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>。</li><li>从树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 飞到树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>。</li><li>沿着树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 向上爬 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> 米。</li></ol><p><strong>样例输入 #2</strong></p><pre><code class="highlight text">2 1 0111 2 100</code></pre><p><strong>样例输出 #2</strong></p><pre><code class="highlight text">-1</code></pre><p><strong>样例输出 #2</strong></p><p>JOI 君无法从树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 飞到树木 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>。</p><p><strong>样例输入 #3</strong></p><pre><code class="highlight text">4 3 30501020501 2 102 3 103 4 10</code></pre><p><strong>样例输出 #3</strong></p><pre><code class="highlight text">100</code></pre><h3 id="数据范围与约定-6">数据范围与约定</h3><p>本题采用 Subtask 方式评测。</p><table><thead><tr><th style="text-align:center">子任务编号</th><th style="text-align:center">分值</th><th style="text-align:center">数据范围</th><th>特殊性质</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><span>25 分</span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">N\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≤</mo><mn>3000</mn></mrow><annotation encoding="application/x-tex">M\le 3000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3000</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">H_{i}\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>j</mi></msub><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">T_{j}\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></td><td>无</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">25 分</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">2\le N\le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>300000</mn></mrow><annotation encoding="application/x-tex">1\le M\le 300000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">300000</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>H</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\le H_i\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>T</mi><mi>j</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\le T_j\le 10^{9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">X=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">50 分</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">2\le N\le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>300000</mn></mrow><annotation encoding="application/x-tex">1\le M\le 300000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">300000</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>H</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\le H_i\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>T</mi><mi>j</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\le T_j\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></td><td>无</td></tr></tbody></table><p>表格中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">H_i, T_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 满足：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">1\le i\le N, 1\le j\le M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>。</p><p>所有数据满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>X</mi><mo>≤</mo><msub><mi>H</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">0\le X\le H_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><h2 id="思路-9">思路</h2><p>可以使用最短路算法解决本题。</p><p>对于每条边，会有以下几种情况：</p><ol><li>到达点的高度大于树顶高度。<br>需要先向下爬到高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>v</mi></msub><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">h_v + w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 的点才能从该边飞过，可以证明这是最优选择。</li><li>在飞行途中落地。<br>这种情况又细分为两种情况：<ol><li>从树顶开始飞行时，无法到达终点。<br>此种情况在加边时即可判定并丢弃这条边。<br></li><li>从树上某点开始飞行时，无法到达终点。<br>处理完上一种情况以后，树上一定存在一个高度，使得从该高度开始正好可以飞到下一个点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 米高处。<br>容易证明，先下降到高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 的点再飞过该边是最优选择。</li></ol></li><li>能正常飞到终点。<br>正常计算即可。</li></ol><p>本题答案大小可能会超出 <code>int</code> 上界，因此需要使用 <code>long long</code> 存储。</p><h2 id="代码-9">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;<span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;<span class="type">int</span> n, m, x, h[N], nh[N];std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt;&gt; g[N];<span class="comment">// Dijkstra - Shortest Path</span><span class="type">long</span> <span class="type">long</span> dist[N];<span class="type">bool</span> vis[N];<span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>{    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));    dist[<span class="number">1</span>] = <span class="number">0</span>;    std::priority_queue&lt;std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;&gt;, std::greater&lt;std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;&gt;&gt; q;    q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));    nh[<span class="number">1</span>] = x;    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {        <span class="type">int</span> u = q.<span class="built_in">top</span>().second;        q.<span class="built_in">pop</span>();        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;        vis[u] = <span class="literal">true</span>;        <span class="keyword">for</span> (<span class="keyword">auto</span> e : g[u]) {            <span class="type">int</span> v = e.first;            <span class="type">long</span> <span class="type">long</span> w = e.second;            <span class="keyword">if</span> (nh[u] - w &gt; h[v]) {  <span class="comment">// 到达点的高度大于树顶高度</span>                <span class="keyword">if</span> (dist[v] &gt; dist[u] + nh[u] - h[v]) {                    dist[v] = dist[u] + nh[u] - h[v];                    nh[v] = h[v];                    q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(dist[v], v));                }            } <span class="keyword">else</span> <span class="keyword">if</span> (nh[u] - w &lt; <span class="number">0</span>) {  <span class="comment">// 飞行中途会落地</span>                <span class="keyword">if</span> (dist[v] &gt; dist[u] + w - (nh[u] - w)) {                    dist[v] = dist[u] + w - (nh[u] - w);                    nh[v] = <span class="number">0</span>;                    q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(dist[v], v));                }            } <span class="keyword">else</span> <span class="keyword">if</span> (dist[v] &gt; dist[u] + w) {  <span class="comment">// 其他情况</span>                dist[v] = dist[u] + w;                nh[v] = nh[u] - w;                q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(dist[v], v));            }        }    }}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        cin &gt;&gt; h[i];    }    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {        <span class="type">int</span> u, v;        <span class="type">long</span> <span class="type">long</span> w;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        <span class="comment">// 保证飞行中途不落地</span>        <span class="keyword">if</span> (w &lt;= h[u]) g[u].<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(v, w));        <span class="keyword">if</span> (w &lt;= h[v]) g[v].<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(u, w));    }    <span class="built_in">dijkstra</span>();    cout &lt;&lt; (dist[n] == <span class="number">0x3f3f3f3f3f3f3f3f</span> ? <span class="number">-1</span> : dist[n] + h[n] - nh[n]) &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本题有多个提交渠道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://loj.ac/p/2759&quot;&gt;LibreOJ #2759&lt;/a&gt; (&lt;a href=&quot;https://github.com/renbaoshu</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="图论" scheme="https://oi.baoshuo.ren/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="https://oi.baoshuo.ren/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="Dijkstra" scheme="https://oi.baoshuo.ren/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>有向图的强连通分量</title>
    <link href="https://oi.baoshuo.ren/notes/graph/scc/"/>
    <id>https://oi.baoshuo.ren/notes/graph/scc/</id>
    <published>2021-12-31T14:49:28.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="定义">定义</h2><ul><li>强连通的定义是：对于一个有向图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 中任意一对节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 可以互相到达。</li><li>强连通分量的定义是：<strong>极大强连通子图</strong>。</li></ul><p>在上面的定义中，我们称一个强连通子图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G' = (V', E')</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>「极大」（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>V</mi><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">V' \in V, E' \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>），是指不存在包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">G'</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 的更大的子图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>V</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo separator="true">,</mo><msup><mi>E</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G'' = (V'', E'')</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⊆</mo><msup><mi>V</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>⊆</mo><mi>V</mi><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⊆</mo><msup><mi>E</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>⊆</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">V' \subseteq V'' \subseteq V, E' \subseteq E'' \subseteq E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8879em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8879em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">G''</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span></span></span></span> 也是强连通子图。</p><h2 id="dfs-生成树">DFS 生成树</h2><p>在介绍 Tarjan 算法之前，需要先了解一下 <strong>DFS 生成树</strong>。</p><p>给定一个有向图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V, E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，若存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">r \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，满足从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 出发能够到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 中的所有点，则称 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 是一个流图（Flow Graph），记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 称为流图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 的源点。</p><p>在一个流图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> 上从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 出发进行深度优先遍历，每个点只访问一次。所有发生递归的边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 构成一棵以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 为根的树，我们称它为流图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span> 的 <strong>DFS 生成树</strong>。</p><p>有向图的 DFS 生成树有四种边，以下面这个有向图为例：</p><p><img src="https://s1.baoshuo.ren/2021/12/29/5ZTfE1joDA6FwMI.png" alt="" loading="lazy"></p><ul><li>树枝边：示意图中以黑色边表示（如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>→</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2 \to 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>），它是在搜索时访问到了一个还没有访问过的节点时形成的。</li><li>前向边：示意图中以绿色边表示（如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>→</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">3 \to 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span>），它是在搜索时遇到子树中的节点的时候形成的。</li><li>后向边：示意图中以红色边表示（如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">7 \to 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>），它是在搜索时遇到祖先节点时形成的。</li><li>横叉边：示意图中以蓝色边表示（如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><mo>→</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">9 \to 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span>），它是在搜索时遇到了一个已经访问过的且不是当前节点的祖先的结点时形成的。</li></ul><p>不同书籍介绍的这四种边的名称可能不同，但定义内容基本上是一样的。</p><p>此外，在 DFS 过程中，按照每个节点第一次被访问的时间顺序，依次给流图中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>&nbsp;</mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">1 ~ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace nobreak">&nbsp;</span><span class="mord mathnormal">n</span></span></span></span> 的整数标记，该标记被称为 DFS 序（也被称为时间戳），记作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>dfn</mtext></mrow><annotation encoding="application/x-tex">\text{dfn}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">dfn</span></span></span></span></span>。上图中节点的圆圈内的数字便是该节点的 DFS 序。</p><h2 id="tarjan-算法">Tarjan 算法</h2><p>Tarjan 发明了许多算法。本文中的「Tarjan 算法」指的是由 Tarjan 发明的在有向图中强连通分量的算法。</p><blockquote><p>提示：请勿混淆 <strong>边</strong> 与 <strong>路径</strong> 的概念。</p></blockquote><h3 id="实现-2">实现</h3><p>一个环一定是强连通图。如果图中既存在从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的路径（不仅仅是边），又存在从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的边，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 显然在一个环中。因此，Tarjan 算法的基本思路就是对于每个点，尽量找到与它一起能够构成环的所有节点。</p><p>容易发现，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的前向边并没有什么用处，因为 DFS 生成树上本来就存在从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的路径。从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的后向边非常有用，因为它可以和 DFS 生成树上从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的路径一起构成环。从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的横向边需要视情况而定，如果从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 出发能找到一条路径回到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的祖先节点，那么这条边也是有用的，可以成为环的一部分。</p><p>为了找到通过后向边和横叉边构成的环，Tarjan 算法需要在 DFS 的同时维护一个栈。当访问到节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 时，栈中需要保存以下两类节点：</p><ol><li>DFS 生成树上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的祖先节点，记为集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>。<br>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y \in A(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，若存在后向边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 与从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的路径一起形成环。</li><li>已经访问过，并且存在一条路径能够到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 中的节点。<br>设节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 符合该要求，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 出发存在一条路径能到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y \in A(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，若存在横叉边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x \to z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>，则这条边和从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的路径还有从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的路径可以共同形成一个环。</li></ol><p>综上所述，栈中的节点就是能与从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 出发的后向边和横叉边形成环的节点。</p><h3 id="追溯值">追溯值</h3><p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 表示流图的 DFS 生成树中以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 为根的子树。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的追溯值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>w</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">low_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 定义为满足以下条件的节点的最小时间戳。</p><ol><li>该点在栈中。</li><li>存在一条从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 中出发的有向边以该点为终点。</li></ol><p>根据定义，Tarjan 算法按照以下步骤计算追溯值：</p><ol><li>当节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 第一次被访问时，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 入栈，初始化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>low</mtext><mi>x</mi></msub><mo>=</mo><msub><mtext>dfn</mtext><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\text{low}_x = \text{dfn}_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">low</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">dfn</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>扫描从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 出发的每一条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>。<ol><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 从未被访问过，则说明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 是树枝边，递归访问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 回溯后，令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>low</mtext><mi>x</mi></msub><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mtext>low</mtext><mi>x</mi></msub><mo separator="true">,</mo><msub><mtext>low</mtext><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{low}_x = \min(\text{low}_x, \text{low}_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">low</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">low</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord text"><span class="mord">low</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li><li>若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 被访问过且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 在栈中，则令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>low</mtext><mi>x</mi></msub><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mtext>low</mtext><mi>x</mi></msub><mo separator="true">,</mo><msub><mtext>dfn</mtext><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{low}_x = \min(\text{low}_x, \text{dfn}_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">low</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">low</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord text"><span class="mord">dfn</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li></ol></li><li>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 回溯之前，判断是否有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>low</mtext><mi>x</mi></msub><mo>=</mo><msub><mtext>dfn</mtext><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\text{low}_x = \text{dfn}_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">low</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">dfn</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 成立。若成立，则不断从栈中弹出节点，直至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 出栈。</li></ol><h3 id="判定强连通分量">判定强连通分量</h3><p>在追溯值的计算过程中，若从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 回溯前有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>low</mtext><mi>x</mi></msub><mo>=</mo><msub><mtext>dfn</mtext><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\text{low}_x = \text{dfn}_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">low</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">dfn</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 成立，则栈中从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 到栈顶的所有节点均在同一个强连通分量中。</p><p>此处不作证明，有兴趣的读者可以自行查找相关论文与书籍。</p><h3 id="实现-3">实现</h3><p>说明请见代码注释。</p><pre><code class="highlight cpp"><span class="type">int</span> cnt,      <span class="comment">// 搜索过的节点个数</span>    dfn[N],   <span class="comment">// 每个点的 DFS 序</span>    low[N];   <span class="comment">// 每个点的追溯值</span><span class="type">int</span> scc_cnt,  <span class="comment">// 强连通分量个数</span>    id[N],    <span class="comment">// 每个点对应的强连通分量编号</span>    siz[N];   <span class="comment">// 每个强连通分量的节点数</span><span class="type">bool</span> vis[N];  <span class="comment">// 节点是否在栈内</span>std::stack&lt;<span class="type">int</span>&gt; st;<span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>{    dfn[u] = low[u] = ++cnt;    st.<span class="built_in">push</span>(u);    vis[u] = <span class="literal">true</span>;    <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) {        <span class="keyword">if</span> (!dfn[v]) {        <span class="comment">// 未被访问过</span>            <span class="built_in">tarjan</span>(v);            low[u] = std::<span class="built_in">min</span>(low[u], low[v]);        } <span class="keyword">else</span> <span class="keyword">if</span> (vis[v]) {  <span class="comment">// 被访问过且在栈中</span>            low[u] = std::<span class="built_in">min</span>(low[u], dfn[v]);        }    }    <span class="keyword">if</span> (dfn[u] == low[u]) {        scc_cnt++;        <span class="comment">// 强连通分量的个数加一</span>        <span class="type">int</span> v;        <span class="keyword">do</span> {            v = st.<span class="built_in">top</span>();            st.<span class="built_in">pop</span>();        <span class="comment">// 出栈</span>            vis[v] = <span class="literal">false</span>;  <span class="comment">// 取消标记</span>            siz[scc_cnt]++;  <span class="comment">// 当前强连通分量的大小加一</span>        } <span class="keyword">while</span> (v != u);    <span class="comment">// 循环到节点 x</span>    }}</code></pre><h2 id="例题及代码">例题及代码</h2><p>对应题目：<a href="https://www.luogu.com.cn/problem/P3387">洛谷 - P3387 【模板】缩点</a></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;<span class="comment">// Limits</span><span class="type">const</span> <span class="type">int</span> N = <span class="number">10005</span>;<span class="type">int</span> n, m, u, v, a[N];std::vector&lt;<span class="type">int</span>&gt; g[N], g2[N];<span class="comment">// Tarjan</span><span class="type">int</span> cnt, dfn[N], low[N];<span class="type">int</span> scc_cnt, id[N];<span class="type">int</span> w[N];<span class="type">bool</span> vis[N];std::stack&lt;<span class="type">int</span>&gt; st;<span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>{    dfn[u] = low[u] = ++cnt;    vis[u] = <span class="literal">true</span>;    st.<span class="built_in">push</span>(u);    <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) {        <span class="keyword">if</span> (!dfn[v]) {            <span class="built_in">tarjan</span>(v);            low[u] = std::<span class="built_in">min</span>(low[u], low[v]);        } <span class="keyword">else</span> <span class="keyword">if</span> (vis[v]) {            low[u] = std::<span class="built_in">min</span>(low[u], dfn[v]);        }    }    <span class="keyword">if</span> (low[u] == dfn[u]) {        scc_cnt++;        <span class="type">int</span> v;        <span class="keyword">do</span> {            v = st.<span class="built_in">top</span>();            st.<span class="built_in">pop</span>();            vis[v] = <span class="literal">false</span>;            id[v] = scc_cnt;            w[scc_cnt] += a[v];        } <span class="keyword">while</span> (v != u);    }}<span class="comment">// Shortest Path</span><span class="type">int</span> dist[N];<span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span> </span>{    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="built_in">sizeof</span>(dist));    std::queue&lt;<span class="type">int</span>&gt; q;    q.<span class="built_in">push</span>(s);    dist[s] = <span class="number">0</span>;    <span class="type">int</span> res = <span class="number">0</span>;    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {        <span class="type">int</span> u = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        res = std::<span class="built_in">max</span>(res, dist[u] + w[u]);        <span class="keyword">for</span> (<span class="type">int</span> v : g2[u]) {            <span class="keyword">if</span> (dist[v] &lt; dist[u] + w[u]) {                dist[v] = dist[u] + w[u];                q.<span class="built_in">push</span>(v);            }        }    }    <span class="keyword">return</span> res;}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    cin &gt;&gt; n &gt;&gt; m;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        cin &gt;&gt; a[i];    }    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {        cin &gt;&gt; u &gt;&gt; v;        g[u].<span class="built_in">push_back</span>(v);    }    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        <span class="keyword">if</span> (!dfn[i]) {            <span class="built_in">tarjan</span>(i);        }    }    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        <span class="keyword">for</span> (<span class="type">int</span> v : g[i]) {            <span class="keyword">if</span> (id[i] != id[v]) {                g2[id[i]].<span class="built_in">push_back</span>(id[v]);            }        }    }    <span class="type">int</span> ans = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i++) {        ans = std::<span class="built_in">max</span>(ans, <span class="built_in">spfa</span>(i));    }    cout &lt;&lt; ans &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre><h2 id="参考资料-10">参考资料</h2><ol><li>22.5 强连通分量，《算法导论》中译本（ISBN 978-7-111-40701-0，机械工业出版社），2013 年 1 月第三版。</li><li>0x67 Tarjan 算法与有向图连接性，《算法竞赛进阶指南》（ISBN 978-7-893-88198-5，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。</li><li><a href="https://oi-wiki.org/graph/concept/#_9">连通：有向图</a>，图论：相关概念，OI Wiki，2021 年 8 月 23 日。</li><li><a href="https://oi-wiki.org/graph/scc/">强连通分量</a>，图论，OI Wiki，2021 年 11 月 8 日。</li><li>3.7 有向图的强连通分量，AcWing 算法提高课，闫学灿，2019 年 11 月 30 日。</li></ol><p>本文图片由 OI Wiki 提供，在此对图片作者表示感谢。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;强连通的定义是：对于一个有向图 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www</summary>
      
    
    
    
    <category term="笔记" scheme="https://oi.baoshuo.ren/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="图论" scheme="https://oi.baoshuo.ren/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="强连通分量" scheme="https://oi.baoshuo.ren/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
    <category term="Tarjan" scheme="https://oi.baoshuo.ren/tags/Tarjan/"/>
    
  </entry>
  
  <entry>
    <title>S2OJ - 1199. 90 岁的张哥哥</title>
    <link href="https://oi.baoshuo.ren/solutions/s2oj-1199/"/>
    <id>https://oi.baoshuo.ren/solutions/s2oj-1199/</id>
    <published>2021-12-27T20:34:16.000Z</published>
    <updated>2021-12-27T20:34:16.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本题是 <a href="https://www.luogu.com.cn/problem/P1750">洛谷 - P1750 出栈序列</a> 的加强版。</p><span id="more"></span><h2 id="题面-35">题面</h2><h3 id="题目背景-5">题目背景</h3><p>90 岁的张哥哥躺在床上，奄奄一息，No enemy 和小叶子在两旁伺候。</p><p>ck 赶来：「lzl 块状链表调不出来，你去帮他 debug 吧。」<br>张哥哥：「老了，让这蒟蒻自己去调。」<br>风雪山神猫的林教头的林妹妹赶来（好像有什么不和谐的东西乱入了）：「后宫『着火了』又！」<br>张哥哥：「老了，没力气了，我相信你能搞定的。」</p><p>这时，张哥哥的手机铃声「星空使者」响起，电话那头是镕昊和克凡：「我们在 ACM 的现场，发现栈不会写……」话音未落，张哥哥腾得一声跳了起来，容光焕发：「什么？！栈都不会写，放着我来！」</p><p>这件事情告诉我们，栈，是张哥哥生前最喜欢的数据结构（与事实不符别怪我）。</p><h3 id="题目描述-36">题目描述</h3><p>我们知道，给定一个由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个元素构成的序列，将其中的元素按顺序压入一个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 的栈并弹出。元素按它们的出栈顺序进行排列，会得到一个新的序列。这样的序列可能会有很多种，请输出所有新序列中第一个元素最小的序列（若第一个元素最小的序列有多个，则令第二个尽可能小；若仍有多个，则令第三个最小，以此类推）。</p><h3 id="输入格式-31">输入格式</h3><p>第一行两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo separator="true">,</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">N, C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>。</p><p>第二行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个整数，表示将顺序入栈的元素的值。</p><h3 id="输出格式-31">输出格式</h3><p>仅一行，即满足要求的序列。</p><h3 id="输入输出样例-24">输入输出样例</h3><p><strong>样例输入 #1</strong></p><pre><code class="highlight text">3 25 3 2</code></pre><p><strong>样例输出 #1</strong></p><pre><code class="highlight text">3 2 5</code></pre><p><strong>样例说明 #1</strong></p><p>因为栈的大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，所以 <code>2 3 5</code> 尽管是最小的序列，但是是不合法的。正确的做法是先将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 压入栈中，弹出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，压入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，弹出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，弹出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span></p><h3 id="数据规模与约定-6">数据规模与约定</h3><ul><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">40\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">40%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">n \leq 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">70%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">n \leq 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>300000</mn></mrow><annotation encoding="application/x-tex">c \leq n \leq 300000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">300000</span></span></span></span>，元素大小均在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 以内。</li></ul><h2 id="思路-41">思路</h2><h3 id="70-分">70 分</h3><p>考虑贪心。</p><p>设定两个指针 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l, r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，初始值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>。</p><p>循环 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 次，每次找出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间中未被标记的最小的数并输出、标记，然后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 跳到前一个未被标记的数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 增加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p>可以证明这个贪心是正确的。</p><h3 id="100-分">100 分</h3><p>使用线段树维护区间最小值可以将区间最值的查询从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 降至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p>使用栈模拟实际操作可以省去标记已入栈的数，需要遵循以下几点注意事项：</p><ol><li>入栈时需要将当前区间内的最小值前的所有未入栈元素入栈。</li><li>确保栈内元素数量不超过栈容量。</li><li>弹出栈顶元素后从栈顶元素的后一个元素开始执行上述过程。</li></ol><h2 id="代码-42">代码</h2><details><summary>70 分代码</summary><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;<span class="type">const</span> <span class="type">int</span> N = <span class="number">300005</span>;<span class="type">int</span> n, c, l, r, a[N];<span class="type">bool</span> vis[N];<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    cin &gt;&gt; n &gt;&gt; c;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        cin &gt;&gt; a[i];    }    l = <span class="number">1</span>, r = c;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        <span class="type">int</span> p = std::<span class="built_in">min_element</span>(a + l, a + r + <span class="number">1</span>) - a;        cout &lt;&lt; a[p] &lt;&lt; <span class="string">' '</span>;        vis[p] = <span class="literal">true</span>;        a[p] = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();        <span class="keyword">while</span> (p &amp;&amp; vis[p]) p--;        l = std::<span class="built_in">max</span>(p, <span class="number">1</span>);        r = std::<span class="built_in">min</span>(r + <span class="number">1</span>, n);    }    cout &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></details><details open=""><summary>100 分代码</summary><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;<span class="comment">// Limits</span><span class="type">const</span> <span class="type">int</span> N = <span class="number">300005</span>;<span class="comment">// Variables</span><span class="type">int</span> a[N];<span class="type">bool</span> vis[N];<span class="comment">// Segment Tree</span><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);    <span class="type">int</span> n, c;    cin &gt;&gt; n &gt;&gt; c;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        cin &gt;&gt; a[i];    }    a[<span class="number">0</span>] = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);    <span class="type">int</span> pos = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, c);    std::stack&lt;<span class="type">int</span>&gt; st;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pos; i++) {        st.<span class="built_in">push</span>(i);    }    cout &lt;&lt; a[pos] &lt;&lt; <span class="string">' '</span>;    <span class="keyword">for</span> (<span class="type">int</span> i = c + <span class="number">1</span>; i &lt;= n; i++) {        <span class="type">int</span> p = <span class="built_in">query</span>(<span class="number">1</span>, pos + <span class="number">1</span>, i);        <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; a[st.<span class="built_in">top</span>()] &lt;= a[p]) {            cout &lt;&lt; a[st.<span class="built_in">top</span>()] &lt;&lt; <span class="string">' '</span>;            st.<span class="built_in">pop</span>();        } <span class="keyword">else</span> {            <span class="keyword">for</span> (<span class="type">int</span> j = pos + <span class="number">1</span>; j &lt; p; j++) {                st.<span class="built_in">push</span>(j);            }            pos = p;            cout &lt;&lt; a[p] &lt;&lt; <span class="string">' '</span>;        }    }    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; c; i++) {        <span class="type">int</span> p = pos + <span class="number">1</span> &lt;= n ? <span class="built_in">query</span>(<span class="number">1</span>, pos + <span class="number">1</span>, n) : <span class="number">0</span>;        <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; a[st.<span class="built_in">top</span>()] &lt;= a[p]) {            cout &lt;&lt; a[st.<span class="built_in">top</span>()] &lt;&lt; <span class="string">' '</span>;            st.<span class="built_in">pop</span>();        } <span class="keyword">else</span> {            <span class="keyword">for</span> (<span class="type">int</span> j = pos + <span class="number">1</span>; j &lt; p; j++) {                st.<span class="built_in">push</span>(j);            }            pos = p;            cout &lt;&lt; a[p] &lt;&lt; <span class="string">' '</span>;        }    }    cout &lt;&lt; endl;    <span class="keyword">return</span> <span class="number">0</span>;}<span class="comment">// === Segment Tree ===</span><span class="keyword">struct</span> <span class="title class_">node</span> {    <span class="type">int</span> l, r, id;    <span class="built_in">node</span>()        : <span class="built_in">l</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>), <span class="built_in">id</span>(<span class="number">0</span>) {}    <span class="built_in">node</span>(<span class="type">int</span> _l, <span class="type">int</span> _r)        : <span class="built_in">l</span>(_l), <span class="built_in">r</span>(_r), <span class="built_in">id</span>(<span class="number">0</span>) {}} tr[N &lt;&lt; <span class="number">2</span>];<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>{    tr[u].id = a[tr[u &lt;&lt; <span class="number">1</span>].id] &lt;= a[tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].id] ? tr[u &lt;&lt; <span class="number">1</span>].id : tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].id;}<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{    tr[u] = <span class="built_in">node</span>(l, r);    <span class="keyword">if</span> (l == r) {        tr[u].id = l;        <span class="keyword">return</span>;    }    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);    <span class="built_in">pushup</span>(u);}<span class="comment">/**</span><span class="comment"> * 查询区间 [l, r] 最小值，并返回最小值在 a 数组中对应的**下标**</span><span class="comment"> * @param u 根节点坐标</span><span class="comment"> * @param l 区间左端点</span><span class="comment"> * @param r 区间右端点</span><span class="comment"> * @return 最小值在 a 数组中对应的**下标**</span><span class="comment"> */</span><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].id;    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>,        pos = <span class="number">0</span>;    <span class="keyword">if</span> (l &lt;= mid) {        <span class="type">int</span> t = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);        <span class="keyword">if</span> (a[t] &lt; a[pos]) pos = t;    }    <span class="keyword">if</span> (r &gt; mid) {        <span class="type">int</span> t = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);        <span class="keyword">if</span> (a[t] &lt; a[pos]) pos = t;    }    <span class="keyword">return</span> pos;}</code></pre></details></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;本题是 &lt;a href=&quot;https://www.luogu.com.cn/problem/P1750&quot;&gt;洛谷 - P1750 出栈序列&lt;/a&gt; 的加强版。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="模拟" scheme="https://oi.baoshuo.ren/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="线段树" scheme="https://oi.baoshuo.ren/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="S2OJ" scheme="https://oi.baoshuo.ren/tags/S2OJ/"/>
    
    <category term="栈" scheme="https://oi.baoshuo.ren/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>可持久化线段树学习笔记</title>
    <link href="https://oi.baoshuo.ren/notes/ds/persistent-segment-tree/"/>
    <id>https://oi.baoshuo.ren/notes/ds/persistent-segment-tree/</id>
    <published>2021-12-24T21:03:09.000Z</published>
    <updated>2022-03-30T06:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文讲述的是 <strong>可持久化权值线段树</strong> 。这种数据结构在普通线段树的基础之上支持查询某个历史版本，同时时间复杂度与线段树是同级，空间复杂度相较而言更高一些。</p><span id="more"></span><p>下文中将以「可持久化线段树」代指「可持久化权值线段树」。</p><p>注意：可持久化线段树难以进行区间修改操作，因为进行该操作可能会修改历史信息导致查询出错误结果，或者使用标记永久化避免出现这个问题，该项内容不在本文的讨论范围内。</p><h2 id="前置知识">前置知识</h2><ul><li><a href="#">Post not found: segment-tree</a></li></ul><h2 id="原理">原理</h2><p>可持久化线段树维护的是每个节点的历史版本，而最朴素的实现方式是每次进行修改操作都新开一颗线段树，而这样操作带来的时空复杂度是不可接受的。</p><p>稍微推导一下可以发现每次修改操作需要修改的节点个数只有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 个，那么可以使用动态开点并记录历史版本的方式来节约空间和时间的消耗，这就是<strong>可持久化线段树</strong>。</p><h2 id="实现">实现</h2><p>先进行离散化，以节约存储空间，具体实现不再过多描述。</p><p>然后以数值为基础建立权值线段树，维护每个数值区间中一共有多少个数。</p><p><code>node</code> 类型的定义如下：</p><pre><code class="highlight cpp"><span class="keyword">struct</span> <span class="title class_">node</span> {    <span class="type">int</span> l,     <span class="comment">// 左儿子的数组下标</span>        r,     <span class="comment">// 右儿子的数组下标</span>        c;     <span class="comment">// 当前区间中一共有多少个数</span>    <span class="built_in">node</span>();    <span class="comment">// 构造函数</span>};</code></pre><p>这和 <a href="#">Post not found: segment-tree</a> 中的定义有一些差别。首先，<code>l</code> 和 <code>r</code> 的存储的信息从左右端点变成了左右儿子的数组下标；其次，区间维护的信息从节点的和差与最值变成了区间中数据的个数。</p><p>再来看 build 函数。</p><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{    <span class="type">int</span> p = ++cnt;               <span class="comment">// 新建节点</span>    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> p;        <span class="comment">// 返回节点编号</span>    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    tr[p].l = <span class="built_in">build</span>(l, mid);     <span class="comment">// 左子树</span>    tr[p].r = <span class="built_in">build</span>(mid + <span class="number">1</span>, r); <span class="comment">// 右子树</span>    <span class="keyword">return</span> p;                    <span class="comment">// 返回节点编号</span>}</code></pre><p>变化是线段树存储方式从原先的堆变成了动态开点，动态开点线段树可以在网上找到相关学习资料，在此不作过多赘述。</p><p>还有 <code>insert</code> 函数：</p><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>{    <span class="type">int</span> q = ++cnt;  <span class="comment">// 开点</span>    tr[q] = tr[p];  <span class="comment">// 拷贝旧节点</span>    <span class="keyword">if</span> (l == r) {        tr[q].c++;  <span class="comment">// 增加计数</span>        <span class="keyword">return</span> q;    }    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    <span class="keyword">if</span> (x &lt;= mid) {        tr[q].l = <span class="built_in">insert</span>(tr[p].l, l, mid, x);     <span class="comment">// 左子树</span>    } <span class="keyword">else</span> {        tr[q].r = <span class="built_in">insert</span>(tr[p].r, mid + <span class="number">1</span>, r, x); <span class="comment">// 右子树</span>    }    tr[q].c = tr[tr[q].l].c + tr[tr[q].r].c;      <span class="comment">// 更新计数（内联的 pushup 操作）</span>    <span class="keyword">return</span> q;}</code></pre><p>仍然是动态开点，新节点的初始值由 <code>node(l, r)</code> 变成了 <code>tr[p]</code> ，即以第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个版本为基础，再进行修改。</p><p>最后是 <code>query</code> 函数：</p><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> q, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>{    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;                   <span class="comment">// 返回</span>    <span class="type">int</span> c = tr[tr[q].l].c - tr[tr[p].l].c;  <span class="comment">// 前缀和</span>    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    <span class="keyword">if</span> (k &lt;= c) <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].l, tr[p].l, l, mid, k);  <span class="comment">// 查询左子树</span>    <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].r, tr[p].r, mid + <span class="number">1</span>, r, k - c);      <span class="comment">// 查询右子树</span>}</code></pre><p>通过 <code>tr[tr[q].l].c - tr[tr[p].l].c</code> 获得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间内数的个数。</p><blockquote><p>注：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 号节点的数的个数减去第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 号节点的数的个数即为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 中的数的个数，这里使用到了前缀和的思想。</p></blockquote><p>取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mclose">]</span></span></span></span> 区间的数的个数并记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span>，接下来分两种情况：</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">cnt \leq k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小的数在左子树上。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">cnt &gt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小的数在右子树上，查询右子树第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">k - cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span> 小的数。</li></ol><p>递归查询即可。</p><h2 id="代码-56">代码</h2><p>对应题目：<a href="https://www.luogu.com.cn/problem/P3834">洛谷 - P3834 【模板】可持久化线段树 2</a> <small><a href="https://github.com/renbaoshuo/OI-codes/commit/8d7072398401a43a02512d78a725bf9ae5a50719"><code>8d70723</code></a></small></p><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;<span class="type">const</span> <span class="type">int</span> N = <span class="number">200005</span>;<span class="type">int</span> n, m, l, r, k, a[N];std::vector&lt;<span class="type">int</span>&gt; nums;<span class="comment">// Helpers</span><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">// Segment Tree</span><span class="type">int</span> cnt, root[N];<span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    cin &gt;&gt; n &gt;&gt; m;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        cin &gt;&gt; a[i];        nums.<span class="built_in">push_back</span>(a[i]);    }    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());    nums.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>], <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="built_in">find</span>(a[i]));    }    <span class="keyword">while</span> (m--) {        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;        cout &lt;&lt; nums[<span class="built_in">query</span>(root[r], root[l - <span class="number">1</span>], <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, k)] &lt;&lt; endl;    }    <span class="keyword">return</span> <span class="number">0</span>;}<span class="comment">// === Helpers ===</span><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>{    <span class="keyword">return</span> std::<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), x) - nums.<span class="built_in">begin</span>();}<span class="comment">// === Segment Tree ===</span><span class="keyword">struct</span> <span class="title class_">node</span> {    <span class="type">int</span> l, r, c;    <span class="built_in">node</span>()        : <span class="built_in">l</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>), <span class="built_in">c</span>(<span class="number">0</span>) {}} tr[N &lt;&lt; <span class="number">5</span>];<span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{    <span class="type">int</span> p = ++cnt;    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> p;    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    tr[p].l = <span class="built_in">build</span>(l, mid);    tr[p].r = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);    <span class="keyword">return</span> p;}<span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>{    <span class="type">int</span> q = ++cnt;    tr[q] = tr[p];    <span class="keyword">if</span> (l == r) {        tr[q].c++;        <span class="keyword">return</span> q;    }    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    <span class="keyword">if</span> (x &lt;= mid) {        tr[q].l = <span class="built_in">insert</span>(tr[p].l, l, mid, x);    } <span class="keyword">else</span> {        tr[q].r = <span class="built_in">insert</span>(tr[p].r, mid + <span class="number">1</span>, r, x);    }    tr[q].c = tr[tr[q].l].c + tr[tr[q].r].c;    <span class="keyword">return</span> q;}<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> q, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>{    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;    <span class="type">int</span> c = tr[tr[q].l].c - tr[tr[p].l].c;    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    <span class="keyword">if</span> (k &lt;= c) <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].l, tr[p].l, l, mid, k);    <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].r, tr[p].r, mid + <span class="number">1</span>, r, k - c);}</code></pre><h2 id="参考资料-7">参考资料</h2><ol><li>第 255 ~ 258 页，0x48 可持久化数据结构，《算法竞赛进阶指南》（ISBN 978-7-893-88198-5，河南电子音像出版社），李煜东，2019 年 5 月第 5 次修订版。</li><li><a href="https://oi-wiki.org/ds/persistent-seg/">可持久化线段树</a>，OI Wiki，2021 年 12 月 11 日。</li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91">可持久化线段树</a>，维基百科，2021 年 10 月 29 日。</li><li>4.4 可持久化数据结构，AcWing 算法提高课，闫学灿，2019 年 12 月 28 日。</li></ol></body></html>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述的是 &lt;strong&gt;可持久化权值线段树&lt;/strong&gt; 。这种数据结构在普通线段树的基础之上支持查询某个历史版本，同时时间复杂度与线段树是同级，空间复杂度相较而言更高一些。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://oi.baoshuo.ren/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="https://oi.baoshuo.ren/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="https://oi.baoshuo.ren/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="可持久化线段树" scheme="https://oi.baoshuo.ren/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LibreOJ - 2130. 「NOI2015」软件包管理器</title>
    <link href="https://oi.baoshuo.ren/solutions/libreoj-2130/"/>
    <id>https://oi.baoshuo.ren/solutions/libreoj-2130/</id>
    <published>2021-12-05T00:15:28.000Z</published>
    <updated>2021-12-05T00:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本题有多个提交渠道：</p><ul><li><a href="https://loj.ac/p/2130">LibreOJ 2130</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/93dab817137383bcc126472dc9e29f2c9dcc14c6"><code>93dab817</code></a>)</small></li><li><a href="https://www.luogu.com.cn/problem/P2146">洛谷 P2146</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/f796c455380a68ccb3cd65ca88e17d6890e27fae"><code>f796c45</code></a>)</small></li><li><a href="https://www.acwing.com/problem/content/920/">AcWing 918</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/023cd53070ab7ebf31a74b6b4a26bb5af7fd04b0"><code>023cd53</code></a>)</small></li></ul><hr><h2 id="题面-7">题面</h2><h3 id="题目背景-2">题目背景</h3><p>Linux 用户和 OSX 用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu 使用的 apt-get，Fedora/CentOS 使用的 yum，以及 OSX 下可用的 homebrew 都是优秀的软件包管理器。</p><h3 id="题目描述-7">题目描述</h3><p>你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 依赖软件包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>，那么安装软件包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 以前，必须先安装软件包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>。同时，如果想要卸载软件包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>，则必须卸载软件包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>。</p><p>现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 号软件包不依赖任何一个软件包。且依赖关系不存在环（即不会存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个软件包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2, \dots , a_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">i&lt;m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">a_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的情况）。</p><p>现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。</p><p>注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><h3 id="输入格式-7">输入格式</h3><p>第一行一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，表示软件包个数，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 开始编号。<br>第二行有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个整数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 号软件包依赖的软件包编号。<br>然后一行一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，表示操作个数，格式如下：</p><ul><li><code>install x</code> 表示安装 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 号软件包</li><li><code>uninstall x</code> 表示卸载 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 号软件包</li></ul><p>一开始所有软件包都是未安装的。</p><p>对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。</p><h3 id="输出格式-7">输出格式</h3><p>输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行一个整数，表示每次询问的答案。</p><h3 id="输入输出样例-4">输入输出样例</h3><p><strong>样例输入 #1</strong></p><pre><code class="highlight text">70 0 0 1 1 55install 5install 6uninstall 1install 4uninstall 0</code></pre><p><strong>样例输出 #1</strong></p><pre><code class="highlight text">31323</code></pre><p><strong>样例解释 #1</strong></p><p><img src="https://s1.baoshuo.ren/2021/12/04/h6lfdbUoAcWs4Ea.png" alt="" loading="lazy"></p><p>一开始所有软件包都处于未安装状态。</p><p>安装 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 号软件包，需要安装 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">0,1,5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span></span></span></span> 三个软件包。</p><p>之后安装 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 号软件包，只需要安装 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 号软件包。此时安装了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">0,1,5,6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span></span></span></span> 四个软件包。</p><p>卸载 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 号软件包需要卸载 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">1,5,6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span></span></span></span> 三个软件包。此时只有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 号软件包还处于安装状态。</p><p>之后安装 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 号软件包，需要安装 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">1,4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span></span></span></span> 两个软件包。此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">0,1,4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span></span></span></span> 处在安装状态。最后，卸载 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 号软件包会卸载所有的软件包。</p><p><strong>样例输入 #2</strong></p><pre><code class="highlight text">100 1 2 1 3 0 0 3 210install 0install 3uninstall 2install 7install 5install 9uninstall 9install 4install 1install 9</code></pre><p><strong>样例输出 #2</strong></p><pre><code class="highlight text">1321311101</code></pre><h3 id="数据范围与约定-4">数据范围与约定</h3><p><img src="https://s1.baoshuo.ren/2021/12/04/WTQsbRjJt59Ca6u.png" alt="" loading="lazy"></p><h2 id="思路-7">思路</h2><p>一道树链剖分模板题。</p><p>通过分析可得：每次执行安装操作时，把根节点到软件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 路径上的值设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ；每次执行卸载操作时，把以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 为根节点的子树上的所有值设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 。</p><p>然后题目就转化为了区间和问题，操作前记录下线段树整体的和，操作后再记录一次，两者相减取绝对值即为安装状态被改变了的软件包的数量。</p><hr><p>几点注意事项：</p><ol><li>线段树区间覆盖的实现：在修改时将 <code>+=</code> 改为 <code>=</code> 即可。</li><li>懒标记初值不要用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ，因为修改的时候会有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 。</li><li>推荐从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 开始编号，方便维护，避免因编号起始值不同带来的麻烦。</li></ol><h2 id="代码-7">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;<span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;<span class="type">int</span> n, q, a, x;std::string op;std::vector&lt;<span class="type">int</span>&gt; g[N];<span class="comment">// Heavy Path Decomposition</span><span class="type">int</span> cnt, id[N], fa[N], dep[N], son[N], siz[N], top[N];<span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">void</span> <span class="title">modify_path</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">void</span> <span class="title">modify_tree</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="comment">// Segment Tree</span><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    cin &gt;&gt; n;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {        cin &gt;&gt; x;        x++;        g[x].<span class="built_in">push_back</span>(i);        g[i].<span class="built_in">push_back</span>(x);    }    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">1</span>);    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);    cin &gt;&gt; q;    <span class="keyword">while</span> (q--) {        cin &gt;&gt; op &gt;&gt; x;        x++;        <span class="type">int</span> before = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n);        <span class="keyword">if</span> (op == <span class="string">"install"</span>) {            <span class="keyword">if</span> (!<span class="built_in">query</span>(<span class="number">1</span>, id[x], id[x])) {                <span class="built_in">modify_path</span>(<span class="number">1</span>, x, <span class="number">1</span>);            }        } <span class="keyword">else</span> {            <span class="keyword">if</span> (<span class="built_in">query</span>(<span class="number">1</span>, id[x], id[x])) {                <span class="built_in">modify_tree</span>(x, <span class="number">0</span>);            }        }        <span class="type">int</span> after = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n);        cout &lt;&lt; std::<span class="built_in">abs</span>(before - after) &lt;&lt; endl;    }    <span class="keyword">return</span> <span class="number">0</span>;}<span class="comment">// === Heavy Path Decomposition ===</span><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span> </span>{    dep[u] = dep[f] + <span class="number">1</span>;    fa[u] = f;    siz[u] = <span class="number">1</span>;    <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) {        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;        <span class="built_in">dfs1</span>(v, u);        siz[u] += siz[v];        <span class="keyword">if</span> (siz[son[u]] &lt; siz[v]) son[u] = v;    }}<span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span> </span>{    id[u] = ++cnt;    top[u] = t;    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span>;    <span class="built_in">dfs2</span>(son[u], t);    <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) {        <span class="keyword">if</span> (v == fa[u]) <span class="keyword">continue</span>;        <span class="keyword">if</span> (v == son[u]) <span class="keyword">continue</span>;        <span class="built_in">dfs2</span>(v, v);    }}<span class="function"><span class="type">void</span> <span class="title">modify_path</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> d)</span> </span>{    <span class="keyword">while</span> (top[u] != top[v]) {        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) std::<span class="built_in">swap</span>(u, v);        <span class="built_in">modify</span>(<span class="number">1</span>, id[top[u]], id[u], d);        u = fa[top[u]];    }    <span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);    <span class="built_in">modify</span>(<span class="number">1</span>, id[v], id[u], d);}<span class="function"><span class="type">void</span> <span class="title">modify_tree</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> d)</span> </span>{    <span class="built_in">modify</span>(<span class="number">1</span>, id[u], id[u] + siz[u] - <span class="number">1</span>, d);}<span class="comment">// === Segment Tree ===</span><span class="keyword">struct</span> <span class="title class_">node</span> {    <span class="type">int</span> l, r, s, d;    <span class="built_in">node</span>()        : <span class="built_in">l</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>), <span class="built_in">s</span>(<span class="number">0</span>), <span class="built_in">d</span>(<span class="number">-1</span>) {}    <span class="built_in">node</span>(<span class="type">int</span> _l, <span class="type">int</span> _r)        : <span class="built_in">l</span>(_l), <span class="built_in">r</span>(_r), <span class="built_in">s</span>(<span class="number">0</span>), <span class="built_in">d</span>(<span class="number">-1</span>) {}} tr[N &lt;&lt; <span class="number">2</span>];<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>{    tr[u].s = tr[u &lt;&lt; <span class="number">1</span>].s + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].s;}<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span> </span>{    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];    <span class="keyword">if</span> (root.d == <span class="number">-1</span>) <span class="keyword">return</span>;    left.s = (left.r - left.l + <span class="number">1</span>) * root.d;    left.d = root.d;    right.s = (right.r - right.l + <span class="number">1</span>) * root.d;    right.d = root.d;    root.d = <span class="number">-1</span>;}<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{    tr[u] = <span class="built_in">node</span>(l, r);    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);}<span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span> </span>{    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) {        tr[u].s = (tr[u].r - tr[u].l + <span class="number">1</span>) * d;        tr[u].d = d;        <span class="keyword">return</span>;    }    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;    <span class="built_in">pushdown</span>(u);    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);    <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);    <span class="built_in">pushup</span>(u);}<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].s;    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;    <span class="type">int</span> sum = <span class="number">0</span>;    <span class="built_in">pushdown</span>(u);    <span class="keyword">if</span> (l &lt;= mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);    <span class="keyword">return</span> sum;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本题有多个提交渠道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://loj.ac/p/2130&quot;&gt;LibreOJ 2130&lt;/a&gt; &lt;small&gt;(&lt;a href=&quot;https://github.com/ren</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="LibreOJ" scheme="https://oi.baoshuo.ren/tags/LibreOJ/"/>
    
    <category term="洛谷" scheme="https://oi.baoshuo.ren/tags/%E6%B4%9B%E8%B0%B7/"/>
    
    <category term="AcWing" scheme="https://oi.baoshuo.ren/tags/AcWing/"/>
    
    <category term="树链剖分" scheme="https://oi.baoshuo.ren/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
    <category term="线段树" scheme="https://oi.baoshuo.ren/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LibreOJ - 2633. 「BalticOI 2011 Day1」宝藏与维京海盗 Treasures and Vikings</title>
    <link href="https://oi.baoshuo.ren/solutions/libreoj-2633/"/>
    <id>https://oi.baoshuo.ren/solutions/libreoj-2633/</id>
    <published>2021-11-19T18:42:14.000Z</published>
    <updated>2021-11-19T18:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本题有多个提交渠道：</p><ul><li><a href="https://www.luogu.com.cn/problem/P4668">洛谷 P4668</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/7bd830a8435923b4b610cd9ac4aa373643d26db7"><code>7bd830a</code></a>)</small></li><li><a href="https://loj.ac/p/2633">LibreOJ #2633</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/8506be4984293f598c2063712ecbe84d75460d1b"><code>8506be4</code></a>)</small></li><li><a href="https://sjzezoj.com/problem/1159">S2OJ #1159</a> <small>(<a href="https://github.com/renbaoshuo/OI-codes/commit/0c07ca3cd68ad8ec1a9688bf1b95b98a11a45915"><code>0c07ca3</code></a>)</small></li></ul><hr><h2 id="题面-8">题面</h2><p><strong>本题译自 BalticOI 2011 Day1 T4「Treasures and Vikings」。</strong></p><h3 id="题目描述-8">题目描述</h3><p>你有一张藏宝图，藏宝图可视为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N \times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 的网格。每个格子可能是你的船、贼船、海、陆地或藏宝点。你只有一条船，整张图只有一条贼船。你和贼船都只能在海域移动。藏宝点在海中。</p><p>你与贼船交替移动，你移动一次 + 贼船移动一次算作一回合。每次移动，你可以移动到上下左右四个相邻格子中的一格，也可以不移动。贼船的移动同理，贼船也可以不移动。你先移动。</p><p>每一回合结束后，如果你和贼船在同一行或同一列，你就挂了；在你没挂的情况下，如果你位于藏宝点，你就拿到了宝藏。<br>请问：是否有一条安全的路径，使得无论贼船怎么跑你都能或者拿到宝藏。</p><h3 id="输入格式-8">输入格式</h3><p>第一行有两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>。</p><p>在接下来的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行中，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个字符。字符的含义如下：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center"><code>.</code></th><th style="text-align:center"><code>I</code></th><th style="text-align:center"><code>V</code></th><th style="text-align:center"><code>Y</code></th><th style="text-align:center"><code>T</code></th></tr></thead><tbody><tr><td style="text-align:center">含义</td><td style="text-align:center">海</td><td style="text-align:center">陆地</td><td style="text-align:center">贼船</td><td style="text-align:center">你</td><td style="text-align:center">藏宝点</td></tr></tbody></table><p>保证只会出现表中的五种字符，保证 <code>V</code>, <code>Y</code>, <code>T</code> 都只出现一次。</p><h3 id="输出格式-8">输出格式</h3><p>输出 <code>YES</code> 或 <code>NO</code>，表示是否有一条安全的路径。</p><h3 id="输入输出样例-5">输入输出样例</h3><p><strong>样例输入 #1</strong></p><pre><code class="highlight text">5 7Y.....V..I......IIIII..........T...</code></pre><p><strong>样例输出 #1</strong></p><pre><code class="highlight text">YES</code></pre><p><strong>样例输入 #2</strong></p><pre><code class="highlight text">5 7Y....V...I......IIIII..........T...</code></pre><p><strong>样例输出 #2</strong></p><pre><code class="highlight text">NO</code></pre><p><strong>样例输入 #3</strong></p><pre><code class="highlight text">2 3.YTVII</code></pre><p><strong>样例输出 #3</strong></p><pre><code class="highlight text">NO</code></pre><h3 id="数据范围与约定-5">数据范围与约定</h3><ul><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">50\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">50%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">1 \leq N, M \leq 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">200</span></span></span></span> 。</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">100%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo>≤</mo><mn>700</mn></mrow><annotation encoding="application/x-tex">1 \leq N, M \leq 700</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">700</span></span></span></span> 。</li></ul><h2 id="思路-8">思路</h2><p>先使用广搜预处理一下贼船到达每个非陆地点的最小时间并存储下来，然后再使用广搜搜一下是否能到 <code>T</code> 点即可。</p><p>在第二遍广搜的时候需要注意，如果到达某个点的用时比贼船到达的用时长，那么这条路就是走不通的，不能扩展。</p><p>其余信息可以看代码注释.</p><h2 id="代码-8">代码</h2><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="type">const</span> <span class="type">int</span> to[<span class="number">4</span>][<span class="number">2</span>] = {{<span class="number">0</span>, <span class="number">1</span>}, {<span class="number">0</span>, <span class="number">-1</span>}, {<span class="number">1</span>, <span class="number">0</span>}, {<span class="number">-1</span>, <span class="number">0</span>}};<span class="type">int</span> n, m, book[<span class="number">705</span>][<span class="number">705</span>];<span class="type">bool</span> vis[<span class="number">705</span>][<span class="number">705</span>];<span class="type">char</span> g[<span class="number">705</span>][<span class="number">705</span>];pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; y, v, t;<span class="keyword">struct</span> <span class="title class_">node</span> {    <span class="type">int</span> x, y, step;    <span class="built_in">node</span>()        : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">step</span>(<span class="number">0</span>) {}    <span class="built_in">node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y)        : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y), <span class="built_in">step</span>(<span class="number">0</span>) {}    <span class="built_in">node</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; _point)        : <span class="built_in">x</span>(_point.first), <span class="built_in">y</span>(_point.second), <span class="built_in">step</span>(<span class="number">0</span>) {}    <span class="built_in">node</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; _point, <span class="type">int</span> _step)        : <span class="built_in">x</span>(_point.first), <span class="built_in">y</span>(_point.second), <span class="built_in">step</span>(_step) {}    <span class="built_in">node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y, <span class="type">int</span> _step)        : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y), <span class="built_in">step</span>(_step) {}};<span class="comment">/**</span><span class="comment"> * @brief Preprocess the map</span><span class="comment"> */</span><span class="function"><span class="type">void</span> <span class="title">bfsV</span><span class="params">()</span> </span>{    <span class="built_in">memset</span>(vis, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(vis));    <span class="built_in">memset</span>(book, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(book));    queue&lt;node&gt; q;    q.<span class="built_in">push</span>(v);    vis[v.first][v.second] = <span class="literal">true</span>;    book[v.first][v.second] = <span class="number">0</span>;    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {        <span class="type">int</span> now;        <span class="keyword">auto</span> u = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        <span class="comment">// Top</span>        now = u.x - <span class="number">1</span>;        <span class="keyword">while</span> (now &gt;= <span class="number">0</span> &amp;&amp; g[now][u.y] != <span class="string">'I'</span>) {            <span class="keyword">if</span> (book[now][u.y] == <span class="number">-1</span>) {                book[now][u.y] = u.step;            }            now--;        }        <span class="comment">// Bottom</span>        now = u.x + <span class="number">1</span>;        <span class="keyword">while</span> (now &lt; n &amp;&amp; g[now][u.y] != <span class="string">'I'</span>) {            <span class="keyword">if</span> (book[now][u.y] == <span class="number">-1</span>) {                book[now][u.y] = u.step;            }            now++;        }        <span class="comment">// Left</span>        now = u.y - <span class="number">1</span>;        <span class="keyword">while</span> (now &gt;= <span class="number">0</span> &amp;&amp; g[u.x][now] != <span class="string">'I'</span>) {            <span class="keyword">if</span> (book[u.x][now] == <span class="number">-1</span>) {                book[u.x][now] = u.step;            }            --now;        }        <span class="comment">// Right</span>        now = u.y + <span class="number">1</span>;        <span class="keyword">while</span> (now &lt; m &amp;&amp; g[u.x][now] != <span class="string">'I'</span>) {            <span class="keyword">if</span> (book[u.x][now] == <span class="number">-1</span>) {                book[u.x][now] = u.step;            }            now++;        }        <span class="comment">// Expand</span>        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {            node e = <span class="built_in">node</span>(u.x + to[i][<span class="number">0</span>], u.y + to[i][<span class="number">1</span>], u.step + <span class="number">1</span>);            <span class="keyword">if</span> (e.x &gt;= <span class="number">0</span> &amp;&amp; e.x &lt; n &amp;&amp; e.y &gt;= <span class="number">0</span> &amp;&amp; e.y &lt; m &amp;&amp; g[e.x][e.y] != <span class="string">'I'</span> &amp;&amp; !vis[e.x][e.y]) {                vis[e.x][e.y] = <span class="literal">true</span>;                q.<span class="built_in">push</span>(e);            }        }    }}<span class="comment">/**</span><span class="comment"> * @brief Search path to treasure</span><span class="comment"> */</span><span class="function"><span class="type">void</span> <span class="title">bfsY</span><span class="params">()</span> </span>{    <span class="built_in">memset</span>(vis, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(vis));    queue&lt;node&gt; q;    q.<span class="built_in">push</span>(<span class="built_in">node</span>(y, <span class="number">1</span>));    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {        <span class="keyword">auto</span> u = q.<span class="built_in">front</span>();        q.<span class="built_in">pop</span>();        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {            node e = <span class="built_in">node</span>(u.x + to[i][<span class="number">0</span>], u.y + to[i][<span class="number">1</span>], u.step + <span class="number">1</span>);            <span class="keyword">if</span> (e.x &gt;= <span class="number">0</span> &amp;&amp; e.x &lt; n &amp;&amp; e.y &gt;= <span class="number">0</span> &amp;&amp; e.y &lt; m &amp;&amp; e.step &lt;= book[e.x][e.y] &amp;&amp; !vis[e.x][e.y]) {                vis[e.x][e.y] = <span class="literal">true</span>;                <span class="comment">// Reached</span>                <span class="keyword">if</span> (e.x == t.first &amp;&amp; e.y == t.second) {                    cout &lt;&lt; <span class="string">"YES"</span> &lt;&lt; endl;                    <span class="keyword">return</span>;                }                <span class="comment">// Expand</span>                q.<span class="built_in">push</span>(e);            }        }    }    <span class="comment">// Can't reach treasure</span>    cout &lt;&lt; <span class="string">"NO"</span> &lt;&lt; endl;}<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{    <span class="comment">// Read from stdin</span>    cin &gt;&gt; n &gt;&gt; m;    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {        cin &gt;&gt; g[i];    }    <span class="comment">// Mark you, viking and treasure</span>    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) {            <span class="keyword">if</span> (g[i][j] == <span class="string">'Y'</span>) y = <span class="built_in">make_pair</span>(i, j);            <span class="keyword">if</span> (g[i][j] == <span class="string">'V'</span>) v = <span class="built_in">make_pair</span>(i, j);            <span class="keyword">if</span> (g[i][j] == <span class="string">'T'</span>) t = <span class="built_in">make_pair</span>(i, j);        }    }    <span class="built_in">bfsV</span>();    <span class="built_in">bfsY</span>();    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;本题有多个提交渠道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4668&quot;&gt;洛谷 P4668&lt;/a&gt; &lt;small&gt;(&lt;a href=&quot;https://g</summary>
      
    
    
    
    <category term="题解" scheme="https://oi.baoshuo.ren/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="搜索" scheme="https://oi.baoshuo.ren/tags/%E6%90%9C%E7%B4%A2/"/>
    
    <category term="LibreOJ" scheme="https://oi.baoshuo.ren/tags/LibreOJ/"/>
    
    <category term="洛谷" scheme="https://oi.baoshuo.ren/tags/%E6%B4%9B%E8%B0%B7/"/>
    
    <category term="S2OJ" scheme="https://oi.baoshuo.ren/tags/S2OJ/"/>
    
  </entry>
  
</feed>
