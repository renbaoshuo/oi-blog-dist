this.workbox=this.workbox||{},this.workbox.backgroundSync=function(e,t,s,a,r,n){"use strict";try{self["workbox:background-sync:5.1.4"]&&_()}catch(e){}const u="requests",o="queueName";class i{constructor(e){this._queueName=e,this._db=new n.DBWrapper("workbox-background-sync",3,{onupgradeneeded:this._upgradeDb})}async pushEntry(e){a.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"pushEntry",paramName:"entry"}),a.assert.isType(e.requestData,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"pushEntry",paramName:"entry.requestData"}),delete e.id,e.queueName=this._queueName,await this._db.add(u,e)}async unshiftEntry(e){a.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"unshiftEntry",paramName:"entry"}),a.assert.isType(e.requestData,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"unshiftEntry",paramName:"entry.requestData"});const[t]=await this._db.getAllMatching(u,{count:1});t?e.id=t.id-1:delete e.id,e.queueName=this._queueName,await this._db.add(u,e)}async popEntry(){return this._removeEntry({direction:"prev"})}async shiftEntry(){return this._removeEntry({direction:"next"})}async getAll(){return await this._db.getAllMatching(u,{index:o,query:IDBKeyRange.only(this._queueName)})}async deleteEntry(e){await this._db.delete(u,e)}async _removeEntry({direction:e}){const[t]=await this._db.getAllMatching(u,{direction:e,index:o,query:IDBKeyRange.only(this._queueName),count:1});if(t)return await this.deleteEntry(t.id),t}_upgradeDb(e){const t=e.target.result;e.oldVersion>0&&e.oldVersion<3&&t.objectStoreNames.contains(u)&&t.deleteObjectStore(u);t.createObjectStore(u,{autoIncrement:!0,keyPath:"id"}).createIndex(o,o,{unique:!1})}}const c=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"];class d{constructor(e){a.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"StorableRequest",funcName:"constructor",paramName:"requestData"}),a.assert.isType(e.url,"string",{moduleName:"workbox-background-sync",className:"StorableRequest",funcName:"constructor",paramName:"requestData.url"}),"navigate"===e.mode&&(e.mode="same-origin"),this._requestData=e}static async fromRequest(e){const t={url:e.url,headers:{}};"GET"!==e.method&&(t.body=await e.clone().arrayBuffer());for(const[s,a]of e.headers.entries())t.headers[s]=a;for(const s of c)void 0!==e[s]&&(t[s]=e[s]);return new d(t)}toObject(){const e=Object.assign({},this._requestData);return e.headers=Object.assign({},this._requestData.headers),e.body&&(e.body=e.body.slice(0)),e}toRequest(){return new Request(this._requestData.url,this._requestData)}clone(){return new d(this.toObject())}}const m="workbox-background-sync",y=new Set,h=e=>{const t={request:new d(e.requestData).toRequest(),timestamp:e.timestamp};return e.metadata&&(t.metadata=e.metadata),t};class l{constructor(e,{onSync:s,maxRetentionTime:a}={}){if(this._syncInProgress=!1,this._requestsAddedDuringSync=!1,y.has(e))throw new t.WorkboxError("duplicate-queue-name",{name:e});y.add(e),this._name=e,this._onSync=s||this.replayRequests,this._maxRetentionTime=a||10080,this._queueStore=new i(this._name),this._addSyncListener()}get name(){return this._name}async pushRequest(e){a.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"Queue",funcName:"pushRequest",paramName:"entry"}),a.assert.isInstance(e.request,Request,{moduleName:"workbox-background-sync",className:"Queue",funcName:"pushRequest",paramName:"entry.request"}),await this._addRequest(e,"push")}async unshiftRequest(e){a.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"Queue",funcName:"unshiftRequest",paramName:"entry"}),a.assert.isInstance(e.request,Request,{moduleName:"workbox-background-sync",className:"Queue",funcName:"unshiftRequest",paramName:"entry.request"}),await this._addRequest(e,"unshift")}async popRequest(){return this._removeRequest("pop")}async shiftRequest(){return this._removeRequest("shift")}async getAll(){const e=await this._queueStore.getAll(),t=Date.now(),s=[];for(const a of e){const e=60*this._maxRetentionTime*1e3;t-a.timestamp>e?await this._queueStore.deleteEntry(a.id):s.push(h(a))}return s}async _addRequest({request:e,metadata:t,timestamp:a=Date.now()},n){const u={requestData:(await d.fromRequest(e.clone())).toObject(),timestamp:a};t&&(u.metadata=t),await this._queueStore[`${n}Entry`](u),s.logger.log(`Request for '${r.getFriendlyURL(e.url)}' has been added to background sync queue '${this._name}'.`),this._syncInProgress?this._requestsAddedDuringSync=!0:await this.registerSync()}async _removeRequest(e){const t=Date.now(),s=await this._queueStore[`${e}Entry`]();if(s){const a=60*this._maxRetentionTime*1e3;return t-s.timestamp>a?this._removeRequest(e):h(s)}}async replayRequests(){let e;for(;e=await this.shiftRequest();)try{await fetch(e.request.clone()),s.logger.log(`Request for '${r.getFriendlyURL(e.request.url)}'has been replayed in queue '${this._name}'`)}catch(a){throw await this.unshiftRequest(e),s.logger.log(`Request for '${r.getFriendlyURL(e.request.url)}'failed to replay, putting it back in queue '${this._name}'`),new t.WorkboxError("queue-replay-failed",{name:this._name})}s.logger.log(`All requests in queue '${this.name}' have successfully replayed; the queue is now empty!`)}async registerSync(){if("sync"in self.registration)try{await self.registration.sync.register(`${m}:${this._name}`)}catch(e){s.logger.warn(`Unable to register sync event for '${this._name}'.`,e)}}_addSyncListener(){"sync"in self.registration?self.addEventListener("sync",(e=>{if(e.tag===`${m}:${this._name}`){s.logger.log(`Background sync for tag '${e.tag}'has been received`);const t=async()=>{let t;this._syncInProgress=!0;try{await this._onSync({queue:this})}catch(e){throw t=e,t}finally{!this._requestsAddedDuringSync||t&&!e.lastChance||await this.registerSync(),this._syncInProgress=!1,this._requestsAddedDuringSync=!1}};e.waitUntil(t())}})):(s.logger.log("Background sync replaying without background sync event"),this._onSync({queue:this}))}static get _queueNames(){return y}}return e.BackgroundSyncPlugin=class{constructor(e,t){this.fetchDidFail=async({request:e})=>{await this._queue.pushRequest({request:e})},this._queue=new l(e,t)}},e.Queue=l,e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);