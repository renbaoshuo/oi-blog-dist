this.workbox=this.workbox||{},this.workbox.streams=function(e,r,o,n,t){"use strict";try{self["workbox:streams:5.1.4"]&&_()}catch(e){}function s(e){o.assert.isArray(e,{moduleName:"workbox-streams",funcName:"concatenate",paramName:"sourcePromises"});const t=e.map((e=>Promise.resolve(e).then((e=>function(e){return e instanceof Response?e.body.getReader():e instanceof ReadableStream?e.getReader():new Response(e).body.getReader()}(e))))),s=new n.Deferred;let a=0;const c=[],l=new ReadableStream({pull(o){return t[a].then((e=>e.read())).then((n=>{if(n.done){if(c.push(["Reached the end of source:",e[a]]),a++,a>=t.length){r.logger.groupCollapsed(`Concatenating ${t.length} sources.`);for(const e of c)Array.isArray(e)?r.logger.log(...e):r.logger.log(e);return r.logger.log("Finished reading all sources."),r.logger.groupEnd(),o.close(),void s.resolve()}return this.pull(o)}o.enqueue(n.value)})).catch((e=>{throw r.logger.error("An error occurred:",e),s.reject(e),e}))},cancel(){r.logger.warn("The ReadableStream was cancelled."),s.resolve()}});return{done:s.promise,stream:l}}function a(e={}){const r=new Headers(e);return r.has("content-type")||r.set("content-type","text/html"),r}function c(e,r){const{done:o,stream:n}=s(e),t=a(r);return{done:o,response:new Response(n,{headers:t})}}function l(){return t.canConstructReadableStream()}return e.concatenate=s,e.concatenateToResponse=c,e.isSupported=l,e.strategy=function(e,o){return async({event:n,request:t,url:s,params:u})=>{const i=e.map((e=>Promise.resolve(e({event:n,request:t,url:s,params:u}))));if(l()){const{done:e,response:r}=c(i,o);return n&&n.waitUntil(e),r}r.logger.log("The current browser doesn't support creating response streams. Falling back to non-streaming response instead.");const p=i.map((async e=>{const r=await e;return r instanceof Response?r.blob():new Response(r).blob()})),g=await Promise.all(p),d=a(o);return new Response(new Blob(g),{headers:d})}},e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);