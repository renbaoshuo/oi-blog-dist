this.workbox=this.workbox||{},this.workbox.expiration=function(e,t,s,i,a,r,n){"use strict";try{self["workbox:expiration:5.1.4"]&&_()}catch(e){}const c=e=>{const t=new URL(e,location.href);return t.hash="",t.href};class o{constructor(e){this.t=e,this.s=new i.DBWrapper("workbox-expiration",1,{onupgradeneeded:e=>this.i(e)})}i(e){const t=e.target.result.createObjectStore("cache-entries",{keyPath:"id"});t.createIndex("cacheName","cacheName",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1}),a.deleteDatabase(this.t)}async setTimestamp(e,t){const s={url:e=c(e),timestamp:t,cacheName:this.t,id:this.h(e)};await this.s.put("cache-entries",s)}async getTimestamp(e){return(await this.s.get("cache-entries",this.h(e))).timestamp}async expireEntries(e,t){const s=await this.s.transaction("cache-entries","readwrite",((s,i)=>{const a=s.objectStore("cache-entries").index("timestamp").openCursor(null,"prev"),r=[];let n=0;a.onsuccess=()=>{const s=a.result;if(s){const i=s.value;i.cacheName===this.t&&(e&&i.timestamp<e||t&&n>=t?r.push(s.value):n++),s.continue()}else i(r)}})),i=[];for(const e of s)await this.s.delete("cache-entries",e.id),i.push(e.url);return i}h(e){return this.t+"|"+c(e)}}class h{constructor(e,t={}){this.o=!1,this.u=!1,this.l=t.maxEntries,this.m=t.maxAgeSeconds,this.t=e,this.p=new o(e)}async expireEntries(){if(this.o)return void(this.u=!0);this.o=!0;const e=this.m?Date.now()-1e3*this.m:0,s=await this.p.expireEntries(e,this.l),i=await self.caches.open(this.t);for(const e of s)await i.delete(e);this.o=!1,this.u&&(this.u=!1,t.dontWaitFor(this.expireEntries()))}async updateTimestamp(e){await this.p.setTimestamp(e,Date.now())}async isURLExpired(e){return!!this.m&&await this.p.getTimestamp(e)<Date.now()-1e3*this.m}async delete(){this.u=!1,await this.p.expireEntries(1/0)}}return e.CacheExpiration=h,e.ExpirationPlugin=class{constructor(e={}){this.cachedResponseWillBeUsed=async({event:e,request:s,cacheName:i,cachedResponse:a})=>{if(!a)return null;const r=this.k(a),n=this.D(i);t.dontWaitFor(n.expireEntries());const c=n.updateTimestamp(s.url);if(e)try{e.waitUntil(c)}catch(e){}return r?a:null},this.cacheDidUpdate=async({cacheName:e,request:t})=>{const s=this.D(e);await s.updateTimestamp(t.url),await s.expireEntries()},this.N=e,this.m=e.maxAgeSeconds,this.g=new Map,e.purgeOnQuotaError&&n.registerQuotaErrorCallback((()=>this.deleteCacheAndMetadata()))}D(e){if(e===r.cacheNames.getRuntimeName())throw new s.WorkboxError("expire-custom-caches-only");let t=this.g.get(e);return t||(t=new h(e,this.N),this.g.set(e,t)),t}k(e){if(!this.m)return!0;const t=this._(e);return null===t||t>=Date.now()-1e3*this.m}_(e){if(!e.headers.has("date"))return null;const t=e.headers.get("date"),s=new Date(t).getTime();return isNaN(s)?null:s}async deleteCacheAndMetadata(){for(const[e,t]of this.g)await self.caches.delete(e),await t.delete();this.g=new Map}},e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);