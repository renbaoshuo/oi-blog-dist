this.workbox=this.workbox||{},this.workbox.routing=function(e,t,r,o,a){"use strict";try{self["workbox:routing:5.1.4"]&&_()}catch(e){}const s=["DELETE","GET","HEAD","PATCH","POST","PUT"],n=e=>e&&"object"==typeof e?(t.assert.hasMethod(e,"handle",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),e):(t.assert.isType(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),{handle:e});class i{constructor(e,r,o="GET"){t.assert.isType(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"match"}),o&&t.assert.isOneOf(o,s,{paramName:"method"}),this.handler=n(r),this.match=e,this.method=o}}class u extends i{constructor(e,o,a){t.assert.isInstance(e,RegExp,{moduleName:"workbox-routing",className:"RegExpRoute",funcName:"constructor",paramName:"pattern"});super((({url:t})=>{const o=e.exec(t.href);if(o){if(t.origin===location.origin||0===o.index)return o.slice(1);r.logger.debug(`The regular expression '${e}' only partially matched against the cross-origin URL '${t}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`)}}),o,a)}}class l{constructor(){this._routes=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",(e=>{const{request:t}=e,r=this.handleRequest({request:t,event:e});r&&e.respondWith(r)}))}addCacheListener(){self.addEventListener("message",(e=>{if(e.data&&"CACHE_URLS"===e.data.type){const{payload:t}=e.data;r.logger.debug("Caching URLs from the window",t.urlsToCache);const o=Promise.all(t.urlsToCache.map((e=>{"string"==typeof e&&(e=[e]);const t=new Request(...e);return this.handleRequest({request:t})})));e.waitUntil(o),e.ports&&e.ports[0]&&o.then((()=>e.ports[0].postMessage(!0)))}}))}handleRequest({request:e,event:o}){t.assert.isInstance(e,Request,{moduleName:"workbox-routing",className:"Router",funcName:"handleRequest",paramName:"options.request"});const s=new URL(e.url,location.href);if(!s.protocol.startsWith("http"))return void r.logger.debug("Workbox Router only supports URLs that start with 'http'.");const{params:n,route:i}=this.findMatchingRoute({url:s,request:e,event:o});let u=i&&i.handler;const l=[];if(u&&(l.push(["Found a route to handle this request:",i]),n&&l.push(["Passing the following params to the route's handler:",n])),!u&&this._defaultHandler&&(l.push("Failed to find a matching route. Falling back to the default handler."),u=this._defaultHandler),!u)return void r.logger.debug(`No route found for: ${a.getFriendlyURL(s)}`);let c;r.logger.groupCollapsed(`Router is responding to: ${a.getFriendlyURL(s)}`),l.forEach((e=>{Array.isArray(e)?r.logger.log(...e):r.logger.log(e)})),r.logger.groupEnd();try{c=u.handle({url:s,request:e,event:o,params:n})}catch(e){c=Promise.reject(e)}return c instanceof Promise&&this._catchHandler&&(c=c.catch((t=>(r.logger.groupCollapsed(`Error thrown when responding to:  ${a.getFriendlyURL(s)}. Falling back to Catch Handler.`),r.logger.error("Error thrown by:",i),r.logger.error(t),r.logger.groupEnd(),this._catchHandler.handle({url:s,request:e,event:o}))))),c}findMatchingRoute({url:e,request:r,event:o}){t.assert.isInstance(e,URL,{moduleName:"workbox-routing",className:"Router",funcName:"findMatchingRoute",paramName:"options.url"}),t.assert.isInstance(r,Request,{moduleName:"workbox-routing",className:"Router",funcName:"findMatchingRoute",paramName:"options.request"});const a=this._routes.get(r.method)||[];for(const t of a){let a;const s=t.match({url:e,request:r,event:o});if(s)return a=s,(Array.isArray(s)&&0===s.length||s.constructor===Object&&0===Object.keys(s).length||"boolean"==typeof s)&&(a=void 0),{route:t,params:a}}return{}}setDefaultHandler(e){this._defaultHandler=n(e)}setCatchHandler(e){this._catchHandler=n(e)}registerRoute(e){t.assert.isType(e,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),t.assert.hasMethod(e,"match",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),t.assert.isType(e.handler,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),t.assert.hasMethod(e.handler,"handle",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.handler"}),t.assert.isType(e.method,"string",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.method"}),this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new o.WorkboxError("unregister-route-but-not-found-with-method",{method:e.method});const t=this._routes.get(e.method).indexOf(e);if(!(t>-1))throw new o.WorkboxError("unregister-route-route-not-registered");this._routes.get(e.method).splice(t,1)}}let c;const h=()=>(c||(c=new l,c.addFetchListener(),c.addCacheListener()),c);return e.NavigationRoute=class extends i{constructor(e,{allowlist:r=[/./],denylist:o=[]}={}){t.assert.isArrayOfClass(r,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.allowlist"}),t.assert.isArrayOfClass(o,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.denylist"}),super((e=>this._match(e)),e),this._allowlist=r,this._denylist=o}_match({url:e,request:t}){if(t&&"navigate"!==t.mode)return!1;const o=e.pathname+e.search;for(const e of this._denylist)if(e.test(o))return r.logger.log(`The navigation route ${o} is not being used, since the URL matches this denylist pattern: ${e}`),!1;return this._allowlist.some((e=>e.test(o)))?(r.logger.debug(`The navigation route ${o} is being used.`),!0):(r.logger.log(`The navigation route ${o} is not being used, since the URL being navigated to doesn't match the allowlist.`),!1)}},e.RegExpRoute=u,e.Route=i,e.Router=l,e.registerRoute=function(e,t,a){let s;if("string"==typeof e){const n=new URL(e,location.href);{if(!e.startsWith("/")&&!e.startsWith("http"))throw new o.WorkboxError("invalid-string",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});const t=e.startsWith("http")?n.pathname:e,a="[*:?+]";new RegExp(`${a}`).exec(t)&&r.logger.debug(`The '$capture' parameter contains an Express-style wildcard character (${a}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`)}s=new i((({url:t})=>(t.pathname===n.pathname&&t.origin!==n.origin&&r.logger.debug(`${e} only partially matches the cross-origin URL ${t}. This route will only handle cross-origin requests if they match the entire URL.`),t.href===n.href)),t,a)}else if(e instanceof RegExp)s=new u(e,t,a);else if("function"==typeof e)s=new i(e,t,a);else{if(!(e instanceof i))throw new o.WorkboxError("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});s=e}return h().registerRoute(s),s},e.setCatchHandler=function(e){h().setCatchHandler(e)},e.setDefaultHandler=function(e){h().setDefaultHandler(e)},e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);