this.workbox=this.workbox||{},this.workbox.precaching=function(e,t,r,a,o,n,c,s,i){"use strict";try{self["workbox:precaching:5.1.4"]&&_()}catch(e){}const h=[],l={get:()=>h,add(e){h.push(...e)}};function u(e){if(!e)throw new s.WorkboxError("add-to-cache-list-unexpected-type",{entry:e});if("string"==typeof e){const t=new URL(e,location.href);return{cacheKey:t.href,url:t.href}}const{revision:t,url:r}=e;if(!r)throw new s.WorkboxError("add-to-cache-list-unexpected-type",{entry:e});if(!t){const e=new URL(r,location.href);return{cacheKey:e.href,url:e.href}}const a=new URL(r,location.href),o=new URL(r,location.href);return a.searchParams.set("__WB_REVISION__",t),{cacheKey:a.href,url:o.href}}function g(e){const t=e.length;t>0&&(a.logger.groupCollapsed(`During precaching cleanup, ${t} cached request${1===t?" was":"s were"} deleted.`),((e,t)=>{a.logger.groupCollapsed(e);for(const e of t)a.logger.log(e);a.logger.groupEnd()})("Deleted Cache Requests",e),a.logger.groupEnd())}function d(e,t){if(0!==t.length){a.logger.groupCollapsed(e);for(const e of t)a.logger.log(e);a.logger.groupEnd()}}class f{constructor(e){this._cacheName=t.cacheNames.getPrecacheName(e),this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map}addToCacheList(e){o.assert.isArray(e,{moduleName:"workbox-precaching",className:"PrecacheController",funcName:"addToCacheList",paramName:"entries"});const t=[];for(const r of e){"string"==typeof r?t.push(r):r&&void 0===r.revision&&t.push(r.url);const{cacheKey:e,url:o}=u(r),n="string"!=typeof r&&r.revision?"reload":"default";if(this._urlsToCacheKeys.has(o)&&this._urlsToCacheKeys.get(o)!==e)throw new s.WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(o),secondEntry:e});if("string"!=typeof r&&r.integrity){if(this._cacheKeysToIntegrities.has(e)&&this._cacheKeysToIntegrities.get(e)!==r.integrity)throw new s.WorkboxError("add-to-cache-list-conflicting-integrities",{url:o});this._cacheKeysToIntegrities.set(e,r.integrity)}if(this._urlsToCacheKeys.set(o,e),this._urlsToCacheModes.set(o,n),t.length>0){const e=`Workbox is precaching URLs without revision info: ${t.join(", ")}\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;a.logger.warn(e)}}}async install({event:e,plugins:t}={}){t&&o.assert.isArray(t,{moduleName:"workbox-precaching",className:"PrecacheController",funcName:"install",paramName:"plugins"});const r=[],n=[],c=await self.caches.open(this._cacheName),s=await c.keys(),i=new Set(s.map((e=>e.url)));for(const[e,t]of this._urlsToCacheKeys)i.has(t)?n.push(e):r.push({cacheKey:t,url:e});const h=r.map((({cacheKey:r,url:a})=>{const o=this._cacheKeysToIntegrities.get(r),n=this._urlsToCacheModes.get(a);return this._addURLToCache({cacheKey:r,cacheMode:n,event:e,integrity:o,plugins:t,url:a})}));await Promise.all(h);const l=r.map((e=>e.url));return function(e,t){const r=e.length,o=t.length;if(r||o){let n=`Precaching ${r} file${1===r?"":"s"}.`;o>0&&(n+=` ${o} file${1===o?" is":"s are"} already cached.`),a.logger.groupCollapsed(n),d("View newly precached URLs.",e),d("View previously precached URLs.",t),a.logger.groupEnd()}}(l,n),{updatedURLs:l,notUpdatedURLs:n}}async activate(){const e=await self.caches.open(this._cacheName),t=await e.keys(),r=new Set(this._urlsToCacheKeys.values()),a=[];for(const o of t)r.has(o.url)||(await e.delete(o),a.push(o.url));return g(a),{deletedURLs:a}}async _addURLToCache({cacheKey:e,url:t,cacheMode:r,event:a,plugins:o,integrity:h}){const l=new Request(t,{integrity:h,cache:r,credentials:"same-origin"});let u,g=await c.fetchWrapper.fetch({event:a,plugins:o,request:l});for(const e of o||[])"cacheWillUpdate"in e&&(u=e);if(!(u?await u.cacheWillUpdate({event:a,request:l,response:g}):g.status<400))throw new s.WorkboxError("bad-precaching-response",{url:t,status:g.status});g.redirected&&(g=await i.copyResponse(g)),await n.cacheWrapper.put({event:a,plugins:o,response:g,request:e===t?l:new Request(e),cacheName:this._cacheName,matchOptions:{ignoreSearch:!0}})}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(e){const t=new URL(e,location.href);return this._urlsToCacheKeys.get(t.href)}async matchPrecache(e){const t=e instanceof Request?e.url:e,r=this.getCacheKeyForURL(t);if(r){return(await self.caches.open(this._cacheName)).match(r)}}createHandler(e=!0){return async({request:t})=>{try{const e=await this.matchPrecache(t);if(e)return e;throw new s.WorkboxError("missing-precache-entry",{cacheName:this._cacheName,url:t instanceof Request?t.url:t})}catch(r){if(e)return a.logger.debug("Unable to respond with precached response. Falling back to network.",r),fetch(t);throw r}}}createHandlerBoundToURL(e,t=!0){if(!this.getCacheKeyForURL(e))throw new s.WorkboxError("non-precached-url",{url:e});const r=this.createHandler(t),a=new Request(e);return()=>r({request:a})}}let p;const w=()=>(p||(p=new f),p);const y=(e,t)=>{const r=w().getURLsToCacheKeys();for(const a of function*(e,{ignoreURLParametersMatching:t,directoryIndex:r,cleanURLs:a,urlManipulation:o}={}){const n=new URL(e,location.href);n.hash="",yield n.href;const c=function(e,t=[]){for(const r of[...e.searchParams.keys()])t.some((e=>e.test(r)))&&e.searchParams.delete(r);return e}(n,t);if(yield c.href,r&&c.pathname.endsWith("/")){const e=new URL(c.href);e.pathname+=r,yield e.href}if(a){const e=new URL(c.href);e.pathname+=".html",yield e.href}if(o){const e=o({url:n});for(const t of e)yield t.href}}(e,t)){const e=r.get(a);if(e)return e}};let m=!1;function R(e){m||((({ignoreURLParametersMatching:e=[/^utm_/],directoryIndex:o="index.html",cleanURLs:n=!0,urlManipulation:c}={})=>{const s=t.cacheNames.getPrecacheName();self.addEventListener("fetch",(t=>{const i=y(t.request.url,{cleanURLs:n,directoryIndex:o,ignoreURLParametersMatching:e,urlManipulation:c});if(!i)return void a.logger.debug("Precaching did not find a match for "+r.getFriendlyURL(t.request.url));let h=self.caches.open(s).then((e=>e.match(i))).then((e=>e||(a.logger.warn(`The precached response for ${r.getFriendlyURL(i)} in ${s} was not found. Falling back to the network instead.`),fetch(i))));h=h.then((e=>(a.logger.groupCollapsed("Precaching is responding to: "+r.getFriendlyURL(t.request.url)),a.logger.log(`Serving the precached url: ${i}`),a.logger.groupCollapsed("View request details here."),a.logger.log(t.request),a.logger.groupEnd(),a.logger.groupCollapsed("View response details here."),a.logger.log(e),a.logger.groupEnd(),a.logger.groupEnd(),e))),t.respondWith(h)}))})(e),m=!0)}const L=e=>{const t=w(),r=l.get();e.waitUntil(t.install({event:e,plugins:r}).catch((e=>{throw a.logger.error("Service worker installation failed. It will be retried automatically during the next navigation."),e})))},U=e=>{const t=w();e.waitUntil(t.activate())};function C(e){w().addToCacheList(e),e.length>0&&(self.addEventListener("install",L),self.addEventListener("activate",U))}return e.PrecacheController=f,e.addPlugins=function(e){l.add(e)},e.addRoute=R,e.cleanupOutdatedCaches=function(){self.addEventListener("activate",(e=>{const r=t.cacheNames.getPrecacheName();e.waitUntil((async(e,t="-precache-")=>{const r=(await self.caches.keys()).filter((r=>r.includes(t)&&r.includes(self.registration.scope)&&r!==e));return await Promise.all(r.map((e=>self.caches.delete(e)))),r})(r).then((e=>{e.length>0&&a.logger.log("The following out-of-date precaches were cleaned up automatically:",e)})))}))},e.createHandler=function(e=!0){return w().createHandler(e)},e.createHandlerBoundToURL=function(e){return w().createHandlerBoundToURL(e)},e.getCacheKeyForURL=function(e){return w().getCacheKeyForURL(e)},e.matchPrecache=function(e){return w().matchPrecache(e)},e.precache=C,e.precacheAndRoute=function(e,t){C(e),R(t)},e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);