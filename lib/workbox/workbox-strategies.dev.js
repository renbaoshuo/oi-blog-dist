this.workbox=this.workbox||{},this.workbox.strategies=function(e,t,s,r,o,a,n,i){"use strict";try{self["workbox:strategies:5.1.4"]&&_()}catch(e){}const c=(e,t)=>`Using ${e} to respond to '${a.getFriendlyURL(t.url)}'`,h=e=>{e&&(n.logger.groupCollapsed("View the final response here."),n.logger.log(e||"[No response returned]"),n.logger.groupEnd())};const u={cacheWillUpdate:async({response:e})=>200===e.status||0===e.status?e:null};return e.CacheFirst=class{constructor(e={}){this._cacheName=s.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._fetchOptions=e.fetchOptions,this._matchOptions=e.matchOptions}async handle({event:e,request:s}){const o=[];"string"==typeof s&&(s=new Request(s)),t.assert.isInstance(s,Request,{moduleName:"workbox-strategies",className:"CacheFirst",funcName:"makeRequest",paramName:"request"});let a,u=await r.cacheWrapper.match({cacheName:this._cacheName,request:s,event:e,matchOptions:this._matchOptions,plugins:this._plugins});if(u)o.push(`Found a cached response in the '${this._cacheName}' cache.`);else{o.push(`No response found in the '${this._cacheName}' cache. Will respond with a network request.`);try{u=await this._getFromNetwork(s,e)}catch(e){a=e}u?o.push("Got response from network."):o.push("Unable to get a response from the network.")}n.logger.groupCollapsed(c("CacheFirst",s));for(const e of o)n.logger.log(e);if(h(u),n.logger.groupEnd(),!u)throw new i.WorkboxError("no-response",{url:s.url,error:a});return u}async _getFromNetwork(e,t){const s=await o.fetchWrapper.fetch({request:e,event:t,fetchOptions:this._fetchOptions,plugins:this._plugins}),i=s.clone(),c=r.cacheWrapper.put({cacheName:this._cacheName,request:e,response:i,event:t,plugins:this._plugins});if(t)try{t.waitUntil(c)}catch(t){n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${a.getFriendlyURL(e.url)}'.`)}return s}},e.CacheOnly=class{constructor(e={}){this._cacheName=s.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._matchOptions=e.matchOptions}async handle({event:e,request:s}){"string"==typeof s&&(s=new Request(s)),t.assert.isInstance(s,Request,{moduleName:"workbox-strategies",className:"CacheOnly",funcName:"makeRequest",paramName:"request"});const o=await r.cacheWrapper.match({cacheName:this._cacheName,request:s,event:e,matchOptions:this._matchOptions,plugins:this._plugins});if(n.logger.groupCollapsed(c("CacheOnly",s)),o?(n.logger.log(`Found a cached response in the '${this._cacheName}' cache.`),h(o)):n.logger.log(`No response found in the '${this._cacheName}' cache.`),n.logger.groupEnd(),!o)throw new i.WorkboxError("no-response",{url:s.url});return o}},e.NetworkFirst=class{constructor(e={}){if(this._cacheName=s.cacheNames.getRuntimeName(e.cacheName),e.plugins){const t=e.plugins.some((e=>!!e.cacheWillUpdate));this._plugins=t?e.plugins:[u,...e.plugins]}else this._plugins=[u];this._networkTimeoutSeconds=e.networkTimeoutSeconds||0,this._networkTimeoutSeconds&&t.assert.isType(this._networkTimeoutSeconds,"number",{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"constructor",paramName:"networkTimeoutSeconds"}),this._fetchOptions=e.fetchOptions,this._matchOptions=e.matchOptions}async handle({event:e,request:s}){const r=[];"string"==typeof s&&(s=new Request(s)),t.assert.isInstance(s,Request,{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"handle",paramName:"makeRequest"});const o=[];let a;if(this._networkTimeoutSeconds){const{id:t,promise:n}=this._getTimeoutPromise({request:s,event:e,logs:r});a=t,o.push(n)}const u=this._getNetworkPromise({timeoutId:a,request:s,event:e,logs:r});o.push(u);let l=await Promise.race(o);l||(l=await u),n.logger.groupCollapsed(c("NetworkFirst",s));for(const e of r)n.logger.log(e);if(h(l),n.logger.groupEnd(),!l)throw new i.WorkboxError("no-response",{url:s.url});return l}_getTimeoutPromise({request:e,logs:t,event:s}){let r;return{promise:new Promise((o=>{r=setTimeout((async()=>{t.push(`Timing out the network response at ${this._networkTimeoutSeconds} seconds.`),o(await this._respondFromCache({request:e,event:s}))}),1e3*this._networkTimeoutSeconds)})),id:r}}async _getNetworkPromise({timeoutId:e,request:t,logs:s,event:i}){let c,h;try{h=await o.fetchWrapper.fetch({request:t,event:i,fetchOptions:this._fetchOptions,plugins:this._plugins})}catch(e){c=e}if(e&&clearTimeout(e),h?s.push("Got response from network."):s.push("Unable to get a response from the network. Will respond with a cached response."),c||!h)h=await this._respondFromCache({request:t,event:i}),h?s.push(`Found a cached response in the '${this._cacheName}' cache.`):s.push(`No response found in the '${this._cacheName}' cache.`);else{const e=h.clone(),s=r.cacheWrapper.put({cacheName:this._cacheName,request:t,response:e,event:i,plugins:this._plugins});if(i)try{i.waitUntil(s)}catch(e){n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${a.getFriendlyURL(t.url)}'.`)}}return h}_respondFromCache({event:e,request:t}){return r.cacheWrapper.match({cacheName:this._cacheName,request:t,event:e,matchOptions:this._matchOptions,plugins:this._plugins})}},e.NetworkOnly=class{constructor(e={}){this._plugins=e.plugins||[],this._fetchOptions=e.fetchOptions}async handle({event:e,request:s}){let r,a;"string"==typeof s&&(s=new Request(s)),t.assert.isInstance(s,Request,{moduleName:"workbox-strategies",className:"NetworkOnly",funcName:"handle",paramName:"request"});try{a=await o.fetchWrapper.fetch({request:s,event:e,fetchOptions:this._fetchOptions,plugins:this._plugins})}catch(e){r=e}if(n.logger.groupCollapsed(c("NetworkOnly",s)),a?n.logger.log("Got response from network."):n.logger.log("Unable to get a response from the network."),h(a),n.logger.groupEnd(),!a)throw new i.WorkboxError("no-response",{url:s.url,error:r});return a}},e.StaleWhileRevalidate=class{constructor(e={}){if(this._cacheName=s.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],e.plugins){const t=e.plugins.some((e=>!!e.cacheWillUpdate));this._plugins=t?e.plugins:[u,...e.plugins]}else this._plugins=[u];this._fetchOptions=e.fetchOptions,this._matchOptions=e.matchOptions}async handle({event:e,request:s}){const o=[];"string"==typeof s&&(s=new Request(s)),t.assert.isInstance(s,Request,{moduleName:"workbox-strategies",className:"StaleWhileRevalidate",funcName:"handle",paramName:"request"});const u=this._getFromNetwork({request:s,event:e});let l,p=await r.cacheWrapper.match({cacheName:this._cacheName,request:s,event:e,matchOptions:this._matchOptions,plugins:this._plugins});if(p){if(o.push(`Found a cached response in the '${this._cacheName}' cache. Will update with the network response in the background.`),e)try{e.waitUntil(u)}catch(l){n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${a.getFriendlyURL(s.url)}'.`)}}else{o.push(`No response found in the '${this._cacheName}' cache. Will wait for the network response.`);try{p=await u}catch(e){l=e}}n.logger.groupCollapsed(c("StaleWhileRevalidate",s));for(const e of o)n.logger.log(e);if(h(p),n.logger.groupEnd(),!p)throw new i.WorkboxError("no-response",{url:s.url,error:l});return p}async _getFromNetwork({request:e,event:t}){const s=await o.fetchWrapper.fetch({request:e,event:t,fetchOptions:this._fetchOptions,plugins:this._plugins}),i=r.cacheWrapper.put({cacheName:this._cacheName,request:e,response:s.clone(),event:t,plugins:this._plugins});if(t)try{t.waitUntil(i)}catch(t){n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${a.getFriendlyURL(e.url)}'.`)}return s}},e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);